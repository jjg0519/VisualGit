<?xml version="1.0"?>
<doc>
    <assembly>
        <name>NGit</name>
    </assembly>
    <members>
        <!-- Badly formed XML comment ignored for member "T:NGit.Api.StashDropCommand" -->
        <!-- Badly formed XML comment ignored for member "T:NGit.Api.GitCommand`1" -->
        <member name="F:NGit.Api.GitCommand`1.repo">
            <summary>The repository this command is working with</summary>
        </member>
        <member name="F:NGit.Api.GitCommand`1.callable">
            <summary>
            a state which tells whether it is allowed to call
            <see cref="M:NGit.Api.GitCommand`1.Call">GitCommand&lt;T&gt;.Call()</see>
            on this
            instance.
            </summary>
        </member>
        <member name="M:NGit.Api.GitCommand`1.#ctor(NGit.Repository)">
            <summary>Creates a new command which interacts with a single repository</summary>
            <param name="repo">
            the
            <see cref="T:NGit.Repository">NGit.Repository</see>
            this command should interact with
            </param>
        </member>
        <member name="M:NGit.Api.GitCommand`1.GetRepository">
            <returns>
            the
            <see cref="T:NGit.Repository">NGit.Repository</see>
            this command is interacting with
            </returns>
        </member>
        <member name="M:NGit.Api.GitCommand`1.SetCallable(System.Boolean)">
            <summary>
            Set's the state which tells whether it is allowed to call
            <see cref="M:NGit.Api.GitCommand`1.Call">GitCommand&lt;T&gt;.Call()</see>
            on this instance.
            <see cref="M:NGit.Api.GitCommand`1.CheckCallable">GitCommand&lt;T&gt;.CheckCallable()</see>
            will throw an exception when
            called and this property is set to
            <code>false</code>
            </summary>
            <param name="callable">
            if <code>true</code> it is allowed to call
            <see cref="M:NGit.Api.GitCommand`1.Call">GitCommand&lt;T&gt;.Call()</see>
            on
            this instance.
            </param>
        </member>
        <member name="M:NGit.Api.GitCommand`1.CheckCallable">
            <summary>
            Checks that the property
            <see cref="F:NGit.Api.GitCommand`1.callable">GitCommand&lt;T&gt;.callable</see>
            is
            <code>true</code>
            . If not then
            an
            <see cref="T:System.InvalidOperationException">System.InvalidOperationException</see>
            is thrown
            </summary>
            <exception cref="T:System.InvalidOperationException">
            when this method is called and the property
            <see cref="F:NGit.Api.GitCommand`1.callable">GitCommand&lt;T&gt;.callable</see>
            is
            <code>false</code>
            </exception>
        </member>
        <member name="M:NGit.Api.GitCommand`1.Call">
            <summary>Executes the command</summary>
            <returns>T a result. Each command has its own return type</returns>
            <exception cref="T:NGit.Api.Errors.GitAPIException">or subclass thereof when an error occurs
            	</exception>
        </member>
        <member name="M:NGit.Api.StashDropCommand.#ctor(NGit.Repository)">
            <param name="repo"></param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Api.StashDropCommand.SetStashRef(System.Int32)" -->
        <member name="M:NGit.Api.StashDropCommand.SetAll(System.Boolean)">
            <summary>Set wheter drop all stashed commits</summary>
            <param name="all">
            true to drop all stashed commits, false to drop only the
            stashed commit set via calling
            <see cref="M:NGit.Api.StashDropCommand.SetStashRef(System.Int32)">SetStashRef(int)</see>
            </param>
            <returns>
            
            <code>this</code>
            </returns>
        </member>
        <member name="M:NGit.Api.StashDropCommand.GetRef">
            <exception cref="T:NGit.Api.Errors.GitAPIException"></exception>
        </member>
        <member name="M:NGit.Api.StashDropCommand.CreateRefUpdate(NGit.Ref)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Api.StashDropCommand.Call">
            <summary>
            Drop the configured entry from the stash reflog and return value of the
            stash reference after the drop occurs
            </summary>
            <returns>commit id of stash reference or null if no more stashed changes</returns>
            <exception cref="T:NGit.Api.Errors.GitAPIException">NGit.Api.Errors.GitAPIException
            	</exception>
        </member>
        <member name="T:NGit.Submodule.SubmoduleStatus">
            <summary>Status class containing the type, path, and commit id of the submodule.</summary>
            <remarks>Status class containing the type, path, and commit id of the submodule.</remarks>
        </member>
        <member name="M:NGit.Submodule.SubmoduleStatus.#ctor(NGit.Submodule.SubmoduleStatusType,System.String,NGit.ObjectId)">
            <summary>Create submodule status</summary>
            <param name="type"></param>
            <param name="path"></param>
            <param name="indexId"></param>
        </member>
        <member name="M:NGit.Submodule.SubmoduleStatus.#ctor(NGit.Submodule.SubmoduleStatusType,System.String,NGit.ObjectId,NGit.ObjectId)">
            <summary>Create submodule status</summary>
            <param name="type"></param>
            <param name="path"></param>
            <param name="indexId"></param>
            <param name="headId"></param>
        </member>
        <member name="M:NGit.Submodule.SubmoduleStatus.GetType">
            <returns>type</returns>
        </member>
        <member name="M:NGit.Submodule.SubmoduleStatus.GetPath">
            <returns>path</returns>
        </member>
        <member name="M:NGit.Submodule.SubmoduleStatus.GetIndexId">
            <returns>index object id</returns>
        </member>
        <member name="M:NGit.Submodule.SubmoduleStatus.GetHeadId">
            <returns>HEAD object id</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Api.SubmoduleInitCommand" -->
        <member name="M:NGit.Api.SubmoduleInitCommand.#ctor(NGit.Repository)">
            <param name="repo"></param>
        </member>
        <member name="M:NGit.Api.SubmoduleInitCommand.AddPath(System.String)">
            <summary>Add repository-relative submodule path to initialize</summary>
            <param name="path"></param>
            <returns>this command</returns>
        </member>
        <member name="M:NGit.Api.SubmoduleInitCommand.Call">
            <exception cref="T:NGit.Api.Errors.GitAPIException"></exception>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Api.ListNotesCommand" -->
        <member name="M:NGit.Api.ListNotesCommand.#ctor(NGit.Repository)">
            <param name="repo"></param>
        </member>
        <member name="M:NGit.Api.ListNotesCommand.Call">
            <returns>the requested notes</returns>
            <exception cref="T:NGit.Api.Errors.GitAPIException"></exception>
        </member>
        <member name="M:NGit.Api.ListNotesCommand.SetNotesRef(System.String)">
            <param name="notesRef">
            the ref to read notes from. Note, the default value of
            <see cref="F:NGit.Constants.R_NOTES_COMMITS">NGit.Constants.R_NOTES_COMMITS</see>
            will be used if nothing is
            set
            </param>
            <returns>
            
            <code>this</code>
            </returns>
            <seealso cref="F:NGit.Constants.R_NOTES_COMMITS">NGit.Constants.R_NOTES_COMMITS</seealso>
        </member>
        <member name="T:NGit.Notes.Note">
            <summary>In-memory representation of a single note attached to one object.</summary>
            <remarks>In-memory representation of a single note attached to one object.</remarks>
        </member>
        <member name="T:NGit.ObjectId">
            <summary>A SHA-1 abstraction.</summary>
            <remarks>A SHA-1 abstraction.</remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.AnyObjectId" -->
        <member name="M:NGit.AnyObjectId.Equals(NGit.AnyObjectId,NGit.AnyObjectId)">
            <summary>Compare to object identifier byte sequences for equality.</summary>
            <remarks>Compare to object identifier byte sequences for equality.</remarks>
            <param name="firstObjectId">the first identifier to compare. Must not be null.</param>
            <param name="secondObjectId">the second identifier to compare. Must not be null.</param>
            <returns>true if the two identifiers are the same.</returns>
        </member>
        <member name="M:NGit.AnyObjectId.GetByte(System.Int32)">
            <summary>Get any byte from the ObjectId.</summary>
            <remarks>
            Get any byte from the ObjectId.
            Callers hard-coding
            <code>getByte(0)</code>
            should instead use the much faster
            special case variant
            <see cref="P:NGit.AnyObjectId.FirstByte">FirstByte()</see>
            .
            </remarks>
            <param name="index">
            index of the byte to obtain from the raw form of the ObjectId.
            Must be in range [0,
            <see cref="F:NGit.Constants.OBJECT_ID_LENGTH">Constants.OBJECT_ID_LENGTH</see>
            ).
            </param>
            <returns>
            the value of the requested byte at
            <code>index</code>
            . Returned values
            are unsigned and thus are in the range [0,255] rather than the
            signed byte range of [-128, 127].
            </returns>
            <exception cref="T:System.IndexOutOfRangeException">
            <code>index</code>
            is less than 0, equal to
            <see cref="F:NGit.Constants.OBJECT_ID_LENGTH">Constants.OBJECT_ID_LENGTH</see>
            , or greater than
            <see cref="F:NGit.Constants.OBJECT_ID_LENGTH">Constants.OBJECT_ID_LENGTH</see>
            .
            </exception>
        </member>
        <member name="M:NGit.AnyObjectId.CompareTo(NGit.AnyObjectId)">
            <summary>Compare this ObjectId to another and obtain a sort ordering.</summary>
            <remarks>Compare this ObjectId to another and obtain a sort ordering.</remarks>
            <param name="other">the other id to compare to. Must not be null.</param>
            <returns>
            &lt; 0 if this id comes before other; 0 if this id is equal to
            other; &gt; 0 if this id comes after other.
            </returns>
        </member>
        <member name="M:NGit.AnyObjectId.CompareTo(System.Byte[],System.Int32)">
            <summary>Compare this ObjectId to a network-byte-order ObjectId.</summary>
            <remarks>Compare this ObjectId to a network-byte-order ObjectId.</remarks>
            <param name="bs">array containing the other ObjectId in network byte order.</param>
            <param name="p">
            position within
            <code>bs</code>
            to start the compare at. At least
            20 bytes, starting at this position are required.
            </param>
            <returns>
            a negative integer, zero, or a positive integer as this object is
            less than, equal to, or greater than the specified object.
            </returns>
        </member>
        <member name="M:NGit.AnyObjectId.CompareTo(System.Int32[],System.Int32)">
            <summary>Compare this ObjectId to a network-byte-order ObjectId.</summary>
            <remarks>Compare this ObjectId to a network-byte-order ObjectId.</remarks>
            <param name="bs">array containing the other ObjectId in network byte order.</param>
            <param name="p">
            position within
            <code>bs</code>
            to start the compare at. At least 5
            integers, starting at this position are required.
            </param>
            <returns>
            a negative integer, zero, or a positive integer as this object is
            less than, equal to, or greater than the specified object.
            </returns>
        </member>
        <member name="M:NGit.AnyObjectId.StartsWith(NGit.AbbreviatedObjectId)">
            <summary>Tests if this ObjectId starts with the given abbreviation.</summary>
            <remarks>Tests if this ObjectId starts with the given abbreviation.</remarks>
            <param name="abbr">the abbreviation.</param>
            <returns>true if this ObjectId begins with the abbreviation; else false.</returns>
        </member>
        <member name="M:NGit.AnyObjectId.Equals(NGit.AnyObjectId)">
            <summary>Determine if this ObjectId has exactly the same value as another.</summary>
            <remarks>Determine if this ObjectId has exactly the same value as another.</remarks>
            <param name="other">the other id to compare to. May be null.</param>
            <returns>true only if both ObjectIds have identical bits.</returns>
        </member>
        <member name="M:NGit.AnyObjectId.CopyRawTo(Sharpen.ByteBuffer)">
            <summary>Copy this ObjectId to an output writer in raw binary.</summary>
            <remarks>Copy this ObjectId to an output writer in raw binary.</remarks>
            <param name="w">the buffer to copy to. Must be in big endian order.</param>
        </member>
        <member name="M:NGit.AnyObjectId.CopyRawTo(System.Byte[],System.Int32)">
            <summary>Copy this ObjectId to a byte array.</summary>
            <remarks>Copy this ObjectId to a byte array.</remarks>
            <param name="b">the buffer to copy to.</param>
            <param name="o">the offset within b to write at.</param>
        </member>
        <member name="M:NGit.AnyObjectId.CopyRawTo(System.Int32[],System.Int32)">
            <summary>Copy this ObjectId to an int array.</summary>
            <remarks>Copy this ObjectId to an int array.</remarks>
            <param name="b">the buffer to copy to.</param>
            <param name="o">the offset within b to write at.</param>
        </member>
        <member name="M:NGit.AnyObjectId.CopyRawTo(Sharpen.OutputStream)">
            <summary>Copy this ObjectId to an output writer in raw binary.</summary>
            <remarks>Copy this ObjectId to an output writer in raw binary.</remarks>
            <param name="w">the stream to write to.</param>
            <exception cref="T:System.IO.IOException">the stream writing failed.</exception>
        </member>
        <member name="M:NGit.AnyObjectId.WriteRawInt(Sharpen.OutputStream,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.AnyObjectId.CopyTo(Sharpen.OutputStream)">
            <summary>Copy this ObjectId to an output writer in hex format.</summary>
            <remarks>Copy this ObjectId to an output writer in hex format.</remarks>
            <param name="w">the stream to copy to.</param>
            <exception cref="T:System.IO.IOException">the stream writing failed.</exception>
        </member>
        <member name="M:NGit.AnyObjectId.CopyTo(System.Byte[],System.Int32)">
            <summary>Copy this ObjectId to a byte array in hex format.</summary>
            <remarks>Copy this ObjectId to a byte array in hex format.</remarks>
            <param name="b">the buffer to copy to.</param>
            <param name="o">the offset within b to write at.</param>
        </member>
        <member name="M:NGit.AnyObjectId.CopyTo(Sharpen.ByteBuffer)">
            <summary>Copy this ObjectId to a ByteBuffer in hex format.</summary>
            <remarks>Copy this ObjectId to a ByteBuffer in hex format.</remarks>
            <param name="b">the buffer to copy to.</param>
        </member>
        <member name="M:NGit.AnyObjectId.CopyTo(System.IO.TextWriter)">
            <summary>Copy this ObjectId to an output writer in hex format.</summary>
            <remarks>Copy this ObjectId to an output writer in hex format.</remarks>
            <param name="w">the stream to copy to.</param>
            <exception cref="T:System.IO.IOException">the stream writing failed.</exception>
        </member>
        <member name="M:NGit.AnyObjectId.CopyTo(System.Char[],System.IO.TextWriter)">
            <summary>Copy this ObjectId to an output writer in hex format.</summary>
            <remarks>Copy this ObjectId to an output writer in hex format.</remarks>
            <param name="tmp">
            temporary char array to buffer construct into before writing.
            Must be at least large enough to hold 2 digits for each byte
            of object id (40 characters or larger).
            </param>
            <param name="w">the stream to copy to.</param>
            <exception cref="T:System.IO.IOException">the stream writing failed.</exception>
        </member>
        <member name="M:NGit.AnyObjectId.CopyTo(System.Char[],System.Text.StringBuilder)">
            <summary>Copy this ObjectId to a StringBuilder in hex format.</summary>
            <remarks>Copy this ObjectId to a StringBuilder in hex format.</remarks>
            <param name="tmp">
            temporary char array to buffer construct into before writing.
            Must be at least large enough to hold 2 digits for each byte
            of object id (40 characters or larger).
            </param>
            <param name="w">the string to append onto.</param>
        </member>
        <member name="M:NGit.AnyObjectId.GetName">
            <returns>string form of the SHA-1, in lower case hexadecimal.</returns>
        </member>
        <member name="M:NGit.AnyObjectId.Abbreviate(System.Int32)">
            <summary>Return an abbreviation (prefix) of this object SHA-1.</summary>
            <remarks>
            Return an abbreviation (prefix) of this object SHA-1.
            This implementation does not guaranteeing uniqueness. Callers should
            instead use
            <see cref="M:NGit.ObjectReader.Abbreviate(NGit.AnyObjectId,System.Int32)">ObjectReader.Abbreviate(AnyObjectId, int)
            	</see>
            to obtain a
            unique abbreviation within the scope of a particular object database.
            </remarks>
            <param name="len">length of the abbreviated string.</param>
            <returns>SHA-1 abbreviation.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.AnyObjectId.Copy" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.AnyObjectId.ToObjectId" -->
        <member name="P:NGit.AnyObjectId.FirstByte">
            <summary>Get the first 8 bits of the ObjectId.</summary>
            <remarks>
            Get the first 8 bits of the ObjectId.
            This is a faster version of
            <code>getByte(0)</code>
            .
            </remarks>
            <returns>
            a discriminator usable for a fan-out style map. Returned values
            are unsigned and thus are in the range [0,255] rather than the
            signed byte range of [-128, 127].
            </returns>
        </member>
        <member name="P:NGit.AnyObjectId.Name">
            <returns>string form of the SHA-1, in lower case hexadecimal.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.ObjectId.IsId(System.String)" -->
        <member name="M:NGit.ObjectId.ToString(NGit.ObjectId)">
            <summary>Convert an ObjectId into a hex string representation.</summary>
            <remarks>Convert an ObjectId into a hex string representation.</remarks>
            <param name="i">the id to convert. May be null.</param>
            <returns>the hex string conversion of this id's content.</returns>
        </member>
        <member name="M:NGit.ObjectId.Equals(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>Compare to object identifier byte sequences for equality.</summary>
            <remarks>Compare to object identifier byte sequences for equality.</remarks>
            <param name="firstBuffer">
            the first buffer to compare against. Must have at least 20
            bytes from position ai through the end of the buffer.
            </param>
            <param name="fi">first offset within firstBuffer to begin testing.</param>
            <param name="secondBuffer">
            the second buffer to compare against. Must have at least 2
            bytes from position bi through the end of the buffer.
            </param>
            <param name="si">first offset within secondBuffer to begin testing.</param>
            <returns>true if the two identifiers are the same.</returns>
        </member>
        <member name="M:NGit.ObjectId.FromRaw(System.Byte[])">
            <summary>Convert an ObjectId from raw binary representation.</summary>
            <remarks>Convert an ObjectId from raw binary representation.</remarks>
            <param name="bs">
            the raw byte buffer to read from. At least 20 bytes must be
            available within this byte array.
            </param>
            <returns>the converted object id.</returns>
        </member>
        <member name="M:NGit.ObjectId.FromRaw(System.Byte[],System.Int32)">
            <summary>Convert an ObjectId from raw binary representation.</summary>
            <remarks>Convert an ObjectId from raw binary representation.</remarks>
            <param name="bs">
            the raw byte buffer to read from. At least 20 bytes after p
            must be available within this byte array.
            </param>
            <param name="p">position to read the first byte of data from.</param>
            <returns>the converted object id.</returns>
        </member>
        <member name="M:NGit.ObjectId.FromRaw(System.Int32[])">
            <summary>Convert an ObjectId from raw binary representation.</summary>
            <remarks>Convert an ObjectId from raw binary representation.</remarks>
            <param name="is">
            the raw integers buffer to read from. At least 5 integers must
            be available within this int array.
            </param>
            <returns>the converted object id.</returns>
        </member>
        <member name="M:NGit.ObjectId.FromRaw(System.Int32[],System.Int32)">
            <summary>Convert an ObjectId from raw binary representation.</summary>
            <remarks>Convert an ObjectId from raw binary representation.</remarks>
            <param name="is">
            the raw integers buffer to read from. At least 5 integers
            after p must be available within this int array.
            </param>
            <param name="p">position to read the first integer of data from.</param>
            <returns>the converted object id.</returns>
        </member>
        <member name="M:NGit.ObjectId.FromString(System.Byte[],System.Int32)">
            <summary>Convert an ObjectId from hex characters (US-ASCII).</summary>
            <remarks>Convert an ObjectId from hex characters (US-ASCII).</remarks>
            <param name="buf">
            the US-ASCII buffer to read from. At least 40 bytes after
            offset must be available within this byte array.
            </param>
            <param name="offset">position to read the first character from.</param>
            <returns>the converted object id.</returns>
        </member>
        <member name="M:NGit.ObjectId.FromString(System.String)">
            <summary>Convert an ObjectId from hex characters.</summary>
            <remarks>Convert an ObjectId from hex characters.</remarks>
            <param name="str">the string to read from. Must be 40 characters long.</param>
            <returns>the converted object id.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.ObjectId.#ctor(NGit.AnyObjectId)" -->
        <member name="M:NGit.ObjectId.WriteObject(Sharpen.ObjectOutputStream)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.ObjectId.ReadObject(Sharpen.ObjectInputStream)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="P:NGit.ObjectId.ZeroId">
            <summary>Get the special all-null ObjectId.</summary>
            <remarks>Get the special all-null ObjectId.</remarks>
            <returns>the all-null ObjectId, often used to stand-in for no object.</returns>
        </member>
        <member name="M:NGit.Notes.Note.#ctor(NGit.AnyObjectId,NGit.ObjectId)">
            <summary>
            A Git note about the object referenced by
            <code>noteOn</code>
            .
            </summary>
            <param name="noteOn">the object that has a note attached to it.</param>
            <param name="noteData">the actual note data contained in this note</param>
        </member>
        <member name="M:NGit.Notes.Note.GetData">
            <returns>the note content</returns>
        </member>
        <member name="T:NGit.Api.Errors.CannotDeleteCurrentBranchException">
            <summary>Thrown when trying to delete a branch which is currently checked out</summary>
        </member>
        <member name="T:NGit.Api.Errors.GitAPIException">
            <summary>
            Superclass of all exceptions thrown by the API classes in
            <code>org.eclipse.jgit.api</code>
            </summary>
        </member>
        <member name="M:NGit.Api.Errors.CannotDeleteCurrentBranchException.#ctor(System.String)">
            <param name="message">the message</param>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Api.FetchCommand" -->
        <!-- Badly formed XML comment ignored for member "T:NGit.Api.TransportCommand`2" -->
        <member name="F:NGit.Api.TransportCommand`2.credentialsProvider">
            <summary>Configured credentials provider</summary>
        </member>
        <member name="F:NGit.Api.TransportCommand`2.timeout">
            <summary>Configured transport timeout</summary>
        </member>
        <member name="F:NGit.Api.TransportCommand`2.transportConfigCallback">
            <summary>Configured callback for transport configuration</summary>
        </member>
        <member name="M:NGit.Api.TransportCommand`2.#ctor(NGit.Repository)">
            <param name="repo"></param>
        </member>
        <member name="M:NGit.Api.TransportCommand`2.SetCredentialsProvider(NGit.Transport.CredentialsProvider)">
            <param name="credentialsProvider">
            the
            <see cref="T:NGit.Transport.CredentialsProvider">NGit.Transport.CredentialsProvider
            	</see>
            to use
            </param>
            <returns>
            
            <code>this</code>
            </returns>
        </member>
        <member name="M:NGit.Api.TransportCommand`2.SetTimeout(System.Int32)">
            <param name="timeout">the timeout used for the transport step</param>
            <returns>
            
            <code>this</code>
            </returns>
        </member>
        <member name="M:NGit.Api.TransportCommand`2.SetTransportConfigCallback(NGit.Api.TransportConfigCallback)">
            <param name="transportConfigCallback">
            if set, the callback will be invoked after the
            <see cref="T:NGit.Transport.Transport">NGit.Transport.Transport</see>
            has created, but before the
            <see cref="T:NGit.Transport.Transport">NGit.Transport.Transport</see>
            is used. The callback can use this
            opportunity to set additional type-specific configuration on
            the
            <see cref="T:NGit.Transport.Transport">NGit.Transport.Transport</see>
            instance.
            </param>
            <returns>
            
            <code>this</code>
            </returns>
        </member>
        <member name="M:NGit.Api.TransportCommand`2.Self">
            <returns>
            
            <code>this</code>
            
            </returns>
        </member>
        <member name="M:NGit.Api.TransportCommand`2.Configure(NGit.Transport.Transport)">
            <summary>
            Configure transport with credentials provider, timeout, and config
            callback
            </summary>
            <param name="transport"></param>
            <returns>
            
            <code>this</code>
            </returns>
        </member>
        <member name="M:NGit.Api.TransportCommand`2.Configure(NGit.Api.TransportCommand)">
            <summary>
            Configure a child command with the current configuration set in
            <code>this</code>
            command
            </summary>
            <param name="childCommand"></param>
            <returns>
            
            <code>this</code>
            </returns>
        </member>
        <member name="M:NGit.Api.FetchCommand.#ctor(NGit.Repository)">
            <param name="repo"></param>
        </member>
        <member name="M:NGit.Api.FetchCommand.Call">
            <summary>
            Executes the
            <code>fetch</code>
            command with all the options and parameters
            collected by the setter methods of this class. Each instance of this
            class should only be used for one invocation of the command (means: one
            call to
            <see cref="M:NGit.Api.FetchCommand.Call">Call()</see>
            )
            </summary>
            <returns>
            a
            <see cref="T:NGit.Transport.FetchResult">NGit.Transport.FetchResult</see>
            object representing the successful fetch
            result
            </returns>
            <exception cref="T:NGit.Api.Errors.InvalidRemoteException">when called with an invalid remote uri
            	</exception>
            <exception cref="T:NGit.Api.Errors.TransportException">when an error occurs during transport
            	</exception>
            <exception cref="T:NGit.Api.Errors.GitAPIException"></exception>
        </member>
        <member name="M:NGit.Api.FetchCommand.SetRemote(System.String)">
            <summary>The remote (uri or name) used for the fetch operation.</summary>
            <remarks>
            The remote (uri or name) used for the fetch operation. If no remote is
            set, the default value of <code>Constants.DEFAULT_REMOTE_NAME</code> will
            be used.
            </remarks>
            <seealso cref="F:NGit.Constants.DEFAULT_REMOTE_NAME">NGit.Constants.DEFAULT_REMOTE_NAME
            	</seealso>
            <param name="remote"></param>
            <returns>
            
            <code>this</code>
            </returns>
        </member>
        <member name="M:NGit.Api.FetchCommand.GetRemote">
            <returns>the remote used for the remote operation</returns>
        </member>
        <member name="M:NGit.Api.FetchCommand.GetTimeout">
            <returns>the timeout used for the fetch operation</returns>
        </member>
        <member name="M:NGit.Api.FetchCommand.IsCheckFetchedObjects">
            <returns>whether to check received objects checked for validity</returns>
        </member>
        <member name="M:NGit.Api.FetchCommand.SetCheckFetchedObjects(System.Boolean)">
            <summary>If set to true, objects received will be checked for validity</summary>
            <param name="checkFetchedObjects"></param>
            <returns>
            
            <code>this</code>
            </returns>
        </member>
        <member name="M:NGit.Api.FetchCommand.IsRemoveDeletedRefs">
            <returns>whether or not to remove refs which no longer exist in the source</returns>
        </member>
        <member name="M:NGit.Api.FetchCommand.SetRemoveDeletedRefs(System.Boolean)">
            <summary>If set to true, refs are removed which no longer exist in the source</summary>
            <param name="removeDeletedRefs"></param>
            <returns>
            
            <code>this</code>
            </returns>
        </member>
        <member name="M:NGit.Api.FetchCommand.GetProgressMonitor">
            <returns>the progress monitor for the fetch operation</returns>
        </member>
        <member name="M:NGit.Api.FetchCommand.SetProgressMonitor(NGit.ProgressMonitor)">
            <summary>The progress monitor associated with the fetch operation.</summary>
            <remarks>
            The progress monitor associated with the fetch operation. By default,
            this is set to <code>NullProgressMonitor</code>
            </remarks>
            <seealso cref="T:NGit.NullProgressMonitor">NGit.NullProgressMonitor</seealso>
            <param name="monitor"></param>
            <returns>
            
            <code>this</code>
            </returns>
        </member>
        <member name="M:NGit.Api.FetchCommand.GetRefSpecs">
            <returns>the ref specs</returns>
        </member>
        <member name="M:NGit.Api.FetchCommand.SetRefSpecs(NGit.Transport.RefSpec[])">
            <summary>The ref specs to be used in the fetch operation</summary>
            <param name="specs"></param>
            <returns>
            
            <code>this</code>
            </returns>
        </member>
        <member name="M:NGit.Api.FetchCommand.SetRefSpecs(System.Collections.Generic.IList{NGit.Transport.RefSpec})">
            <summary>The ref specs to be used in the fetch operation</summary>
            <param name="specs"></param>
            <returns>
            
            <code>this</code>
            </returns>
        </member>
        <member name="M:NGit.Api.FetchCommand.IsDryRun">
            <returns>the dry run preference for the fetch operation</returns>
        </member>
        <member name="M:NGit.Api.FetchCommand.SetDryRun(System.Boolean)">
            <summary>Sets whether the fetch operation should be a dry run</summary>
            <param name="dryRun"></param>
            <returns>
            
            <code>this</code>
            </returns>
        </member>
        <member name="M:NGit.Api.FetchCommand.IsThin">
            <returns>the thin-pack preference for fetch operation</returns>
        </member>
        <member name="M:NGit.Api.FetchCommand.SetThin(System.Boolean)">
            <summary>Sets the thin-pack preference for fetch operation.</summary>
            <remarks>
            Sets the thin-pack preference for fetch operation.
            Default setting is Transport.DEFAULT_FETCH_THIN
            </remarks>
            <param name="thin"></param>
            <returns>
            
            <code>this</code>
            </returns>
        </member>
        <member name="M:NGit.Api.FetchCommand.SetTagOpt(NGit.Transport.TagOpt)">
            <summary>Sets the specification of annotated tag behavior during fetch</summary>
            <param name="tagOpt"></param>
            <returns>
            
            <code>this</code>
            </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Transport.TransportSftp" -->
        <member name="T:NGit.Transport.SshTransport">
            <summary>The base class for transports that use SSH protocol.</summary>
            <remarks>
            The base class for transports that use SSH protocol. This class allows
            customizing SSH connection settings.
            </remarks>
        </member>
        <member name="T:NGit.Transport.TcpTransport">
            <summary>The base class for transports based on TCP sockets.</summary>
            <remarks>
            The base class for transports based on TCP sockets. This class
            holds settings common for all TCP based transports.
            </remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Transport.Transport" -->
        <member name="F:NGit.Transport.Transport.DEFAULT_FETCH_THIN">
            <summary>
            Default setting for
            <see cref="F:NGit.Transport.Transport.fetchThin">fetchThin</see>
            option.
            </summary>
        </member>
        <member name="F:NGit.Transport.Transport.DEFAULT_PUSH_THIN">
            <summary>
            Default setting for
            <see cref="F:NGit.Transport.Transport.pushThin">pushThin</see>
            option.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Transport.Transport.Register(NGit.Transport.TransportProtocol)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Transport.Transport.Unregister(NGit.Transport.TransportProtocol)" -->
        <member name="M:NGit.Transport.Transport.GetTransportProtocols">
            <summary>Obtain a copy of the registered protocols.</summary>
            <remarks>Obtain a copy of the registered protocols.</remarks>
            <returns>an immutable copy of the currently registered protocols.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Transport.Transport.Open(NGit.Repository,System.String)" -->
        <member name="M:NGit.Transport.Transport.Open(NGit.Repository,System.String,NGit.Transport.Transport.Operation)">
            <summary>Open a new transport instance to connect two repositories.</summary>
            <remarks>Open a new transport instance to connect two repositories.</remarks>
            <param name="local">existing local repository.</param>
            <param name="remote">
            location of the remote repository - may be URI or remote
            configuration name.
            </param>
            <param name="op">
            planned use of the returned Transport; the URI may differ
            based on the type of connection desired.
            </param>
            <returns>
            the new transport instance. Never null. In case of multiple URIs
            in remote configuration, only the first is chosen.
            </returns>
            <exception cref="T:Sharpen.URISyntaxException">
            the location is not a remote defined in the configuration
            file and is not a well-formed URL.
            </exception>
            <exception cref="T:System.NotSupportedException">the protocol specified is not supported.
            	</exception>
            <exception cref="T:NGit.Errors.TransportException">the transport cannot open this URI.
            	</exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Transport.Transport.OpenAll(NGit.Repository,System.String)" -->
        <member name="M:NGit.Transport.Transport.OpenAll(NGit.Repository,System.String,NGit.Transport.Transport.Operation)">
            <summary>Open new transport instances to connect two repositories.</summary>
            <remarks>Open new transport instances to connect two repositories.</remarks>
            <param name="local">existing local repository.</param>
            <param name="remote">
            location of the remote repository - may be URI or remote
            configuration name.
            </param>
            <param name="op">
            planned use of the returned Transport; the URI may differ
            based on the type of connection desired.
            </param>
            <returns>
            the list of new transport instances for every URI in remote
            configuration.
            </returns>
            <exception cref="T:Sharpen.URISyntaxException">
            the location is not a remote defined in the configuration
            file and is not a well-formed URL.
            </exception>
            <exception cref="T:System.NotSupportedException">the protocol specified is not supported.
            	</exception>
            <exception cref="T:NGit.Errors.TransportException">the transport cannot open this URI.
            	</exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Transport.Transport.Open(NGit.Repository,NGit.Transport.RemoteConfig)" -->
        <member name="M:NGit.Transport.Transport.Open(NGit.Repository,NGit.Transport.RemoteConfig,NGit.Transport.Transport.Operation)">
            <summary>Open a new transport instance to connect two repositories.</summary>
            <remarks>Open a new transport instance to connect two repositories.</remarks>
            <param name="local">existing local repository.</param>
            <param name="cfg">
            configuration describing how to connect to the remote
            repository.
            </param>
            <param name="op">
            planned use of the returned Transport; the URI may differ
            based on the type of connection desired.
            </param>
            <returns>
            the new transport instance. Never null. In case of multiple URIs
            in remote configuration, only the first is chosen.
            </returns>
            <exception cref="T:System.NotSupportedException">the protocol specified is not supported.
            	</exception>
            <exception cref="T:NGit.Errors.TransportException">the transport cannot open this URI.
            	</exception>
            <exception cref="T:System.ArgumentException">
            if provided remote configuration doesn't have any URI
            associated.
            </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Transport.Transport.OpenAll(NGit.Repository,NGit.Transport.RemoteConfig)" -->
        <member name="M:NGit.Transport.Transport.OpenAll(NGit.Repository,NGit.Transport.RemoteConfig,NGit.Transport.Transport.Operation)">
            <summary>Open new transport instances to connect two repositories.</summary>
            <remarks>Open new transport instances to connect two repositories.</remarks>
            <param name="local">existing local repository.</param>
            <param name="cfg">
            configuration describing how to connect to the remote
            repository.
            </param>
            <param name="op">
            planned use of the returned Transport; the URI may differ
            based on the type of connection desired.
            </param>
            <returns>
            the list of new transport instances for every URI in remote
            configuration.
            </returns>
            <exception cref="T:System.NotSupportedException">the protocol specified is not supported.
            	</exception>
            <exception cref="T:NGit.Errors.TransportException">the transport cannot open this URI.
            	</exception>
        </member>
        <member name="M:NGit.Transport.Transport.Open(NGit.Repository,NGit.Transport.URIish)">
            <summary>Open a new transport instance to connect two repositories.</summary>
            <remarks>Open a new transport instance to connect two repositories.</remarks>
            <param name="local">existing local repository.</param>
            <param name="uri">location of the remote repository.</param>
            <returns>the new transport instance. Never null.</returns>
            <exception cref="T:System.NotSupportedException">the protocol specified is not supported.
            	</exception>
            <exception cref="T:NGit.Errors.TransportException">the transport cannot open this URI.
            	</exception>
        </member>
        <member name="M:NGit.Transport.Transport.Open(NGit.Repository,NGit.Transport.URIish,System.String)">
            <summary>Open a new transport instance to connect two repositories.</summary>
            <remarks>Open a new transport instance to connect two repositories.</remarks>
            <param name="local">existing local repository.</param>
            <param name="uri">location of the remote repository.</param>
            <param name="remoteName">
            name of the remote, if the remote as configured in
            <code>local</code>
            ; otherwise null.
            </param>
            <returns>the new transport instance. Never null.</returns>
            <exception cref="T:System.NotSupportedException">the protocol specified is not supported.
            	</exception>
            <exception cref="T:NGit.Errors.TransportException">the transport cannot open this URI.
            	</exception>
        </member>
        <member name="M:NGit.Transport.Transport.Open(NGit.Transport.URIish)">
            <summary>Open a new transport with no local repository.</summary>
            <remarks>Open a new transport with no local repository.</remarks>
            <param name="uri"></param>
            <returns>new Transport instance</returns>
            <exception cref="T:System.NotSupportedException">System.NotSupportedException</exception>
            <exception cref="T:NGit.Errors.TransportException">NGit.Errors.TransportException</exception>
        </member>
        <member name="M:NGit.Transport.Transport.FindRemoteRefUpdatesFor(NGit.Repository,System.Collections.Generic.ICollection{NGit.Transport.RefSpec},System.Collections.Generic.ICollection{NGit.Transport.RefSpec})">
            <summary>
            Convert push remote refs update specification from
            <see cref="T:NGit.Transport.RefSpec">RefSpec</see>
            form
            to
            <see cref="T:NGit.Transport.RemoteRefUpdate">RemoteRefUpdate</see>
            . Conversion expands wildcards by matching
            source part to local refs. expectedOldObjectId in RemoteRefUpdate is
            always set as null. Tracking branch is configured if RefSpec destination
            matches source of any fetch ref spec for this transport remote
            configuration.
            </summary>
            <param name="db">local database.</param>
            <param name="specs">collection of RefSpec to convert.</param>
            <param name="fetchSpecs">
            fetch specifications used for finding localtracking refs. May
            be null or empty collection.
            </param>
            <returns>
            collection of set up
            <see cref="T:NGit.Transport.RemoteRefUpdate">RemoteRefUpdate</see>
            .
            </returns>
            <exception cref="T:System.IO.IOException">
            when problem occurred during conversion or specification set
            up: most probably, missing objects or refs.
            </exception>
        </member>
        <member name="F:NGit.Transport.Transport.REFSPEC_TAGS">
            <summary>Specification for fetch or push operations, to fetch or push all tags.</summary>
            <remarks>
            Specification for fetch or push operations, to fetch or push all tags.
            Acts as --tags.
            </remarks>
        </member>
        <member name="F:NGit.Transport.Transport.REFSPEC_PUSH_ALL">
            <summary>Specification for push operation, to push all refs under refs/heads.</summary>
            <remarks>
            Specification for push operation, to push all refs under refs/heads. Acts
            as --all.
            </remarks>
        </member>
        <member name="F:NGit.Transport.Transport.local">
            <summary>The repository this transport fetches into, or pushes out of.</summary>
            <remarks>The repository this transport fetches into, or pushes out of.</remarks>
        </member>
        <member name="F:NGit.Transport.Transport.uri">
            <summary>The URI used to create this transport.</summary>
            <remarks>The URI used to create this transport.</remarks>
        </member>
        <member name="F:NGit.Transport.Transport.optionUploadPack">
            <summary>Name of the upload pack program, if it must be executed.</summary>
            <remarks>Name of the upload pack program, if it must be executed.</remarks>
        </member>
        <member name="F:NGit.Transport.Transport.fetch">
            <summary>Specifications to apply during fetch.</summary>
            <remarks>Specifications to apply during fetch.</remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "F:NGit.Transport.Transport.tagopt" -->
        <member name="F:NGit.Transport.Transport.fetchThin">
            <summary>Should fetch request thin-pack if remote repository can produce it.</summary>
            <remarks>Should fetch request thin-pack if remote repository can produce it.</remarks>
        </member>
        <member name="F:NGit.Transport.Transport.optionReceivePack">
            <summary>Name of the receive pack program, if it must be executed.</summary>
            <remarks>Name of the receive pack program, if it must be executed.</remarks>
        </member>
        <member name="F:NGit.Transport.Transport.push">
            <summary>Specifications to apply during push.</summary>
            <remarks>Specifications to apply during push.</remarks>
        </member>
        <member name="F:NGit.Transport.Transport.pushThin">
            <summary>Should push produce thin-pack when sending objects to remote repository.
            	</summary>
            <remarks>Should push produce thin-pack when sending objects to remote repository.
            	</remarks>
        </member>
        <member name="F:NGit.Transport.Transport.dryRun">
            <summary>Should push just check for operation result, not really push.</summary>
            <remarks>Should push just check for operation result, not really push.</remarks>
        </member>
        <member name="F:NGit.Transport.Transport.checkFetchedObjects">
            <summary>Should an incoming (fetch) transfer validate objects?</summary>
        </member>
        <member name="F:NGit.Transport.Transport.removeDeletedRefs">
            <summary>Should refs no longer on the source be pruned from the destination?</summary>
        </member>
        <member name="F:NGit.Transport.Transport.timeout">
            <summary>Timeout in seconds to wait before aborting an IO read or write.</summary>
            <remarks>Timeout in seconds to wait before aborting an IO read or write.</remarks>
        </member>
        <member name="F:NGit.Transport.Transport.packConfig">
            <summary>Pack configuration used by this transport to make pack file.</summary>
            <remarks>Pack configuration used by this transport to make pack file.</remarks>
        </member>
        <member name="F:NGit.Transport.Transport.credentialsProvider">
            <summary>Assists with authentication the connection.</summary>
            <remarks>Assists with authentication the connection.</remarks>
        </member>
        <member name="M:NGit.Transport.Transport.#ctor(NGit.Repository,NGit.Transport.URIish)">
            <summary>Create a new transport instance.</summary>
            <remarks>Create a new transport instance.</remarks>
            <param name="local">
            the repository this instance will fetch into, or push out of.
            This must be the repository passed to
            <see cref="M:NGit.Transport.Transport.Open(NGit.Repository,NGit.Transport.URIish)">Open(NGit.Repository, URIish)</see>
            .
            </param>
            <param name="uri">
            the URI used to access the remote repository. This must be the
            URI passed to
            <see cref="M:NGit.Transport.Transport.Open(NGit.Repository,NGit.Transport.URIish)">Open(NGit.Repository, URIish)</see>
            .
            </param>
        </member>
        <member name="M:NGit.Transport.Transport.#ctor(NGit.Transport.URIish)">
            <summary>Create a minimal transport instance not tied to a single repository.</summary>
            <remarks>Create a minimal transport instance not tied to a single repository.</remarks>
            <param name="uri"></param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Transport.Transport.GetURI" -->
        <member name="M:NGit.Transport.Transport.GetOptionUploadPack">
            <summary>Get the name of the remote executable providing upload-pack service.</summary>
            <remarks>Get the name of the remote executable providing upload-pack service.</remarks>
            <returns>typically "git-upload-pack".</returns>
        </member>
        <member name="M:NGit.Transport.Transport.SetOptionUploadPack(System.String)">
            <summary>Set the name of the remote executable providing upload-pack services.</summary>
            <remarks>Set the name of the remote executable providing upload-pack services.</remarks>
            <param name="where">name of the executable.</param>
        </member>
        <member name="M:NGit.Transport.Transport.GetTagOpt">
            <summary>Get the description of how annotated tags should be treated during fetch.
            	</summary>
            <remarks>Get the description of how annotated tags should be treated during fetch.
            	</remarks>
            <returns>option indicating the behavior of annotated tags in fetch.</returns>
        </member>
        <member name="M:NGit.Transport.Transport.SetTagOpt(NGit.Transport.TagOpt)">
            <summary>Set the description of how annotated tags should be treated on fetch.</summary>
            <remarks>Set the description of how annotated tags should be treated on fetch.</remarks>
            <param name="option">method to use when handling annotated tags.</param>
        </member>
        <member name="M:NGit.Transport.Transport.IsFetchThin">
            <summary>
            Default setting is:
            <see cref="F:NGit.Transport.Transport.DEFAULT_FETCH_THIN">DEFAULT_FETCH_THIN</see>
            </summary>
            <returns>
            true if fetch should request thin-pack when possible; false
            otherwise
            </returns>
            <seealso cref="T:NGit.Transport.PackTransport">PackTransport</seealso>
        </member>
        <member name="M:NGit.Transport.Transport.SetFetchThin(System.Boolean)">
            <summary>Set the thin-pack preference for fetch operation.</summary>
            <remarks>
            Set the thin-pack preference for fetch operation. Default setting is:
            <see cref="F:NGit.Transport.Transport.DEFAULT_FETCH_THIN">DEFAULT_FETCH_THIN</see>
            </remarks>
            <param name="fetchThin">
            true when fetch should request thin-pack when possible; false
            when it shouldn't
            </param>
            <seealso cref="T:NGit.Transport.PackTransport">PackTransport</seealso>
        </member>
        <member name="M:NGit.Transport.Transport.IsCheckFetchedObjects">
            <returns>
            true if fetch will verify received objects are formatted
            correctly. Validating objects requires more CPU time on the
            client side of the connection.
            </returns>
        </member>
        <member name="M:NGit.Transport.Transport.SetCheckFetchedObjects(System.Boolean)">
            <param name="check">
            true to enable checking received objects; false to assume all
            received objects are valid.
            </param>
        </member>
        <member name="M:NGit.Transport.Transport.GetOptionReceivePack">
            <summary>
            Default setting is:
            <see cref="F:NGit.Transport.RemoteConfig.DEFAULT_RECEIVE_PACK">RemoteConfig.DEFAULT_RECEIVE_PACK</see>
            </summary>
            <returns>
            remote executable providing receive-pack service for pack
            transports.
            </returns>
            <seealso cref="T:NGit.Transport.PackTransport">PackTransport</seealso>
        </member>
        <member name="M:NGit.Transport.Transport.SetOptionReceivePack(System.String)">
            <summary>Set remote executable providing receive-pack service for pack transports.
            	</summary>
            <remarks>
            Set remote executable providing receive-pack service for pack transports.
            Default setting is:
            <see cref="F:NGit.Transport.RemoteConfig.DEFAULT_RECEIVE_PACK">RemoteConfig.DEFAULT_RECEIVE_PACK</see>
            </remarks>
            <param name="optionReceivePack">remote executable, if null or empty default one is set;
            	</param>
        </member>
        <member name="M:NGit.Transport.Transport.IsPushThin">
            <summary>
            Default setting is:
            <value>#DEFAULT_PUSH_THIN</value>
            </summary>
            <returns>true if push should produce thin-pack in pack transports</returns>
            <seealso cref="T:NGit.Transport.PackTransport">PackTransport</seealso>
        </member>
        <member name="M:NGit.Transport.Transport.SetPushThin(System.Boolean)">
            <summary>Set thin-pack preference for push operation.</summary>
            <remarks>
            Set thin-pack preference for push operation. Default setting is:
            <value>#DEFAULT_PUSH_THIN</value>
            </remarks>
            <param name="pushThin">
            true when push should produce thin-pack in pack transports;
            false when it shouldn't
            </param>
            <seealso cref="T:NGit.Transport.PackTransport">PackTransport</seealso>
        </member>
        <member name="M:NGit.Transport.Transport.IsRemoveDeletedRefs">
            <returns>
            true if destination refs should be removed if they no longer
            exist at the source repository.
            </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Transport.Transport.SetRemoveDeletedRefs(System.Boolean)" -->
        <member name="M:NGit.Transport.Transport.ApplyConfig(NGit.Transport.RemoteConfig)">
            <summary>Apply provided remote configuration on this transport.</summary>
            <remarks>Apply provided remote configuration on this transport.</remarks>
            <param name="cfg">configuration to apply on this transport.</param>
        </member>
        <member name="M:NGit.Transport.Transport.IsDryRun">
            <returns>
            true if push operation should just check for possible result and
            not really update remote refs, false otherwise - when push should
            act normally.
            </returns>
        </member>
        <member name="M:NGit.Transport.Transport.SetDryRun(System.Boolean)">
            <summary>Set dry run option for push operation.</summary>
            <remarks>Set dry run option for push operation.</remarks>
            <param name="dryRun">
            true if push operation should just check for possible result
            and not really update remote refs, false otherwise - when push
            should act normally.
            </param>
        </member>
        <member name="M:NGit.Transport.Transport.GetTimeout">
            <returns>timeout (in seconds) before aborting an IO operation.</returns>
        </member>
        <member name="M:NGit.Transport.Transport.SetTimeout(System.Int32)">
            <summary>Set the timeout before willing to abort an IO call.</summary>
            <remarks>Set the timeout before willing to abort an IO call.</remarks>
            <param name="seconds">
            number of seconds to wait (with no data transfer occurring)
            before aborting an IO read or write operation with this
            remote.
            </param>
        </member>
        <member name="M:NGit.Transport.Transport.GetPackConfig">
            <summary>Get the configuration used by the pack generator to make packs.</summary>
            <remarks>
            Get the configuration used by the pack generator to make packs.
            If
            <see cref="M:NGit.Transport.Transport.SetPackConfig(NGit.Storage.Pack.PackConfig)">SetPackConfig(NGit.Storage.Pack.PackConfig)
            	</see>
            was previously given null a new
            PackConfig is created on demand by this method using the source
            repository's settings.
            </remarks>
            <returns>the pack configuration. Never null.</returns>
        </member>
        <member name="M:NGit.Transport.Transport.SetPackConfig(NGit.Storage.Pack.PackConfig)">
            <summary>Set the configuration used by the pack generator.</summary>
            <remarks>Set the configuration used by the pack generator.</remarks>
            <param name="pc">
            configuration controlling packing parameters. If null the
            source repository's settings will be used.
            </param>
        </member>
        <member name="M:NGit.Transport.Transport.SetCredentialsProvider(NGit.Transport.CredentialsProvider)">
            <summary>A credentials provider to assist with authentication connections..</summary>
            <remarks>A credentials provider to assist with authentication connections..</remarks>
            <param name="credentialsProvider">the credentials provider, or null if there is none
            	</param>
        </member>
        <member name="M:NGit.Transport.Transport.GetCredentialsProvider">
            <summary>The configured credentials provider.</summary>
            <remarks>The configured credentials provider.</remarks>
            <returns>
            the credentials provider, or null if no credentials provider is
            associated with this transport.
            </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Transport.Transport.Fetch(NGit.ProgressMonitor,System.Collections.Generic.ICollection{NGit.Transport.RefSpec})" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Transport.Transport.Push(NGit.ProgressMonitor,System.Collections.Generic.ICollection{NGit.Transport.RemoteRefUpdate})" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Transport.Transport.FindRemoteRefUpdatesFor(System.Collections.Generic.ICollection{NGit.Transport.RefSpec})" -->
        <member name="M:NGit.Transport.Transport.OpenFetch">
            <summary>Begins a new connection for fetching from the remote repository.</summary>
            <remarks>Begins a new connection for fetching from the remote repository.</remarks>
            <returns>a fresh connection to fetch from the remote repository.</returns>
            <exception cref="T:System.NotSupportedException">the implementation does not support fetching.
            	</exception>
            <exception cref="T:NGit.Errors.TransportException">the remote connection could not be established.
            	</exception>
        </member>
        <member name="M:NGit.Transport.Transport.OpenPush">
            <summary>Begins a new connection for pushing into the remote repository.</summary>
            <remarks>Begins a new connection for pushing into the remote repository.</remarks>
            <returns>a fresh connection to push into the remote repository.</returns>
            <exception cref="T:System.NotSupportedException">the implementation does not support pushing.
            	</exception>
            <exception cref="T:NGit.Errors.TransportException">the remote connection could not be established
            	</exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Transport.Transport.Close" -->
        <member name="T:NGit.Transport.Transport.Operation">
            <summary>Type of operation a Transport is being opened for.</summary>
            <remarks>Type of operation a Transport is being opened for.</remarks>
        </member>
        <member name="M:NGit.Transport.TcpTransport.#ctor(NGit.Repository,NGit.Transport.URIish)">
            <summary>Create a new transport instance.</summary>
            <remarks>Create a new transport instance.</remarks>
            <param name="local">
            the repository this instance will fetch into, or push out of.
            This must be the repository passed to
            <see cref="M:NGit.Transport.Transport.Open(NGit.Repository,NGit.Transport.URIish)">Transport.Open(NGit.Repository, URIish)
            	</see>
            .
            </param>
            <param name="uri">
            the URI used to access the remote repository. This must be the
            URI passed to
            <see cref="M:NGit.Transport.Transport.Open(NGit.Repository,NGit.Transport.URIish)">Transport.Open(NGit.Repository, URIish)
            	</see>
            .
            </param>
        </member>
        <member name="F:NGit.Transport.SshTransport.sock">
            <summary>The open SSH session</summary>
        </member>
        <member name="M:NGit.Transport.SshTransport.#ctor(NGit.Repository,NGit.Transport.URIish)">
            <summary>Create a new transport instance.</summary>
            <remarks>Create a new transport instance.</remarks>
            <param name="local">
            the repository this instance will fetch into, or push out of.
            This must be the repository passed to
            <see cref="M:NGit.Transport.Transport.Open(NGit.Repository,NGit.Transport.URIish)">Transport.Open(NGit.Repository, URIish)
            	</see>
            .
            </param>
            <param name="uri">
            the URI used to access the remote repository. This must be the
            URI passed to
            <see cref="M:NGit.Transport.Transport.Open(NGit.Repository,NGit.Transport.URIish)">Transport.Open(NGit.Repository, URIish)
            	</see>
            .
            </param>
        </member>
        <member name="M:NGit.Transport.SshTransport.SetSshSessionFactory(NGit.Transport.SshSessionFactory)">
            <summary>
            Set SSH session factory instead of the default one for this instance of
            the transport.
            </summary>
            <remarks>
            Set SSH session factory instead of the default one for this instance of
            the transport.
            </remarks>
            <param name="factory">a factory to set, must not be null</param>
            <exception cref="T:System.InvalidOperationException">if session has been already created.
            	</exception>
        </member>
        <member name="M:NGit.Transport.SshTransport.GetSshSessionFactory">
            <returns>the SSH session factory that will be used for creating SSH sessions</returns>
        </member>
        <member name="M:NGit.Transport.SshTransport.GetSession">
            <summary>Get the default SSH session</summary>
            <returns>a remote session</returns>
            <exception cref="T:NGit.Errors.TransportException">in case of error with opening SSH session
            	</exception>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Transport.WalkTransport" -->
        <member name="M:NGit.Transport.TransportSftp.OpenFetch">
            <exception cref="T:NGit.Errors.TransportException"></exception>
        </member>
        <member name="M:NGit.Transport.TransportSftp.OpenPush">
            <exception cref="T:NGit.Errors.TransportException"></exception>
        </member>
        <member name="M:NGit.Transport.TransportSftp.NewSftp">
            <exception cref="T:NGit.Errors.TransportException"></exception>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Transport.TransportProtocol" -->
        <member name="M:NGit.Transport.TransportProtocol.GetName">
            <returns>text name of the protocol suitable for display to a user.</returns>
        </member>
        <member name="M:NGit.Transport.TransportProtocol.GetSchemes">
            <returns>immutable set of schemes supported by this protocol.</returns>
        </member>
        <member name="M:NGit.Transport.TransportProtocol.GetRequiredFields">
            <returns>immutable set of URIishFields that must be filled in.</returns>
        </member>
        <member name="M:NGit.Transport.TransportProtocol.GetOptionalFields">
            <returns>immutable set of URIishFields that may be filled in.</returns>
        </member>
        <member name="M:NGit.Transport.TransportProtocol.GetDefaultPort">
            <returns>if a port is supported, the default port, else -1.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Transport.TransportProtocol.CanHandle(NGit.Transport.URIish)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Transport.TransportProtocol.CanHandle(NGit.Transport.URIish,NGit.Repository,System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Transport.TransportProtocol.Open(NGit.Transport.URIish,NGit.Repository,System.String)" -->
        <member name="M:NGit.Transport.TransportProtocol.Open(NGit.Transport.URIish)">
            <summary>Open a new transport instance to the remote repository.</summary>
            <remarks>
            Open a new transport instance to the remote repository. Use default
            configuration instead of reading from configuration files.
            </remarks>
            <param name="uri"></param>
            <returns>new Transport</returns>
            <exception cref="T:System.NotSupportedException">System.NotSupportedException</exception>
            <exception cref="T:NGit.Errors.TransportException">NGit.Errors.TransportException</exception>
        </member>
        <member name="T:NGit.Transport.TransportProtocol.URIishField">
            <summary>
            Fields within a
            <see cref="T:NGit.Transport.URIish">URIish</see>
            that a transport uses.
            </summary>
        </member>
        <member name="M:NGit.Transport.TransportSftp._TransportProtocol_100.Open(NGit.Transport.URIish,NGit.Repository,System.String)">
            <exception cref="T:System.NotSupportedException"></exception>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Transport.WalkRemoteObjectDatabase" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Transport.WalkRemoteObjectDatabase.GetPackNames" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Transport.WalkRemoteObjectDatabase.GetAlternates" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Transport.WalkRemoteObjectDatabase.Open(System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Transport.WalkRemoteObjectDatabase.OpenAlternate(System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Transport.WalkRemoteObjectDatabase.Close" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Transport.WalkRemoteObjectDatabase.DeleteFile(System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Transport.WalkRemoteObjectDatabase.WriteFile(System.String,NGit.ProgressMonitor,System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Transport.WalkRemoteObjectDatabase.WriteFile(System.String,System.Byte[])" -->
        <member name="M:NGit.Transport.WalkRemoteObjectDatabase.DeleteRef(System.String)">
            <summary>Delete a loose ref from the remote repository.</summary>
            <remarks>Delete a loose ref from the remote repository.</remarks>
            <param name="name">
            name of the ref within the ref space, for example
            <code>refs/heads/pu</code>.
            </param>
            <exception cref="T:System.IO.IOException">deletion is not supported, or deletion failed.
            	</exception>
        </member>
        <member name="M:NGit.Transport.WalkRemoteObjectDatabase.DeleteRefLog(System.String)">
            <summary>Delete a reflog from the remote repository.</summary>
            <remarks>Delete a reflog from the remote repository.</remarks>
            <param name="name">
            name of the ref within the ref space, for example
            <code>refs/heads/pu</code>.
            </param>
            <exception cref="T:System.IO.IOException">deletion is not supported, or deletion failed.
            	</exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Transport.WalkRemoteObjectDatabase.WriteRef(System.String,NGit.ObjectId)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Transport.WalkRemoteObjectDatabase.WriteInfoPacks(System.Collections.Generic.IEnumerable{System.String})" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Transport.WalkRemoteObjectDatabase.OpenReader(System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Transport.WalkRemoteObjectDatabase.ReadAlternates(System.String)" -->
        <member name="M:NGit.Transport.WalkRemoteObjectDatabase.ReadPackedRefs(System.Collections.Generic.IDictionary{System.String,NGit.Ref})">
            <summary>Read a standard Git packed-refs file to discover known references.</summary>
            <remarks>Read a standard Git packed-refs file to discover known references.</remarks>
            <param name="avail">
            return collection of references. Any existing entries will be
            replaced if they are found in the packed-refs file.
            </param>
            <exception cref="T:NGit.Errors.TransportException">an error occurred reading from the packed refs file.
            	</exception>
        </member>
        <member name="M:NGit.Transport.WalkRemoteObjectDatabase.ReadPackedRefsImpl(System.Collections.Generic.IDictionary{System.String,NGit.Ref},Sharpen.BufferedReader)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Transport.WalkRemoteObjectDatabase.FileStream.#ctor(Sharpen.InputStream)">
            <summary>Create a new stream of unknown length.</summary>
            <remarks>Create a new stream of unknown length.</remarks>
            <param name="i">
            stream containing the file data. This stream will be
            closed by the caller when reading is complete.
            </param>
        </member>
        <member name="M:NGit.Transport.WalkRemoteObjectDatabase.FileStream.#ctor(Sharpen.InputStream,System.Int64)">
            <summary>Create a new stream of known length.</summary>
            <remarks>Create a new stream of known length.</remarks>
            <param name="i">
            stream containing the file data. This stream will be
            closed by the caller when reading is complete.
            </param>
            <param name="n">
            total number of bytes available for reading through
            <code>i</code>.
            </param>
        </member>
        <member name="M:NGit.Transport.WalkRemoteObjectDatabase.FileStream.ToArray">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Transport.TransportSftp.SftpObjectDB.#ctor(NGit.Transport.TransportSftp,System.String)">
            <exception cref="T:NGit.Errors.TransportException"></exception>
        </member>
        <member name="M:NGit.Transport.TransportSftp.SftpObjectDB.#ctor(NGit.Transport.TransportSftp,NGit.Transport.TransportSftp.SftpObjectDB,System.String)">
            <exception cref="T:NGit.Errors.TransportException"></exception>
        </member>
        <member name="M:NGit.Transport.TransportSftp.SftpObjectDB.GetAlternates">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Transport.TransportSftp.SftpObjectDB.OpenAlternate(System.String)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Transport.TransportSftp.SftpObjectDB.GetPackNames">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Transport.TransportSftp.SftpObjectDB.Open(System.String)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Transport.TransportSftp.SftpObjectDB.DeleteFile(System.String)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Transport.TransportSftp.SftpObjectDB.WriteFile(System.String,NGit.ProgressMonitor,System.String)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Transport.TransportSftp.SftpObjectDB.WriteFile(System.String,System.Byte[])">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Transport.TransportSftp.SftpObjectDB.Mkdir_p(System.String)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Transport.TransportSftp.SftpObjectDB.ReadAdvertisedRefs">
            <exception cref="T:NGit.Errors.TransportException"></exception>
        </member>
        <member name="M:NGit.Transport.TransportSftp.SftpObjectDB.ReadLooseRefs(System.Collections.Generic.SortedDictionary{System.String,NGit.Ref},System.String,System.String)">
            <exception cref="T:NGit.Errors.TransportException"></exception>
        </member>
        <member name="M:NGit.Transport.TransportSftp.SftpObjectDB.ReadRef(System.Collections.Generic.SortedDictionary{System.String,NGit.Ref},System.String,System.String)">
            <exception cref="T:NGit.Errors.TransportException"></exception>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Transport.PostReceiveHook" -->
        <member name="F:NGit.Transport.PostReceiveHook.NULL">
            <summary>A simple no-op hook.</summary>
            <remarks>A simple no-op hook.</remarks>
        </member>
        <member name="M:NGit.Transport.PostReceiveHook.OnPostReceive(NGit.Transport.ReceivePack,System.Collections.Generic.ICollection{NGit.Transport.ReceiveCommand})">
            <summary>Invoked after all commands are executed and status has been returned.</summary>
            <remarks>Invoked after all commands are executed and status has been returned.</remarks>
            <param name="rp">
            the process handling the current receive. Hooks may obtain
            details about the destination repository through this handle.
            </param>
            <param name="commands">
            unmodifiable set of successfully completed commands. May be
            the empty set.
            </param>
        </member>
        <member name="T:NGit.Transport.FetchResult">
            <summary>Final status after a successful fetch from a remote repository.</summary>
            <remarks>Final status after a successful fetch from a remote repository.</remarks>
            <seealso cref="!:Transport.Fetch(NGit.ProgressMonitor, System.Collections.Generic.ICollection&lt;E&gt;)&#xA;            	">Transport.Fetch(NGit.ProgressMonitor, System.Collections.Generic.ICollection&lt;E&gt;)
            	</seealso>
        </member>
        <member name="T:NGit.Transport.OperationResult">
            <summary>Class holding result of operation on remote repository.</summary>
            <remarks>
            Class holding result of operation on remote repository. This includes refs
            advertised by remote repo and local tracking refs updates.
            </remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Transport.OperationResult.GetURI" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Transport.OperationResult.GetAdvertisedRefs" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Transport.OperationResult.GetAdvertisedRef(System.String)" -->
        <member name="M:NGit.Transport.OperationResult.GetTrackingRefUpdates">
            <summary>Get the status of all local tracking refs that were updated.</summary>
            <remarks>Get the status of all local tracking refs that were updated.</remarks>
            <returns>
            unmodifiable collection of local updates. Never null. Empty if
            there were no local tracking refs updated.
            </returns>
        </member>
        <member name="M:NGit.Transport.OperationResult.GetTrackingRefUpdate(System.String)">
            <summary>Get the status for a specific local tracking ref update.</summary>
            <remarks>Get the status for a specific local tracking ref update.</remarks>
            <param name="localName">name of the local ref (e.g. "refs/remotes/origin/master").
            	</param>
            <returns>
            status of the local ref; null if this local ref was not touched
            during this operation.
            </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Transport.OperationResult.GetMessages" -->
        <!-- Badly formed XML comment ignored for member "T:NGit.Transport.PacketLineOut" -->
        <member name="M:NGit.Transport.PacketLineOut.#ctor(Sharpen.OutputStream)">
            <summary>Create a new packet line writer.</summary>
            <remarks>Create a new packet line writer.</remarks>
            <param name="outputStream">stream.</param>
        </member>
        <member name="M:NGit.Transport.PacketLineOut.SetFlushOnEnd(System.Boolean)">
            <summary>
            Set the flush behavior during
            <see cref="M:NGit.Transport.PacketLineOut.End">End()</see>
            .
            </summary>
            <param name="flushOnEnd">
            if true, a flush-pkt written during
            <see cref="M:NGit.Transport.PacketLineOut.End">End()</see>
            also
            flushes the underlying stream.
            </param>
        </member>
        <member name="M:NGit.Transport.PacketLineOut.WriteString(System.String)">
            <summary>Write a UTF-8 encoded string as a single length-delimited packet.</summary>
            <remarks>Write a UTF-8 encoded string as a single length-delimited packet.</remarks>
            <param name="s">string to write.</param>
            <exception cref="T:System.IO.IOException">
            the packet could not be written, the stream is corrupted as
            the packet may have been only partially written.
            </exception>
        </member>
        <member name="M:NGit.Transport.PacketLineOut.WritePacket(System.Byte[])">
            <summary>Write a binary packet to the stream.</summary>
            <remarks>Write a binary packet to the stream.</remarks>
            <param name="packet">
            the packet to write; the length of the packet is equal to the
            size of the byte array.
            </param>
            <exception cref="T:System.IO.IOException">
            the packet could not be written, the stream is corrupted as
            the packet may have been only partially written.
            </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Transport.PacketLineOut.End" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Transport.PacketLineOut.Flush" -->
        <!-- Badly formed XML comment ignored for member "T:NGit.Transport.SideBandOutputStream" -->
        <member name="F:NGit.Transport.SideBandOutputStream.CH_DATA">
            <summary>Channel used for pack data.</summary>
            <remarks>Channel used for pack data.</remarks>
        </member>
        <member name="F:NGit.Transport.SideBandOutputStream.CH_PROGRESS">
            <summary>Channel used for progress messages.</summary>
            <remarks>Channel used for progress messages.</remarks>
        </member>
        <member name="F:NGit.Transport.SideBandOutputStream.CH_ERROR">
            <summary>Channel used for error messages.</summary>
            <remarks>Channel used for error messages.</remarks>
        </member>
        <member name="F:NGit.Transport.SideBandOutputStream.SMALL_BUF">
            <summary>Default buffer size for a small amount of data.</summary>
            <remarks>Default buffer size for a small amount of data.</remarks>
        </member>
        <member name="F:NGit.Transport.SideBandOutputStream.MAX_BUF">
            <summary>Maximum buffer size for a single packet of sideband data.</summary>
            <remarks>Maximum buffer size for a single packet of sideband data.</remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "F:NGit.Transport.SideBandOutputStream.cnt" -->
        <member name="M:NGit.Transport.SideBandOutputStream.#ctor(System.Int32,System.Int32,Sharpen.OutputStream)">
            <summary>Create a new stream to write side band packets.</summary>
            <remarks>Create a new stream to write side band packets.</remarks>
            <param name="chan">
            channel number to prefix all packets with, so the remote side
            can demultiplex the stream and get back the original data.
            Must be in the range [0, 255].
            </param>
            <param name="sz">
            maximum size of a data packet within the stream. The remote
            side needs to agree to the packet size to prevent buffer
            overflows. Must be in the range [HDR_SIZE + 1, MAX_BUF).
            </param>
            <param name="os">
            stream that the packets are written onto. This stream should
            be attached to a SideBandInputStream on the remote side.
            </param>
        </member>
        <member name="M:NGit.Transport.SideBandOutputStream.FlushBuffer">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Transport.SideBandOutputStream.Flush">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Transport.SideBandOutputStream.Write(System.Byte[],System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Transport.SideBandOutputStream.Write(System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Transport.SideBandOutputStream.WriteBuffer">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="T:NGit.Util.SystemReader">
            <summary>Interface to read values from the system.</summary>
            <remarks>
            Interface to read values from the system.
            <p>
            When writing unit tests, extending this interface with a custom class
            permits to simulate an access to a system variable or property and
            permits to control the user's global configuration.
            </p>
            </remarks>
        </member>
        <member name="M:NGit.Util.SystemReader.GetInstance">
            <returns>the live instance to read system properties.</returns>
        </member>
        <member name="M:NGit.Util.SystemReader.SetInstance(NGit.Util.SystemReader)">
            <param name="newReader">the new instance to use when accessing properties.</param>
        </member>
        <member name="M:NGit.Util.SystemReader.GetHostname">
            <summary>Gets the hostname of the local host.</summary>
            <remarks>
            Gets the hostname of the local host. If no hostname can be found, the
            hostname is set to the default value "localhost".
            </remarks>
            <returns>the canonical hostname</returns>
        </member>
        <member name="M:NGit.Util.SystemReader.Getenv(System.String)">
            <param name="variable">system variable to read</param>
            <returns>value of the system variable</returns>
        </member>
        <member name="M:NGit.Util.SystemReader.GetProperty(System.String)">
            <param name="key">of the system property to read</param>
            <returns>value of the system property</returns>
        </member>
        <member name="M:NGit.Util.SystemReader.OpenUserConfig(NGit.Config,NGit.Util.FS)">
            <param name="parent">a config with values not found directly in the returned config
            	</param>
            <param name="fs">
            the file system abstraction which will be necessary to perform
            certain file system operations.
            </param>
            <returns>the git configuration found in the user home</returns>
        </member>
        <member name="M:NGit.Util.SystemReader.OpenSystemConfig(NGit.Config,NGit.Util.FS)">
            <param name="parent">
            a config with values not found directly in the returned
            config. Null is a reasonable value here.
            </param>
            <param name="fs">
            the file system abstraction which will be necessary to perform
            certain file system operations.
            </param>
            <returns>
            the gitonfig configuration found in the system-wide "etc"
            directory
            </returns>
        </member>
        <member name="M:NGit.Util.SystemReader.GetCurrentTime">
            <returns>the current system time</returns>
        </member>
        <member name="M:NGit.Util.SystemReader.GetTimezone(System.Int64)">
            <param name="when">TODO</param>
            <returns>the local time zone</returns>
        </member>
        <member name="M:NGit.Util.SystemReader.GetTimeZone">
            <returns>system time zone, possibly mocked for testing</returns>
            <since>1.2</since>
        </member>
        <member name="M:NGit.Util.SystemReader.GetLocale">
            <returns>the locale to use</returns>
            <since>1.2</since>
        </member>
        <member name="M:NGit.Util.SystemReader.GetSimpleDateFormat(System.String)">
            <summary>Returns a simple date format instance as specified by the given pattern.
            	</summary>
            <remarks>Returns a simple date format instance as specified by the given pattern.
            	</remarks>
            <param name="pattern">
            the pattern as defined in
            <see cref="M:Sharpen.SimpleDateFormat.#ctor(System.String)">Sharpen.SimpleDateFormat.SimpleDateFormat(string)
            	</see>
            </param>
            <returns>the simple date format</returns>
            <since>2.0</since>
        </member>
        <member name="M:NGit.Util.SystemReader.GetDateTimeInstance(System.Int32,System.Int32)">
            <summary>Returns a date/time format instance for the given styles.</summary>
            <remarks>Returns a date/time format instance for the given styles.</remarks>
            <param name="dateStyle">
            the date style as specified in
            <see cref="M:Sharpen.DateFormat.GetDateTimeInstance(System.Int32,System.Int32)">Sharpen.DateFormat.GetDateTimeInstance(int, int)
            	</see>
            </param>
            <param name="timeStyle">
            the time style as specified in
            <see cref="M:Sharpen.DateFormat.GetDateTimeInstance(System.Int32,System.Int32)">Sharpen.DateFormat.GetDateTimeInstance(int, int)
            	</see>
            </param>
            <returns>the date format</returns>
            <since>2.0</since>
        </member>
        <member name="T:NGit.Storage.File.FileBasedConfig">
            <summary>The configuration file that is stored in the file of the file system.</summary>
            <remarks>The configuration file that is stored in the file of the file system.</remarks>
        </member>
        <member name="T:NGit.StoredConfig">
            <summary>Persistent configuration that can be stored and loaded from a location.</summary>
            <remarks>Persistent configuration that can be stored and loaded from a location.</remarks>
        </member>
        <member name="T:NGit.Config">
            <summary>
            Git style
            <code>.config</code>
            ,
            <code>.gitconfig</code>
            ,
            <code>.gitmodules</code>
            file.
            </summary>
        </member>
        <member name="F:NGit.Config.listeners">
            <summary>the change listeners</summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:NGit.Config.state" -->
        <!-- Badly formed XML comment ignored for member "F:NGit.Config.MAGIC_EMPTY_VALUE" -->
        <member name="M:NGit.Config.#ctor">
            <summary>Create a configuration with no default fallback.</summary>
            <remarks>Create a configuration with no default fallback.</remarks>
        </member>
        <member name="M:NGit.Config.#ctor(NGit.Config)">
            <summary>Create an empty configuration with a fallback for missing keys.</summary>
            <remarks>Create an empty configuration with a fallback for missing keys.</remarks>
            <param name="defaultConfig">
            the base configuration to be consulted when a key is missing
            from this configuration instance.
            </param>
        </member>
        <member name="M:NGit.Config.EscapeValue(System.String)">
            <summary>Escape the value before saving</summary>
            <param name="x">the value to escape</param>
            <returns>the escaped value</returns>
        </member>
        <member name="M:NGit.Config.GetInt(System.String,System.String,System.Int32)">
            <summary>Obtain an integer value from the configuration.</summary>
            <remarks>Obtain an integer value from the configuration.</remarks>
            <param name="section">section the key is grouped within.</param>
            <param name="name">name of the key to get.</param>
            <param name="defaultValue">default value to return if no value was present.</param>
            <returns>an integer value from the configuration, or defaultValue.</returns>
        </member>
        <member name="M:NGit.Config.GetInt(System.String,System.String,System.String,System.Int32)">
            <summary>Obtain an integer value from the configuration.</summary>
            <remarks>Obtain an integer value from the configuration.</remarks>
            <param name="section">section the key is grouped within.</param>
            <param name="subsection">subsection name, such a remote or branch name.</param>
            <param name="name">name of the key to get.</param>
            <param name="defaultValue">default value to return if no value was present.</param>
            <returns>an integer value from the configuration, or defaultValue.</returns>
        </member>
        <member name="M:NGit.Config.GetLong(System.String,System.String,System.Int64)">
            <summary>Obtain an integer value from the configuration.</summary>
            <remarks>Obtain an integer value from the configuration.</remarks>
            <param name="section">section the key is grouped within.</param>
            <param name="name">name of the key to get.</param>
            <param name="defaultValue">default value to return if no value was present.</param>
            <returns>an integer value from the configuration, or defaultValue.</returns>
        </member>
        <member name="M:NGit.Config.GetLong(System.String,System.String,System.String,System.Int64)">
            <summary>Obtain an integer value from the configuration.</summary>
            <remarks>Obtain an integer value from the configuration.</remarks>
            <param name="section">section the key is grouped within.</param>
            <param name="subsection">subsection name, such a remote or branch name.</param>
            <param name="name">name of the key to get.</param>
            <param name="defaultValue">default value to return if no value was present.</param>
            <returns>an integer value from the configuration, or defaultValue.</returns>
        </member>
        <member name="M:NGit.Config.GetBoolean(System.String,System.String,System.Boolean)">
            <summary>Get a boolean value from the git config</summary>
            <param name="section">section the key is grouped within.</param>
            <param name="name">name of the key to get.</param>
            <param name="defaultValue">default value to return if no value was present.</param>
            <returns>
            true if any value or defaultValue is true, false for missing or
            explicit false
            </returns>
        </member>
        <member name="M:NGit.Config.GetBoolean(System.String,System.String,System.String,System.Boolean)">
            <summary>Get a boolean value from the git config</summary>
            <param name="section">section the key is grouped within.</param>
            <param name="subsection">subsection name, such a remote or branch name.</param>
            <param name="name">name of the key to get.</param>
            <param name="defaultValue">default value to return if no value was present.</param>
            <returns>
            true if any value or defaultValue is true, false for missing or
            explicit false
            </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Config.GetEnum``1(System.String,System.String,System.String,``0)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Config.GetEnum``1(System.Array,System.String,System.String,System.String,``0)" -->
        <member name="M:NGit.Config.GetString(System.String,System.String,System.String)">
            <summary>Get string value</summary>
            <param name="section">the section</param>
            <param name="subsection">the subsection for the value</param>
            <param name="name">the key name</param>
            <returns>a String value from git config.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Config.GetStringList(System.String,System.String,System.String)" -->
        <member name="M:NGit.Config.GetSubsections(System.String)">
            <param name="section">section to search for.</param>
            <returns>
            set of all subsections of specified section within this
            configuration and its base configuration; may be empty if no
            subsection exists. The set's iterator returns sections in the
            order they are declared by the configuration starting from this
            instance and progressing through the base.
            </returns>
        </member>
        <member name="M:NGit.Config.GetSections">
            <returns>
            the sections defined in this
            <see cref="T:NGit.Config">Config</see>
            . The set's iterator
            returns sections in the order they are declared by the
            configuration starting from this instance and progressing through
            the base.
            </returns>
        </member>
        <member name="M:NGit.Config.GetNames(System.String)">
            <param name="section">the section</param>
            <returns>the list of names defined for this section</returns>
        </member>
        <member name="M:NGit.Config.GetNames(System.String,System.String)">
            <param name="section">the section</param>
            <param name="subsection">the subsection</param>
            <returns>the list of names defined for this subsection</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Config.Get``1(NGit.Config.SectionParser{``0})" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Config.Uncache``1(NGit.Config.SectionParser{``0})" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Config.AddChangeListener(NGit.Events.ConfigChangedListener)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Config.NotifyUponTransientChanges" -->
        <member name="M:NGit.Config.FireConfigChangedEvent">
            <summary>Notifies the listeners</summary>
        </member>
        <member name="M:NGit.Config.SetInt(System.String,System.String,System.String,System.Int32)">
            <summary>Add or modify a configuration value.</summary>
            <remarks>
            Add or modify a configuration value. The parameters will result in a
            configuration entry like this.
            <pre>
            [section &quot;subsection&quot;]
            name = value
            </pre>
            </remarks>
            <param name="section">section name, e.g "branch"</param>
            <param name="subsection">optional subsection value, e.g. a branch name</param>
            <param name="name">parameter name, e.g. "filemode"</param>
            <param name="value">parameter value</param>
        </member>
        <member name="M:NGit.Config.SetLong(System.String,System.String,System.String,System.Int64)">
            <summary>Add or modify a configuration value.</summary>
            <remarks>
            Add or modify a configuration value. The parameters will result in a
            configuration entry like this.
            <pre>
            [section &quot;subsection&quot;]
            name = value
            </pre>
            </remarks>
            <param name="section">section name, e.g "branch"</param>
            <param name="subsection">optional subsection value, e.g. a branch name</param>
            <param name="name">parameter name, e.g. "filemode"</param>
            <param name="value">parameter value</param>
        </member>
        <member name="M:NGit.Config.SetBoolean(System.String,System.String,System.String,System.Boolean)">
            <summary>Add or modify a configuration value.</summary>
            <remarks>
            Add or modify a configuration value. The parameters will result in a
            configuration entry like this.
            <pre>
            [section &quot;subsection&quot;]
            name = value
            </pre>
            </remarks>
            <param name="section">section name, e.g "branch"</param>
            <param name="subsection">optional subsection value, e.g. a branch name</param>
            <param name="name">parameter name, e.g. "filemode"</param>
            <param name="value">parameter value</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Config.SetEnum``1(System.String,System.String,System.String,``0)" -->
        <member name="M:NGit.Config.SetString(System.String,System.String,System.String,System.String)">
            <summary>Add or modify a configuration value.</summary>
            <remarks>
            Add or modify a configuration value. The parameters will result in a
            configuration entry like this.
            <pre>
            [section &quot;subsection&quot;]
            name = value
            </pre>
            </remarks>
            <param name="section">section name, e.g "branch"</param>
            <param name="subsection">optional subsection value, e.g. a branch name</param>
            <param name="name">parameter name, e.g. "filemode"</param>
            <param name="value">parameter value, e.g. "true"</param>
        </member>
        <member name="M:NGit.Config.Unset(System.String,System.String,System.String)">
            <summary>Remove a configuration value.</summary>
            <remarks>Remove a configuration value.</remarks>
            <param name="section">section name, e.g "branch"</param>
            <param name="subsection">optional subsection value, e.g. a branch name</param>
            <param name="name">parameter name, e.g. "filemode"</param>
        </member>
        <member name="M:NGit.Config.UnsetSection(System.String,System.String)">
            <summary>Remove all configuration values under a single section.</summary>
            <remarks>Remove all configuration values under a single section.</remarks>
            <param name="section">section name, e.g "branch"</param>
            <param name="subsection">optional subsection value, e.g. a branch name</param>
        </member>
        <member name="M:NGit.Config.SetStringList(System.String,System.String,System.String,System.Collections.Generic.IList{System.String})">
            <summary>Set a configuration value.</summary>
            <remarks>
            Set a configuration value.
            <pre>
            [section &quot;subsection&quot;]
            name = value
            </pre>
            </remarks>
            <param name="section">section name, e.g "branch"</param>
            <param name="subsection">optional subsection value, e.g. a branch name</param>
            <param name="name">parameter name, e.g. "filemode"</param>
            <param name="values">list of zero or more values for this key.</param>
        </member>
        <member name="M:NGit.Config.ToText">
            <returns>this configuration, formatted as a Git style text file.</returns>
        </member>
        <member name="M:NGit.Config.FromText(System.String)">
            <summary>Clear this configuration and reset to the contents of the parsed string.
            	</summary>
            <remarks>Clear this configuration and reset to the contents of the parsed string.
            	</remarks>
            <param name="text">Git style text file listing configuration properties.</param>
            <exception cref="T:NGit.Errors.ConfigInvalidException">
            the text supplied is not formatted correctly. No changes were
            made to
            <code>this</code>
            .
            </exception>
        </member>
        <member name="M:NGit.Config.Clear">
            <summary>Clear the configuration file</summary>
        </member>
        <member name="M:NGit.Config.ReadSectionName(NGit.Config.StringReader)">
            <exception cref="T:NGit.Errors.ConfigInvalidException"></exception>
        </member>
        <member name="M:NGit.Config.ReadKeyName(NGit.Config.StringReader)">
            <exception cref="T:NGit.Errors.ConfigInvalidException"></exception>
        </member>
        <member name="M:NGit.Config.ReadValue(NGit.Config.StringReader,System.Boolean,System.Int32)">
            <exception cref="T:NGit.Errors.ConfigInvalidException"></exception>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Config.SectionParser`1" -->
        <member name="M:NGit.Config.SectionParser`1.Parse(NGit.Config)">
            <summary>Create a model object from a configuration.</summary>
            <remarks>Create a model object from a configuration.</remarks>
            <param name="cfg">the configuration to read values from.</param>
            <returns>the application model instance.</returns>
        </member>
        <member name="M:NGit.StoredConfig.#ctor">
            <summary>Create a configuration with no default fallback.</summary>
            <remarks>Create a configuration with no default fallback.</remarks>
        </member>
        <member name="M:NGit.StoredConfig.#ctor(NGit.Config)">
            <summary>Create an empty configuration with a fallback for missing keys.</summary>
            <remarks>Create an empty configuration with a fallback for missing keys.</remarks>
            <param name="defaultConfig">
            the base configuration to be consulted when a key is missing
            from this configuration instance.
            </param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.StoredConfig.Load" -->
        <member name="M:NGit.StoredConfig.Save">
            <summary>Save the configuration to the persistent store.</summary>
            <remarks>Save the configuration to the persistent store.</remarks>
            <exception cref="T:System.IO.IOException">the configuration could not be written.</exception>
        </member>
        <member name="M:NGit.Storage.File.FileBasedConfig.#ctor(Sharpen.FilePath,NGit.Util.FS)">
            <summary>Create a configuration with no default fallback.</summary>
            <remarks>Create a configuration with no default fallback.</remarks>
            <param name="cfgLocation">the location of the configuration file on the file system
            	</param>
            <param name="fs">
            the file system abstraction which will be necessary to perform
            certain file system operations.
            </param>
        </member>
        <member name="M:NGit.Storage.File.FileBasedConfig.#ctor(NGit.Config,Sharpen.FilePath,NGit.Util.FS)">
            <summary>The constructor</summary>
            <param name="base">the base configuration file</param>
            <param name="cfgLocation">the location of the configuration file on the file system
            	</param>
            <param name="fs">
            the file system abstraction which will be necessary to perform
            certain file system operations.
            </param>
        </member>
        <member name="M:NGit.Storage.File.FileBasedConfig.GetFile">
            <returns>location of the configuration file on disk</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Storage.File.FileBasedConfig.Load" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Storage.File.FileBasedConfig.Save" -->
        <member name="M:NGit.Storage.File.FileBasedConfig.IsOutdated">
            <returns>
            returns true if the currently loaded configuration file is older
            than the file on disk
            </returns>
        </member>
        <member name="T:NGit.Storage.Pack.StoredObjectRepresentation">
            <summary>
            An object representation
            <see cref="T:NGit.Storage.Pack.PackWriter">PackWriter</see>
            can consider for packing.
            </summary>
        </member>
        <member name="F:NGit.Storage.Pack.StoredObjectRepresentation.WEIGHT_UNKNOWN">
            <summary>
            Special unknown value for
            <see cref="M:NGit.Storage.Pack.StoredObjectRepresentation.GetWeight">GetWeight()</see>
            .
            </summary>
        </member>
        <member name="F:NGit.Storage.Pack.StoredObjectRepresentation.PACK_DELTA">
            <summary>Stored in pack format, as a delta to another object.</summary>
            <remarks>Stored in pack format, as a delta to another object.</remarks>
        </member>
        <member name="F:NGit.Storage.Pack.StoredObjectRepresentation.PACK_WHOLE">
            <summary>Stored in pack format, without delta.</summary>
            <remarks>Stored in pack format, without delta.</remarks>
        </member>
        <member name="F:NGit.Storage.Pack.StoredObjectRepresentation.FORMAT_OTHER">
            <summary>Only available after inflating to canonical format.</summary>
            <remarks>Only available after inflating to canonical format.</remarks>
        </member>
        <member name="M:NGit.Storage.Pack.StoredObjectRepresentation.GetWeight">
            <returns>
            relative size of this object's packed form. The special value
            <see cref="F:NGit.Storage.Pack.StoredObjectRepresentation.WEIGHT_UNKNOWN">WEIGHT_UNKNOWN</see>
            can be returned to indicate the
            implementation doesn't know, or cannot supply the weight up
            front.
            </returns>
        </member>
        <member name="M:NGit.Storage.Pack.StoredObjectRepresentation.GetFormat">
            <returns>
            true if this is a delta against another object and this is stored
            in pack delta format.
            </returns>
        </member>
        <member name="M:NGit.Storage.Pack.StoredObjectRepresentation.GetDeltaBase">
            <returns>
            identity of the object this delta applies to in order to recover
            the original object content. This method should only be called if
            <see cref="M:NGit.Storage.Pack.StoredObjectRepresentation.GetFormat">GetFormat()</see>
            returned
            <see cref="F:NGit.Storage.Pack.StoredObjectRepresentation.PACK_DELTA">PACK_DELTA</see>
            .
            </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Storage.Pack.ObjectToPack" -->
        <!-- Badly formed XML comment ignored for member "T:NGit.Transport.PackedObjectInfo" -->
        <member name="T:NGit.ObjectIdOwnerMap.Entry">
            <summary>
            Type of entry stored in the
            <see cref="T:NGit.ObjectIdOwnerMap`1">ObjectIdOwnerMap&lt;V&gt;</see>
            .
            </summary>
        </member>
        <member name="T:NGit.ObjectIdOwnerMap.Entry">
            <summary>
            Type of entry stored in the
            <see cref="T:NGit.ObjectIdOwnerMap`1">ObjectIdOwnerMap&lt;V&gt;</see>
            .
            </summary>
        </member>
        <member name="M:NGit.ObjectIdOwnerMap.Entry.#ctor(NGit.AnyObjectId)">
            <summary>Initialize this entry with a specific ObjectId.</summary>
            <remarks>Initialize this entry with a specific ObjectId.</remarks>
            <param name="id">the id the entry represents.</param>
        </member>
        <member name="M:NGit.Transport.PackedObjectInfo.#ctor(NGit.AnyObjectId)">
            <summary>Create a new structure to remember information about an object.</summary>
            <remarks>Create a new structure to remember information about an object.</remarks>
            <param name="id">the identity of the object the new instance tracks.</param>
        </member>
        <member name="M:NGit.Transport.PackedObjectInfo.GetOffset">
            <returns>
            offset in pack when object has been already written, or 0 if it
            has not been written yet
            </returns>
        </member>
        <member name="M:NGit.Transport.PackedObjectInfo.SetOffset(System.Int64)">
            <summary>Set the offset in pack when object has been written to.</summary>
            <remarks>Set the offset in pack when object has been written to.</remarks>
            <param name="offset">offset where written object starts</param>
        </member>
        <member name="M:NGit.Transport.PackedObjectInfo.GetCRC">
            <returns>the 32 bit CRC checksum for the packed data.</returns>
        </member>
        <member name="M:NGit.Transport.PackedObjectInfo.SetCRC(System.Int32)">
            <summary>Record the 32 bit CRC checksum for the packed data.</summary>
            <remarks>Record the 32 bit CRC checksum for the packed data.</remarks>
            <param name="crc">
            checksum of all packed data (including object type code,
            inflated length and delta base reference) as computed by
            <see cref="T:Sharpen.CRC32">Sharpen.CRC32</see>
            .
            </param>
        </member>
        <member name="F:NGit.Storage.Pack.ObjectToPack.deltaBase">
            <summary>Other object being packed that this will delta against.</summary>
            <remarks>Other object being packed that this will delta against.</remarks>
        </member>
        <member name="F:NGit.Storage.Pack.ObjectToPack.flags">
            <summary>
            Bit field, from bit 0 to bit 31:
            <ul>
            <li>1 bit: wantWrite</li>
            <li>1 bit: canReuseAsIs</li>
            <li>1 bit: doNotDelta</li>
            <li>1 bit: edgeObject</li>
            <li>1 bit: unused</li>
            <li>3 bits: type</li>
            <li>4 bits: subclass flags (if any)</li>
            <li>--</li>
            <li>20 bits: deltaDepth</li>
            </ul>
            </summary>
        </member>
        <member name="F:NGit.Storage.Pack.ObjectToPack.pathHash">
            <summary>Hash of the object's tree path.</summary>
            <remarks>Hash of the object's tree path.</remarks>
        </member>
        <member name="F:NGit.Storage.Pack.ObjectToPack.cachedDelta">
            <summary>If present, deflated delta instruction stream for this object.</summary>
            <remarks>If present, deflated delta instruction stream for this object.</remarks>
        </member>
        <member name="M:NGit.Storage.Pack.ObjectToPack.#ctor(NGit.AnyObjectId,System.Int32)">
            <summary>Construct for the specified object id.</summary>
            <remarks>Construct for the specified object id.</remarks>
            <param name="src">object id of object for packing</param>
            <param name="type">real type code of the object, not its in-pack type.</param>
        </member>
        <member name="M:NGit.Storage.Pack.ObjectToPack.#ctor(NGit.Revwalk.RevObject)">
            <summary>Construct for the specified object.</summary>
            <remarks>Construct for the specified object.</remarks>
            <param name="obj">
            identity of the object that will be packed. The object's
            parsed status is undefined here. Implementers must not rely on
            the object being parsed.
            </param>
        </member>
        <member name="M:NGit.Storage.Pack.ObjectToPack.GetDeltaBaseId">
            <returns>
            delta base object id if object is going to be packed in delta
            representation; null otherwise - if going to be packed as a
            whole object.
            </returns>
        </member>
        <member name="M:NGit.Storage.Pack.ObjectToPack.GetDeltaBase">
            <returns>
            delta base object to pack if object is going to be packed in
            delta representation and delta is specified as object to
            pack; null otherwise - if going to be packed as a whole
            object or delta base is specified only as id.
            </returns>
        </member>
        <member name="M:NGit.Storage.Pack.ObjectToPack.SetDeltaBase(NGit.ObjectId)">
            <summary>Set delta base for the object.</summary>
            <remarks>
            Set delta base for the object. Delta base set by this method is used
            by
            <see cref="T:NGit.Storage.Pack.PackWriter">PackWriter</see>
            to write object - determines its representation
            in a created pack.
            </remarks>
            <param name="deltaBase">
            delta base object or null if object should be packed as a
            whole object.
            </param>
        </member>
        <member name="M:NGit.Storage.Pack.ObjectToPack.IsDeltaRepresentation">
            <returns>
            true if object is going to be written as delta; false
            otherwise.
            </returns>
        </member>
        <member name="M:NGit.Storage.Pack.ObjectToPack.IsWritten">
            <summary>Check if object is already written in a pack.</summary>
            <remarks>
            Check if object is already written in a pack. This information is
            used to achieve delta-base precedence in a pack file.
            </remarks>
            <returns>true if object is already written; false otherwise.</returns>
        </member>
        <member name="M:NGit.Storage.Pack.ObjectToPack.GetType">
            <returns>the type of this object.</returns>
        </member>
        <member name="M:NGit.Storage.Pack.ObjectToPack.IsReuseAsIs">
            <returns>
            true if an existing representation was selected to be reused
            as-is into the pack stream.
            </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Storage.Pack.ObjectToPack.ClearReuseAsIs" -->
        <member name="M:NGit.Storage.Pack.ObjectToPack.GetExtendedFlags">
            <returns>the extended flags on this object, in the range [0x0, 0xf].</returns>
        </member>
        <member name="M:NGit.Storage.Pack.ObjectToPack.IsExtendedFlag(System.Int32)">
            <summary>Determine if a particular extended flag bit has been set.</summary>
            <remarks>
            Determine if a particular extended flag bit has been set.
            This implementation may be faster than calling
            <see cref="M:NGit.Storage.Pack.ObjectToPack.GetExtendedFlags">GetExtendedFlags()</see>
            and testing the result.
            </remarks>
            <param name="flag">the flag mask to test, must be between 0x0 and 0xf.</param>
            <returns>true if any of the bits matching the mask are non-zero.</returns>
        </member>
        <member name="M:NGit.Storage.Pack.ObjectToPack.SetExtendedFlag(System.Int32)">
            <summary>Set an extended flag bit.</summary>
            <remarks>
            Set an extended flag bit.
            This implementation is more efficient than getting the extended flags,
            adding the bit, and setting them all back.
            </remarks>
            <param name="flag">the bits to set, must be between 0x0 and 0xf.</param>
        </member>
        <member name="M:NGit.Storage.Pack.ObjectToPack.ClearExtendedFlag(System.Int32)">
            <summary>Clear an extended flag bit.</summary>
            <remarks>
            Clear an extended flag bit.
            This implementation is more efficient than getting the extended flags,
            removing the bit, and setting them all back.
            </remarks>
            <param name="flag">the bits to clear, must be between 0x0 and 0xf.</param>
        </member>
        <member name="M:NGit.Storage.Pack.ObjectToPack.SetExtendedFlags(System.Int32)">
            <summary>Set the extended flags used by the subclass.</summary>
            <remarks>
            Set the extended flags used by the subclass.
            Subclass implementations may store up to 4 bits of information inside of
            the internal flags field already used by the base ObjectToPack instance.
            </remarks>
            <param name="extFlags">
            additional flag bits to store in the flags field. Due to space
            constraints only values [0x0, 0xf] are permitted.
            </param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Storage.Pack.ObjectToPack.Select(NGit.Storage.Pack.StoredObjectRepresentation)" -->
        <!-- Badly formed XML comment ignored for member "T:NGit.Storage.File.PackReverseIndex" -->
        <member name="F:NGit.Storage.File.PackReverseIndex.index">
            <summary>Index we were created from, and that has our ObjectId data.</summary>
            <remarks>Index we were created from, and that has our ObjectId data.</remarks>
        </member>
        <member name="F:NGit.Storage.File.PackReverseIndex.offsets32">
            <summary>(offset31, truly) Offsets accommodating in 31 bits.</summary>
            <remarks>(offset31, truly) Offsets accommodating in 31 bits.</remarks>
        </member>
        <member name="F:NGit.Storage.File.PackReverseIndex.offsets64">
            <summary>Offsets not accommodating in 31 bits.</summary>
            <remarks>Offsets not accommodating in 31 bits.</remarks>
        </member>
        <member name="F:NGit.Storage.File.PackReverseIndex.nth32">
            <summary>
            Position of the corresponding
            <see cref="F:NGit.Storage.File.PackReverseIndex.offsets32">offsets32</see>
            in
            <see cref="F:NGit.Storage.File.PackReverseIndex.index">index</see>
            .
            </summary>
        </member>
        <member name="F:NGit.Storage.File.PackReverseIndex.nth64">
            <summary>
            Position of the corresponding
            <see cref="F:NGit.Storage.File.PackReverseIndex.offsets64">offsets64</see>
            in
            <see cref="F:NGit.Storage.File.PackReverseIndex.index">index</see>
            .
            </summary>
        </member>
        <member name="M:NGit.Storage.File.PackReverseIndex.#ctor(NGit.Storage.File.PackIndex)">
            <summary>
            Create reverse index from straight/forward pack index, by indexing all
            its entries.
            </summary>
            <remarks>
            Create reverse index from straight/forward pack index, by indexing all
            its entries.
            </remarks>
            <param name="packIndex">forward index - entries to (reverse) index.</param>
        </member>
        <member name="M:NGit.Storage.File.PackReverseIndex.FindObject(System.Int64)">
            <summary>
            Search for object id with the specified start offset in this pack
            (reverse) index.
            </summary>
            <remarks>
            Search for object id with the specified start offset in this pack
            (reverse) index.
            </remarks>
            <param name="offset">start offset of object to find.</param>
            <returns>object id for this offset, or null if no object was found.</returns>
        </member>
        <member name="M:NGit.Storage.File.PackReverseIndex.FindNextOffset(System.Int64,System.Int64)">
            <summary>
            Search for the next offset to the specified offset in this pack (reverse)
            index.
            </summary>
            <remarks>
            Search for the next offset to the specified offset in this pack (reverse)
            index.
            </remarks>
            <param name="offset">
            start offset of previous object (must be valid-existing
            offset).
            </param>
            <param name="maxOffset">
            maximum offset in a pack (returned when there is no next
            offset).
            </param>
            <returns>
            offset of the next object in a pack or maxOffset if provided
            offset was the last one.
            </returns>
            <exception cref="T:NGit.Errors.CorruptObjectException">when there is no object with the provided offset.
            	</exception>
        </member>
        <member name="T:NGit.Storage.File.PackIndex">
            <summary>
            Access path to locate objects by
            <see cref="T:NGit.ObjectId">NGit.ObjectId</see>
            in a
            <see cref="T:NGit.Storage.File.PackFile">PackFile</see>
            .
            <p>
            Indexes are strictly redundant information in that we can rebuild all of the
            data held in the index file from the on disk representation of the pack file
            itself, but it is faster to access for random requests because data is stored
            by ObjectId.
            </p>
            </summary>
        </member>
        <member name="M:NGit.Storage.File.PackIndex.Open(Sharpen.FilePath)">
            <summary>Open an existing pack <code>.idx</code> file for reading.</summary>
            <remarks>
            Open an existing pack <code>.idx</code> file for reading.
            <p>
            The format of the file will be automatically detected and a proper access
            implementation for that format will be constructed and returned to the
            caller. The file may or may not be held open by the returned instance.
            </p>
            </remarks>
            <param name="idxFile">existing pack .idx to read.</param>
            <returns>access implementation for the requested file.</returns>
            <exception cref="T:System.IO.FileNotFoundException">the file does not exist.</exception>
            <exception cref="T:System.IO.IOException">
            the file exists but could not be read due to security errors,
            unrecognized data version, or unexpected data corruption.
            </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Storage.File.PackIndex.Read(Sharpen.InputStream)" -->
        <member name="F:NGit.Storage.File.PackIndex.packChecksum">
            <summary>Footer checksum applied on the bottom of the pack file.</summary>
            <remarks>Footer checksum applied on the bottom of the pack file.</remarks>
        </member>
        <member name="M:NGit.Storage.File.PackIndex.HasObject(NGit.AnyObjectId)">
            <summary>Determine if an object is contained within the pack file.</summary>
            <remarks>Determine if an object is contained within the pack file.</remarks>
            <param name="id">the object to look for. Must not be null.</param>
            <returns>true if the object is listed in this index; false otherwise.</returns>
        </member>
        <member name="M:NGit.Storage.File.PackIndex.Iterator">
            <summary>Provide iterator that gives access to index entries.</summary>
            <remarks>
            Provide iterator that gives access to index entries. Note, that iterator
            returns reference to mutable object, the same reference in each call -
            for performance reason. If client needs immutable objects, it must copy
            returned object on its own.
            <p>
            Iterator returns objects in SHA-1 lexicographical order.
            </p>
            </remarks>
            <returns>iterator over pack index entries</returns>
        </member>
        <member name="M:NGit.Storage.File.PackIndex.GetObjectCount">
            <summary>Obtain the total number of objects described by this index.</summary>
            <remarks>Obtain the total number of objects described by this index.</remarks>
            <returns>
            number of objects in this index, and likewise in the associated
            pack that this index was generated from.
            </returns>
        </member>
        <member name="M:NGit.Storage.File.PackIndex.GetOffset64Count">
            <summary>Obtain the total number of objects needing 64 bit offsets.</summary>
            <remarks>Obtain the total number of objects needing 64 bit offsets.</remarks>
            <returns>
            number of objects in this index using a 64 bit offset; that is an
            object positioned after the 2 GB position within the file.
            </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Storage.File.PackIndex.GetObjectId(System.Int64)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Storage.File.PackIndex.GetObjectId(System.Int32)" -->
        <member name="M:NGit.Storage.File.PackIndex.FindOffset(NGit.AnyObjectId)">
            <summary>Locate the file offset position for the requested object.</summary>
            <remarks>Locate the file offset position for the requested object.</remarks>
            <param name="objId">name of the object to locate within the pack.</param>
            <returns>
            offset of the object's header and compressed content; -1 if the
            object does not exist in this index and is thus not stored in the
            associated pack.
            </returns>
        </member>
        <member name="M:NGit.Storage.File.PackIndex.FindCRC32(NGit.AnyObjectId)">
            <summary>
            Retrieve stored CRC32 checksum of the requested object raw-data
            (including header).
            </summary>
            <remarks>
            Retrieve stored CRC32 checksum of the requested object raw-data
            (including header).
            </remarks>
            <param name="objId">id of object to look for</param>
            <returns>CRC32 checksum of specified object (at 32 less significant bits)</returns>
            <exception cref="T:NGit.Errors.MissingObjectException">when requested ObjectId was not found in this index
            	</exception>
            <exception cref="T:System.NotSupportedException">when this index doesn't support CRC32 checksum
            	</exception>
        </member>
        <member name="M:NGit.Storage.File.PackIndex.HasCRC32Support">
            <summary>Check whether this index supports (has) CRC32 checksums for objects.</summary>
            <remarks>Check whether this index supports (has) CRC32 checksums for objects.</remarks>
            <returns>true if CRC32 is stored, false otherwise</returns>
        </member>
        <member name="M:NGit.Storage.File.PackIndex.Resolve(System.Collections.Generic.ICollection{NGit.ObjectId},NGit.AbbreviatedObjectId,System.Int32)">
            <summary>Find objects matching the prefix abbreviation.</summary>
            <remarks>Find objects matching the prefix abbreviation.</remarks>
            <param name="matches">
            set to add any located ObjectIds to. This is an output
            parameter.
            </param>
            <param name="id">prefix to search for.</param>
            <param name="matchLimit">
            maximum number of results to return. At most this many
            ObjectIds should be added to matches before returning.
            </param>
            <exception cref="T:System.IO.IOException">the index cannot be read.</exception>
        </member>
        <member name="T:NGit.Storage.File.PackIndex.MutableEntry">
            <summary>
            Represent mutable entry of pack index consisting of object id and offset
            in pack (both mutable).
            </summary>
            <remarks>
            Represent mutable entry of pack index consisting of object id and offset
            in pack (both mutable).
            </remarks>
        </member>
        <member name="M:NGit.Storage.File.PackIndex.MutableEntry.GetOffset">
            <summary>Returns offset for this index object entry</summary>
            <returns>offset of this object in a pack file</returns>
        </member>
        <member name="M:NGit.Storage.File.PackIndex.MutableEntry.Name">
            <returns>hex string describing the object id of this entry.</returns>
        </member>
        <member name="M:NGit.Storage.File.PackIndex.MutableEntry.ToObjectId">
            <returns>a copy of the object id.</returns>
        </member>
        <member name="M:NGit.Storage.File.PackIndex.MutableEntry.CloneEntry">
            <returns>a complete copy of this entry, that won't modify</returns>
        </member>
        <member name="M:NGit.Storage.File.PackIndex.EntriesIterator.Next">
            <summary>
            Implementation must update
            <see cref="F:NGit.Storage.File.PackIndex.EntriesIterator.returnedNumber">returnedNumber</see>
            before returning
            element.
            </summary>
        </member>
        <member name="M:NGit.Storage.File.PackIndexV1.#ctor(Sharpen.InputStream,System.Byte[])">
            <exception cref="T:NGit.Errors.CorruptObjectException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.PackIndexV1.Resolve(System.Collections.Generic.ICollection{NGit.ObjectId},NGit.AbbreviatedObjectId,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="T:NGit.Storage.File.ByteArrayWindow">
            <summary>
            A
            <see cref="T:NGit.Storage.File.ByteWindow">ByteWindow</see>
            with an underlying byte array for storage.
            </summary>
        </member>
        <member name="T:NGit.Storage.File.ByteWindow">
            <summary>A window of data currently stored within a cache.</summary>
            <remarks>
            A window of data currently stored within a cache.
            <p>
            All bytes in the window can be assumed to be "immediately available", that is
            they are very likely already in memory, unless the operating system's memory
            is very low and has paged part of this process out to disk. Therefore copying
            bytes from a window is very inexpensive.
            </p>
            </remarks>
        </member>
        <member name="M:NGit.Storage.File.ByteWindow.Copy(System.Int64,System.Byte[],System.Int32,System.Int32)">
            <summary>Copy bytes from the window to a caller supplied buffer.</summary>
            <remarks>Copy bytes from the window to a caller supplied buffer.</remarks>
            <param name="pos">offset within the file to start copying from.</param>
            <param name="dstbuf">destination buffer to copy into.</param>
            <param name="dstoff">offset within <code>dstbuf</code> to start copying into.</param>
            <param name="cnt">
            number of bytes to copy. This value may exceed the number of
            bytes remaining in the window starting at offset
            <code>pos</code>.
            </param>
            <returns>
            number of bytes actually copied; this may be less than
            <code>cnt</code> if <code>cnt</code> exceeded the number of
            bytes available.
            </returns>
        </member>
        <member name="M:NGit.Storage.File.ByteWindow.Copy(System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>Copy bytes from the window to a caller supplied buffer.</summary>
            <remarks>Copy bytes from the window to a caller supplied buffer.</remarks>
            <param name="pos">offset within the window to start copying from.</param>
            <param name="dstbuf">destination buffer to copy into.</param>
            <param name="dstoff">offset within <code>dstbuf</code> to start copying into.</param>
            <param name="cnt">
            number of bytes to copy. This value may exceed the number of
            bytes remaining in the window starting at offset
            <code>pos</code>.
            </param>
            <returns>
            number of bytes actually copied; this may be less than
            <code>cnt</code> if <code>cnt</code> exceeded the number of
            bytes available.
            </returns>
        </member>
        <member name="M:NGit.Storage.File.ByteWindow.Write(NGit.Storage.Pack.PackOutputStream,System.Int64,System.Int32,Sharpen.MessageDigest)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.ByteWindow.SetInput(System.Int64,ICSharpCode.SharpZipLib.Zip.Compression.Inflater)">
            <exception cref="T:ICSharpCode.SharpZipLib.SharpZipBaseException"></exception>
        </member>
        <member name="M:NGit.Storage.File.ByteWindow.SetInput(System.Int32,ICSharpCode.SharpZipLib.Zip.Compression.Inflater)">
            <exception cref="T:ICSharpCode.SharpZipLib.SharpZipBaseException"></exception>
        </member>
        <member name="M:NGit.Storage.File.ByteArrayWindow.SetInput(System.Int32,ICSharpCode.SharpZipLib.Zip.Compression.Inflater)">
            <exception cref="T:ICSharpCode.SharpZipLib.SharpZipBaseException"></exception>
        </member>
        <member name="M:NGit.Storage.File.ByteArrayWindow.Write(NGit.Storage.Pack.PackOutputStream,System.Int64,System.Int32,Sharpen.MessageDigest)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.ByteArrayWindow.Check(ICSharpCode.SharpZipLib.Zip.Compression.Inflater,System.Byte[],System.Int64,System.Int32)">
            <exception cref="T:ICSharpCode.SharpZipLib.SharpZipBaseException"></exception>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Revwalk.Filter.RevFilter" -->
        <member name="F:NGit.Revwalk.Filter.RevFilter.ALL">
            <summary>Default filter that always returns true (thread safe).</summary>
            <remarks>Default filter that always returns true (thread safe).</remarks>
        </member>
        <member name="F:NGit.Revwalk.Filter.RevFilter.NONE">
            <summary>Default filter that always returns false (thread safe).</summary>
            <remarks>Default filter that always returns false (thread safe).</remarks>
        </member>
        <member name="F:NGit.Revwalk.Filter.RevFilter.NO_MERGES">
            <summary>Excludes commits with more than one parent (thread safe).</summary>
            <remarks>Excludes commits with more than one parent (thread safe).</remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "F:NGit.Revwalk.Filter.RevFilter.MERGE_BASE" -->
        <member name="M:NGit.Revwalk.Filter.RevFilter.Negate">
            <summary>Create a new filter that does the opposite of this filter.</summary>
            <remarks>Create a new filter that does the opposite of this filter.</remarks>
            <returns>a new filter that includes commits this filter rejects.</returns>
        </member>
        <member name="M:NGit.Revwalk.Filter.RevFilter.RequiresCommitBody">
            <returns>true if the filter needs the commit body to be parsed.</returns>
        </member>
        <member name="M:NGit.Revwalk.Filter.RevFilter.Include(NGit.Revwalk.RevWalk,NGit.Revwalk.RevCommit)">
            <summary>Determine if the supplied commit should be included in results.</summary>
            <remarks>Determine if the supplied commit should be included in results.</remarks>
            <param name="walker">the active walker this filter is being invoked from within.</param>
            <param name="cmit">
            the commit currently being tested. The commit has been parsed
            and its body is available for inspection only if the filter
            returns true from
            <see cref="M:NGit.Revwalk.Filter.RevFilter.RequiresCommitBody">RequiresCommitBody()</see>
            .
            </param>
            <returns>
            true to include this commit in the results; false to have this
            commit be omitted entirely from the results.
            </returns>
            <exception cref="T:NGit.Errors.StopWalkException">
            the filter knows for certain that no additional commits can
            ever match, and the current commit doesn't match either. The
            walk is halted and no more results are provided.
            </exception>
            <exception cref="T:NGit.Errors.MissingObjectException">
            an object the filter needs to consult to determine its answer
            does not exist in the Git repository the walker is operating
            on. Filtering this commit is impossible without the object.
            </exception>
            <exception cref="T:NGit.Errors.IncorrectObjectTypeException">
            an object the filter needed to consult was not of the
            expected object type. This usually indicates a corrupt
            repository, as an object link is referencing the wrong type.
            </exception>
            <exception cref="T:System.IO.IOException">
            a loose object or pack file could not be read to obtain data
            necessary for the filter to make its decision.
            </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Revwalk.Filter.RevFilter.Clone" -->
        <!-- Badly formed XML comment ignored for member "T:NGit.Merge.StrategyOneSided" -->
        <!-- Badly formed XML comment ignored for member "T:NGit.Merge.MergeStrategy" -->
        <member name="F:NGit.Merge.MergeStrategy.OURS">
            <summary>Simple strategy that sets the output tree to the first input tree.</summary>
            <remarks>Simple strategy that sets the output tree to the first input tree.</remarks>
        </member>
        <member name="F:NGit.Merge.MergeStrategy.THEIRS">
            <summary>Simple strategy that sets the output tree to the second input tree.</summary>
            <remarks>Simple strategy that sets the output tree to the second input tree.</remarks>
        </member>
        <member name="F:NGit.Merge.MergeStrategy.SIMPLE_TWO_WAY_IN_CORE">
            <summary>Simple strategy to merge paths, without simultaneous edits.</summary>
            <remarks>Simple strategy to merge paths, without simultaneous edits.</remarks>
        </member>
        <member name="F:NGit.Merge.MergeStrategy.RESOLVE">
            <summary>Simple strategy to merge paths.</summary>
            <remarks>Simple strategy to merge paths. It tries to merge also contents. Multiple merge bases are not supported
            	</remarks>
        </member>
        <member name="M:NGit.Merge.MergeStrategy.Register(NGit.Merge.MergeStrategy)">
            <summary>Register a merge strategy so it can later be obtained by name.</summary>
            <remarks>Register a merge strategy so it can later be obtained by name.</remarks>
            <param name="imp">the strategy to register.</param>
            <exception cref="T:System.ArgumentException">a strategy by the same name has already been registered.
            	</exception>
        </member>
        <member name="M:NGit.Merge.MergeStrategy.Register(System.String,NGit.Merge.MergeStrategy)">
            <summary>Register a merge strategy so it can later be obtained by name.</summary>
            <remarks>Register a merge strategy so it can later be obtained by name.</remarks>
            <param name="name">name the strategy can be looked up under.</param>
            <param name="imp">the strategy to register.</param>
            <exception cref="T:System.ArgumentException">a strategy by the same name has already been registered.
            	</exception>
        </member>
        <member name="M:NGit.Merge.MergeStrategy.Get(System.String)">
            <summary>Locate a strategy by name.</summary>
            <remarks>Locate a strategy by name.</remarks>
            <param name="name">name of the strategy to locate.</param>
            <returns>the strategy instance; null if no strategy matches the name.</returns>
        </member>
        <member name="M:NGit.Merge.MergeStrategy.Get">
            <summary>Get all registered strategies.</summary>
            <remarks>Get all registered strategies.</remarks>
            <returns>
            the registered strategy instances. No inherit order is returned;
            the caller may modify (and/or sort) the returned array if
            necessary to obtain a reasonable ordering.
            </returns>
        </member>
        <member name="M:NGit.Merge.MergeStrategy.GetName">
            <returns>default name of this strategy implementation.</returns>
        </member>
        <member name="M:NGit.Merge.MergeStrategy.NewMerger(NGit.Repository)">
            <summary>Create a new merge instance.</summary>
            <remarks>Create a new merge instance.</remarks>
            <param name="db">
            repository database the merger will read from, and eventually
            write results back to.
            </param>
            <returns>the new merge instance which implements this strategy.</returns>
        </member>
        <member name="M:NGit.Merge.MergeStrategy.NewMerger(NGit.Repository,System.Boolean)">
            <summary>Create a new merge instance.</summary>
            <remarks>Create a new merge instance.</remarks>
            <param name="db">
            repository database the merger will read from, and eventually
            write results back to.
            </param>
            <param name="inCore">
            the merge will happen in memory, working folder will not be
            modified, in case of a non-trivial merge that requires manual
            resolution, the merger will fail.
            </param>
            <returns>the new merge instance which implements this strategy.</returns>
        </member>
        <member name="M:NGit.Merge.StrategyOneSided.#ctor(System.String,System.Int32)">
            <summary>Create a new merge strategy to select a specific input tree.</summary>
            <remarks>Create a new merge strategy to select a specific input tree.</remarks>
            <param name="name">name of this strategy.</param>
            <param name="index">the position of the input tree to accept as the result.</param>
        </member>
        <member name="T:NGit.Merge.Merger">
            <summary>
            Instance of a specific
            <see cref="T:NGit.Merge.MergeStrategy">MergeStrategy</see>
            for a single
            <see cref="T:NGit.Repository">NGit.Repository</see>
            .
            </summary>
        </member>
        <member name="F:NGit.Merge.Merger.db">
            <summary>The repository this merger operates on.</summary>
            <remarks>The repository this merger operates on.</remarks>
        </member>
        <member name="F:NGit.Merge.Merger.reader">
            <summary>
            Reader to support
            <see cref="F:NGit.Merge.Merger.walk">walk</see>
            and other object loading.
            </summary>
        </member>
        <member name="F:NGit.Merge.Merger.walk">
            <summary>A RevWalk for computing merge bases, or listing incoming commits.</summary>
            <remarks>A RevWalk for computing merge bases, or listing incoming commits.</remarks>
        </member>
        <member name="F:NGit.Merge.Merger.sourceObjects">
            <summary>The original objects supplied in the merge; this can be any tree-ish.</summary>
            <remarks>The original objects supplied in the merge; this can be any tree-ish.</remarks>
        </member>
        <member name="F:NGit.Merge.Merger.sourceCommits">
            <summary>
            If
            <see cref="F:NGit.Merge.Merger.sourceObjects">sourceObjects</see>
            [i] is a commit, this is the commit.
            </summary>
        </member>
        <member name="F:NGit.Merge.Merger.sourceTrees">
            <summary>
            The trees matching every entry in
            <see cref="F:NGit.Merge.Merger.sourceObjects">sourceObjects</see>
            .
            </summary>
        </member>
        <member name="M:NGit.Merge.Merger.#ctor(NGit.Repository)">
            <summary>Create a new merge instance for a repository.</summary>
            <remarks>Create a new merge instance for a repository.</remarks>
            <param name="local">the repository this merger will read and write data on.</param>
        </member>
        <member name="M:NGit.Merge.Merger.GetRepository">
            <returns>the repository this merger operates on.</returns>
        </member>
        <member name="M:NGit.Merge.Merger.GetObjectInserter">
            <returns>
            an object writer to create objects in
            <see cref="M:NGit.Merge.Merger.GetRepository">GetRepository()</see>
            .
            If no inserter has been set on this instance, one will be created
            and returned by all future calls.
            </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Merge.Merger.SetObjectInserter(NGit.ObjectInserter)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Merge.Merger.Merge(NGit.AnyObjectId[])" -->
        <member name="M:NGit.Merge.Merger.MergeBase(System.Int32,System.Int32)">
            <summary>Create an iterator to walk the merge base of two commits.</summary>
            <remarks>Create an iterator to walk the merge base of two commits.</remarks>
            <param name="aIdx">
            index of the first commit in
            <see cref="F:NGit.Merge.Merger.sourceObjects">sourceObjects</see>
            .
            </param>
            <param name="bIdx">
            index of the second commit in
            <see cref="F:NGit.Merge.Merger.sourceObjects">sourceObjects</see>
            .
            </param>
            <returns>the new iterator</returns>
            <exception cref="T:NGit.Errors.IncorrectObjectTypeException">one of the input objects is not a commit.
            	</exception>
            <exception cref="T:System.IO.IOException">objects are missing or multiple merge bases were found.
            	</exception>
        </member>
        <member name="M:NGit.Merge.Merger.GetBaseCommit(System.Int32,System.Int32)">
            <summary>Return the merge base of two commits.</summary>
            <remarks>Return the merge base of two commits.</remarks>
            <param name="aIdx">
            index of the first commit in
            <see cref="F:NGit.Merge.Merger.sourceObjects">sourceObjects</see>
            .
            </param>
            <param name="bIdx">
            index of the second commit in
            <see cref="F:NGit.Merge.Merger.sourceObjects">sourceObjects</see>
            .
            </param>
            <returns>the merge base of two commits</returns>
            <exception cref="T:NGit.Errors.IncorrectObjectTypeException">one of the input objects is not a commit.
            	</exception>
            <exception cref="T:System.IO.IOException">objects are missing or multiple merge bases were found.
            	</exception>
        </member>
        <member name="M:NGit.Merge.Merger.OpenTree(NGit.AnyObjectId)">
            <summary>Open an iterator over a tree.</summary>
            <remarks>Open an iterator over a tree.</remarks>
            <param name="treeId">the tree to scan; must be a tree (not a treeish).</param>
            <returns>an iterator for the tree.</returns>
            <exception cref="T:NGit.Errors.IncorrectObjectTypeException">the input object is not a tree.
            	</exception>
            <exception cref="T:System.IO.IOException">the tree object is not found or cannot be read.
            	</exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Merge.Merger.MergeImpl" -->
        <member name="M:NGit.Merge.Merger.GetResultTreeId">
            <returns>
            resulting tree, if
            <see cref="M:NGit.Merge.Merger.Merge(NGit.AnyObjectId[])">Merge(NGit.AnyObjectId[])</see>
            returned true.
            </returns>
        </member>
        <member name="M:NGit.Merge.StrategyOneSided.OneSide.MergeImpl">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="T:NGit.Ignore.IgnoreRule">
            <summary>
            A single ignore rule corresponding to one line in a .gitignore or
            ignore file.
            </summary>
            <remarks>
            A single ignore rule corresponding to one line in a .gitignore or
            ignore file. Parses the ignore pattern
            Inspiration from: Ferry Huberts
            </remarks>
        </member>
        <member name="M:NGit.Ignore.IgnoreRule.#ctor(System.String)">
            <summary>Create a new ignore rule with the given pattern.</summary>
            <remarks>
            Create a new ignore rule with the given pattern. Assumes that
            the pattern is already trimmed.
            </remarks>
            <param name="pattern">
            Base pattern for the ignore rule. This pattern will
            be parsed to generate rule parameters.
            </param>
        </member>
        <member name="M:NGit.Ignore.IgnoreRule.Setup">
            <summary>Remove leading/trailing characters as needed.</summary>
            <remarks>
            Remove leading/trailing characters as needed. Set up
            rule variables for later matching.
            </remarks>
        </member>
        <member name="M:NGit.Ignore.IgnoreRule.GetNameOnly">
            <returns>True if the pattern is just a file name and not a path</returns>
        </member>
        <member name="M:NGit.Ignore.IgnoreRule.DirOnly">
            <returns>True if the pattern should match directories only</returns>
        </member>
        <member name="M:NGit.Ignore.IgnoreRule.GetNegation">
            <returns>True if the pattern had a "!" in front of it</returns>
        </member>
        <member name="M:NGit.Ignore.IgnoreRule.GetPattern">
            <returns>The blob pattern to be used as a matcher</returns>
        </member>
        <member name="M:NGit.Ignore.IgnoreRule.IsMatch(System.String,System.Boolean)">
            <summary>Returns true if a match was made.</summary>
            <remarks>
            Returns true if a match was made.
            <br/>
            This function does NOT return the actual ignore status of the
            target! Please consult
            <see cref="M:NGit.Ignore.IgnoreRule.GetResult">GetResult()</see>
            for the ignore status. The actual
            ignore status may be true or false depending on whether this rule is
            an ignore rule or a negation rule.
            </remarks>
            <param name="target">Name pattern of the file, relative to the base directory of this rule
            	</param>
            <param name="isDirectory">Whether the target file is a directory or not</param>
            <returns>
            True if a match was made. This does not necessarily mean that
            the target is ignored. Call
            <see cref="M:NGit.Ignore.IgnoreRule.GetResult">getResult()</see>
            for the result.
            </returns>
        </member>
        <member name="M:NGit.Ignore.IgnoreRule.GetResult">
            <summary>
            If a call to <code>isMatch(String, boolean)</code> was previously
            made, this will return whether or not the target was ignored.
            </summary>
            <remarks>
            If a call to <code>isMatch(String, boolean)</code> was previously
            made, this will return whether or not the target was ignored. Otherwise
            this just indicates whether the rule is non-negation or negation.
            </remarks>
            <returns>True if the target is to be ignored, false otherwise.</returns>
        </member>
        <member name="T:NGit.Events.IndexChangedEvent">
            <summary>Describes a change to one or more paths in the index file.</summary>
            <remarks>Describes a change to one or more paths in the index file.</remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Events.RepositoryEvent`1" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Events.RepositoryEvent`1.SetRepository(NGit.Repository)" -->
        <member name="M:NGit.Events.RepositoryEvent`1.GetRepository">
            <returns>the repository that was changed.</returns>
        </member>
        <member name="M:NGit.Events.RepositoryEvent`1.GetListenerType">
            <returns>type of listener this event dispatches to.</returns>
        </member>
        <member name="M:NGit.Events.RepositoryEvent`1.Dispatch(`0)">
            <summary>Dispatch this event to the given listener.</summary>
            <remarks>Dispatch this event to the given listener.</remarks>
            <param name="listener">listener that wants this event.</param>
        </member>
        <member name="T:NGit.Diff.EditList">
            <summary>
            Specialized list of
            <see cref="T:NGit.Diff.Edit">Edit</see>
            s in a document.
            </summary>
        </member>
        <member name="M:NGit.Diff.EditList.Singleton(NGit.Diff.Edit)">
            <summary>Construct an edit list containing a single edit.</summary>
            <remarks>Construct an edit list containing a single edit.</remarks>
            <param name="edit">the edit to return in the list.</param>
            <returns>
            list containing only
            <code>edit</code>
            .
            </returns>
        </member>
        <member name="M:NGit.Diff.EditList.#ctor">
            <summary>Create a new, empty edit list.</summary>
            <remarks>Create a new, empty edit list.</remarks>
        </member>
        <member name="M:NGit.Diff.EditList.#ctor(System.Int32)">
            <summary>Create an empty edit list with the specified capacity.</summary>
            <remarks>Create an empty edit list with the specified capacity.</remarks>
            <param name="capacity">
            the initial capacity of the edit list. If additional edits are
            added to the list, it will be grown to support them.
            </param>
        </member>
        <member name="T:NGit.Tree">
            <summary>A representation of a Git tree entry.</summary>
            <remarks>A representation of a Git tree entry. A Tree is a directory in Git.</remarks>
        </member>
        <member name="T:NGit.TreeEntry">
            <summary>This class represents an entry in a tree, like a blob or another tree.</summary>
            <remarks>This class represents an entry in a tree, like a blob or another tree.</remarks>
        </member>
        <member name="M:NGit.TreeEntry.#ctor(NGit.Tree,NGit.ObjectId,System.Byte[])">
            <summary>Construct a named tree entry.</summary>
            <remarks>Construct a named tree entry.</remarks>
            <param name="myParent"></param>
            <param name="myId"></param>
            <param name="myNameUTF8"></param>
        </member>
        <member name="M:NGit.TreeEntry.GetParent">
            <returns>parent of this tree.</returns>
        </member>
        <member name="M:NGit.TreeEntry.Delete">
            <summary>Delete this entry.</summary>
            <remarks>Delete this entry.</remarks>
        </member>
        <member name="M:NGit.TreeEntry.DetachParent">
            <summary>Detach this entry from it's parent.</summary>
            <remarks>Detach this entry from it's parent.</remarks>
        </member>
        <member name="M:NGit.TreeEntry.GetRepository">
            <returns>the repository owning this entry.</returns>
        </member>
        <member name="M:NGit.TreeEntry.GetNameUTF8">
            <returns>the raw byte name of this entry.</returns>
        </member>
        <member name="M:NGit.TreeEntry.GetName">
            <returns>the name of this entry.</returns>
        </member>
        <member name="M:NGit.TreeEntry.Rename(System.String)">
            <summary>Rename this entry.</summary>
            <remarks>Rename this entry.</remarks>
            <param name="n">The new name</param>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:NGit.TreeEntry.Rename(System.Byte[])">
            <summary>Rename this entry.</summary>
            <remarks>Rename this entry.</remarks>
            <param name="n">The new name</param>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:NGit.TreeEntry.IsModified">
            <returns>true if this entry is new or modified since being loaded.</returns>
        </member>
        <member name="M:NGit.TreeEntry.SetModified">
            <summary>Mark this entry as modified.</summary>
            <remarks>Mark this entry as modified.</remarks>
        </member>
        <member name="M:NGit.TreeEntry.GetId">
            <returns>SHA-1 of this tree entry (null for new unhashed entries)</returns>
        </member>
        <member name="M:NGit.TreeEntry.SetId(NGit.ObjectId)">
            <summary>Set (update) the SHA-1 of this entry.</summary>
            <remarks>
            Set (update) the SHA-1 of this entry. Invalidates the id's of all
            entries above this entry as they will have to be recomputed.
            </remarks>
            <param name="n">SHA-1 for this entry.</param>
        </member>
        <member name="M:NGit.TreeEntry.GetFullName">
            <returns>repository relative name of this entry</returns>
        </member>
        <member name="M:NGit.TreeEntry.GetFullNameUTF8">
            <returns>
            repository relative name of the entry
            FIXME better encoding
            </returns>
        </member>
        <member name="M:NGit.TreeEntry.LastChar(NGit.TreeEntry)">
            <summary>Helper for accessing tree/blob methods.</summary>
            <remarks>Helper for accessing tree/blob methods.</remarks>
            <param name="treeEntry"></param>
            <returns>'/' for Tree entries and NUL for non-treeish objects.</returns>
        </member>
        <member name="M:NGit.TreeEntry.GetMode">
            <returns>mode (type of object)</returns>
        </member>
        <member name="M:NGit.Tree.CompareNames(System.Byte[],System.Byte[],System.Int32,System.Int32)">
            <summary>Compare two names represented as bytes.</summary>
            <remarks>
            Compare two names represented as bytes. Since git treats names of trees and
            blobs differently we have one parameter that represents a '/' for trees. For
            other objects the value should be NUL. The names are compare by their positive
            byte value (0..255).
            A blob and a tree with the same name will not compare equal.
            </remarks>
            <param name="a">name</param>
            <param name="b">name</param>
            <param name="lasta">'/' if a is a tree, else NUL</param>
            <param name="lastb">'/' if b is a tree, else NUL</param>
            <returns>&lt; 0 if a is sorted before b, 0 if they are the same, else b</returns>
        </member>
        <member name="M:NGit.Tree.#ctor(NGit.Repository)">
            <summary>Constructor for a new Tree</summary>
            <param name="repo">The repository that owns the Tree.</param>
        </member>
        <member name="M:NGit.Tree.#ctor(NGit.Repository,NGit.ObjectId,System.Byte[])">
            <summary>Construct a Tree object with known content and hash value</summary>
            <param name="repo"></param>
            <param name="myId"></param>
            <param name="raw"></param>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:NGit.Tree.#ctor(NGit.Tree,System.Byte[])">
            <summary>Construct a new Tree under another Tree</summary>
            <param name="parent"></param>
            <param name="nameUTF8"></param>
        </member>
        <member name="M:NGit.Tree.#ctor(NGit.Tree,NGit.ObjectId,System.Byte[])">
            <summary>Construct a Tree with a known SHA-1 under another tree.</summary>
            <remarks>
            Construct a Tree with a known SHA-1 under another tree. Data is not yet
            specified and will have to be loaded on demand.
            </remarks>
            <param name="parent"></param>
            <param name="id"></param>
            <param name="nameUTF8"></param>
        </member>
        <member name="M:NGit.Tree.IsRoot">
            <returns>true if this Tree is the top level Tree.</returns>
        </member>
        <member name="M:NGit.Tree.IsLoaded">
            <returns>true of the data of this Tree is loaded</returns>
        </member>
        <member name="M:NGit.Tree.Unload">
            <summary>Forget the in-memory data for this tree.</summary>
            <remarks>Forget the in-memory data for this tree.</remarks>
        </member>
        <member name="M:NGit.Tree.AddFile(System.String)">
            <summary>Adds a new or existing file with the specified name to this tree.</summary>
            <remarks>
            Adds a new or existing file with the specified name to this tree.
            Trees are added if necessary as the name may contain '/':s.
            </remarks>
            <param name="name">Name</param>
            <returns>
            a
            <see cref="T:NGit.FileTreeEntry">FileTreeEntry</see>
            for the added file.
            </returns>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:NGit.Tree.AddFile(System.Byte[],System.Int32)">
            <summary>Adds a new or existing file with the specified name to this tree.</summary>
            <remarks>
            Adds a new or existing file with the specified name to this tree.
            Trees are added if necessary as the name may contain '/':s.
            </remarks>
            <param name="s">an array containing the name</param>
            <param name="offset">when the name starts in the tree.</param>
            <returns>
            a
            <see cref="T:NGit.FileTreeEntry">FileTreeEntry</see>
            for the added file.
            </returns>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:NGit.Tree.AddTree(System.String)">
            <summary>Adds a new or existing Tree with the specified name to this tree.</summary>
            <remarks>
            Adds a new or existing Tree with the specified name to this tree.
            Trees are added if necessary as the name may contain '/':s.
            </remarks>
            <param name="name">Name</param>
            <returns>
            a
            <see cref="T:NGit.FileTreeEntry">FileTreeEntry</see>
            for the added tree.
            </returns>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:NGit.Tree.AddTree(System.Byte[],System.Int32)">
            <summary>Adds a new or existing Tree with the specified name to this tree.</summary>
            <remarks>
            Adds a new or existing Tree with the specified name to this tree.
            Trees are added if necessary as the name may contain '/':s.
            </remarks>
            <param name="s">an array containing the name</param>
            <param name="offset">when the name starts in the tree.</param>
            <returns>
            a
            <see cref="T:NGit.FileTreeEntry">FileTreeEntry</see>
            for the added tree.
            </returns>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:NGit.Tree.AddEntry(NGit.TreeEntry)">
            <summary>Add the specified tree entry to this tree.</summary>
            <remarks>Add the specified tree entry to this tree.</remarks>
            <param name="e"></param>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:NGit.Tree.MemberCount">
            <returns>number of members in this tree</returns>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Tree.Members" -->
        <member name="M:NGit.Tree.Exists(System.String,System.Byte)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Tree.ExistsTree(System.String)">
            <param name="path">to the tree.</param>
            <returns>
            true if a tree with the specified path can be found under this
            tree.
            </returns>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:NGit.Tree.ExistsBlob(System.String)">
            <param name="path">of the non-tree entry.</param>
            <returns>
            true if a blob, symlink, or gitlink with the specified name
            can be found under this tree.
            </returns>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:NGit.Tree.FindMember(System.String,System.Byte)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Tree.FindMember(System.Byte[],System.Byte,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Tree.FindBlobMember(System.String)">
            <param name="s">blob name</param>
            <returns>
            a
            <see cref="T:NGit.TreeEntry">TreeEntry</see>
            representing an object with the specified
            relative path.
            </returns>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:NGit.Tree.FindTreeMember(System.String)">
            <param name="s">Tree Name</param>
            <returns>a Tree with the name s or null</returns>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:NGit.Tree.EnsureLoaded">
            <exception cref="T:System.IO.IOException"></exception>
            <exception cref="T:NGit.Errors.MissingObjectException"></exception>
        </member>
        <member name="M:NGit.Tree.ReadTree(System.Byte[])">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Tree.Format">
            <summary>Format this Tree in canonical format.</summary>
            <remarks>Format this Tree in canonical format.</remarks>
            <returns>canonical encoding of the tree object.</returns>
            <exception cref="T:System.IO.IOException">the tree cannot be loaded, or its not in a writable state.
            	</exception>
        </member>
        <member name="T:NGit.RefUpdate">
            <summary>Creates, updates or deletes any reference.</summary>
            <remarks>Creates, updates or deletes any reference.</remarks>
        </member>
        <member name="F:NGit.RefUpdate.newValue">
            <summary>New value the caller wants this ref to have.</summary>
            <remarks>New value the caller wants this ref to have.</remarks>
        </member>
        <member name="F:NGit.RefUpdate.force">
            <summary>Does this specification ask for forced updated (rewind/reset)?</summary>
        </member>
        <member name="F:NGit.RefUpdate.refLogIdent">
            <summary>Identity to record action as within the reflog.</summary>
            <remarks>Identity to record action as within the reflog.</remarks>
        </member>
        <member name="F:NGit.RefUpdate.refLogMessage">
            <summary>Message the caller wants included in the reflog.</summary>
            <remarks>Message the caller wants included in the reflog.</remarks>
        </member>
        <member name="F:NGit.RefUpdate.refLogIncludeResult">
            <summary>
            Should the Result value be appended to
            <see cref="F:NGit.RefUpdate.refLogMessage">refLogMessage</see>
            .
            </summary>
        </member>
        <member name="F:NGit.RefUpdate.oldValue">
            <summary>Old value of the ref, obtained after we lock it.</summary>
            <remarks>Old value of the ref, obtained after we lock it.</remarks>
        </member>
        <member name="F:NGit.RefUpdate.expValue">
            <summary>
            If non-null, the value
            <see cref="F:NGit.RefUpdate.oldValue">oldValue</see>
            must have to continue.
            </summary>
        </member>
        <member name="F:NGit.RefUpdate.result">
            <summary>Result of the update operation.</summary>
            <remarks>Result of the update operation.</remarks>
        </member>
        <member name="F:NGit.RefUpdate.detachingSymbolicRef">
            <summary>
            Is this RefUpdate detaching a symbolic ref?
            We need this info since this.ref will normally be peeled of in case of
            detaching a symbolic ref (HEAD for example).
            </summary>
            <remarks>
            Is this RefUpdate detaching a symbolic ref?
            We need this info since this.ref will normally be peeled of in case of
            detaching a symbolic ref (HEAD for example).
            Without this flag we cannot decide whether the ref has to be updated or
            not in case when it was a symbolic ref and the newValue == oldValue.
            </remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.RefUpdate.#ctor(NGit.Ref)" -->
        <member name="M:NGit.RefUpdate.GetRefDatabase">
            <returns>the reference database this update modifies.</returns>
        </member>
        <member name="M:NGit.RefUpdate.GetRepository">
            <returns>the repository storing the database's objects.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.RefUpdate.TryLock(System.Boolean)" -->
        <member name="M:NGit.RefUpdate.Unlock">
            <summary>
            Releases the lock taken by
            <see cref="M:NGit.RefUpdate.TryLock(System.Boolean)">TryLock(bool)</see>
            if it succeeded.
            </summary>
        </member>
        <member name="M:NGit.RefUpdate.DoUpdate(NGit.RefUpdate.Result)">
            <param name="desiredResult"></param>
            <returns>
            
            <code>result</code>
            </returns>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:NGit.RefUpdate.DoDelete(NGit.RefUpdate.Result)">
            <param name="desiredResult"></param>
            <returns>
            
            <code>result</code>
            </returns>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:NGit.RefUpdate.DoLink(System.String)">
            <param name="target"></param>
            <returns>
            
            <see cref="F:NGit.RefUpdate.Result.NEW">Result.NEW</see>
            on success.
            </returns>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:NGit.RefUpdate.GetName">
            <summary>Get the name of the ref this update will operate on.</summary>
            <remarks>Get the name of the ref this update will operate on.</remarks>
            <returns>name of underlying ref.</returns>
        </member>
        <member name="M:NGit.RefUpdate.GetRef">
            <returns>the reference this update will create or modify.</returns>
        </member>
        <member name="M:NGit.RefUpdate.GetNewObjectId">
            <summary>Get the new value the ref will be (or was) updated to.</summary>
            <remarks>Get the new value the ref will be (or was) updated to.</remarks>
            <returns>new value. Null if the caller has not configured it.</returns>
        </member>
        <member name="M:NGit.RefUpdate.SetDetachingSymbolicRef">
            <summary>Tells this RefUpdate that it is actually detaching a symbolic ref.</summary>
            <remarks>Tells this RefUpdate that it is actually detaching a symbolic ref.</remarks>
        </member>
        <member name="M:NGit.RefUpdate.SetNewObjectId(NGit.AnyObjectId)">
            <summary>Set the new value the ref will update to.</summary>
            <remarks>Set the new value the ref will update to.</remarks>
            <param name="id">the new value.</param>
        </member>
        <member name="M:NGit.RefUpdate.GetExpectedOldObjectId">
            <returns>
            the expected value of the ref after the lock is taken, but before
            update occurs. Null to avoid the compare and swap test. Use
            <see cref="P:NGit.ObjectId.ZeroId">ObjectId.ZeroId()</see>
            to indicate expectation of a
            non-existant ref.
            </returns>
        </member>
        <member name="M:NGit.RefUpdate.SetExpectedOldObjectId(NGit.AnyObjectId)">
            <param name="id">
            the expected value of the ref after the lock is taken, but
            before update occurs. Null to avoid the compare and swap test.
            Use
            <see cref="P:NGit.ObjectId.ZeroId">ObjectId.ZeroId()</see>
            to indicate expectation of a
            non-existant ref.
            </param>
        </member>
        <member name="M:NGit.RefUpdate.IsForceUpdate">
            <summary>Check if this update wants to forcefully change the ref.</summary>
            <remarks>Check if this update wants to forcefully change the ref.</remarks>
            <returns>true if this update should ignore merge tests.</returns>
        </member>
        <member name="M:NGit.RefUpdate.SetForceUpdate(System.Boolean)">
            <summary>Set if this update wants to forcefully change the ref.</summary>
            <remarks>Set if this update wants to forcefully change the ref.</remarks>
            <param name="b">true if this update should ignore merge tests.</param>
        </member>
        <member name="M:NGit.RefUpdate.GetRefLogIdent">
            <returns>identity of the user making the change in the reflog.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.RefUpdate.SetRefLogIdent(NGit.PersonIdent)" -->
        <member name="M:NGit.RefUpdate.GetRefLogMessage">
            <summary>Get the message to include in the reflog.</summary>
            <remarks>Get the message to include in the reflog.</remarks>
            <returns>
            message the caller wants to include in the reflog; null if the
            update should not be logged.
            </returns>
        </member>
        <member name="M:NGit.RefUpdate.IsRefLogIncludingResult">
            <returns>
            
            <code>true</code>
            if the ref log message should show the result.
            </returns>
        </member>
        <member name="M:NGit.RefUpdate.SetRefLogMessage(System.String,System.Boolean)">
            <summary>Set the message to include in the reflog.</summary>
            <remarks>Set the message to include in the reflog.</remarks>
            <param name="msg">
            the message to describe this change. It may be null if
            appendStatus is null in order not to append to the reflog
            </param>
            <param name="appendStatus">
            true if the status of the ref change (fast-forward or
            forced-update) should be appended to the user supplied
            message.
            </param>
        </member>
        <member name="M:NGit.RefUpdate.DisableRefLog">
            <summary>Don't record this update in the ref's associated reflog.</summary>
            <remarks>Don't record this update in the ref's associated reflog.</remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.RefUpdate.GetOldObjectId" -->
        <member name="M:NGit.RefUpdate.SetOldObjectId(NGit.ObjectId)">
            <summary>Set the old value of the ref.</summary>
            <remarks>Set the old value of the ref.</remarks>
            <param name="old">the old value.</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.RefUpdate.GetResult" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.RefUpdate.ForceUpdate" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.RefUpdate.Update" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.RefUpdate.Update(NGit.Revwalk.RevWalk)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.RefUpdate.Delete" -->
        <member name="M:NGit.RefUpdate.Delete(NGit.Revwalk.RevWalk)">
            <summary>Delete the ref.</summary>
            <remarks>Delete the ref.</remarks>
            <param name="walk">
            a RevWalk instance this delete command can borrow to perform
            the merge test. The walk will be reset to perform the test.
            </param>
            <returns>the result status of the delete.</returns>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.RefUpdate.Link(System.String)" -->
        <member name="M:NGit.RefUpdate.UpdateImpl(NGit.Revwalk.RevWalk,NGit.RefUpdate.Store)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.RefUpdate.SafeParse(NGit.Revwalk.RevWalk,NGit.AnyObjectId)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="T:NGit.RefUpdate.Result">
            <summary>Status of an update request.</summary>
            <remarks>Status of an update request.</remarks>
        </member>
        <member name="T:NGit.RefUpdate.Store">
            <summary>Handle the abstraction of storing a ref update.</summary>
            <remarks>
            Handle the abstraction of storing a ref update. This is because both
            updating and deleting of a ref have merge testing in common.
            </remarks>
        </member>
        <member name="M:NGit.RefUpdate.Store.Execute(NGit.RefUpdate.Result)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.RefUpdate._Store_484.Execute(NGit.RefUpdate.Result)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.RefUpdate._Store_540.Execute(NGit.RefUpdate.Result)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="T:NGit.Constants">
            <summary>Misc.</summary>
            <remarks>Misc. constants used throughout JGit.</remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "F:NGit.Constants.OBJECT_ID_LENGTH" -->
        <member name="F:NGit.Constants.OBJECT_ID_STRING_LENGTH">
            <summary>
            A Git object can be expressed as a 40 character string of hexadecimal
            digits.
            </summary>
            <remarks>
            A Git object can be expressed as a 40 character string of hexadecimal
            digits.
            </remarks>
            <seealso cref="F:NGit.Constants.OBJECT_ID_LENGTH">OBJECT_ID_LENGTH</seealso>
        </member>
        <member name="F:NGit.Constants.OBJ_BAD">
            <summary>An unknown or invalid object type code.</summary>
            <remarks>An unknown or invalid object type code.</remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "F:NGit.Constants.OBJ_EXT" -->
        <!-- Badly formed XML comment ignored for member "F:NGit.Constants.OBJ_COMMIT" -->
        <!-- Badly formed XML comment ignored for member "F:NGit.Constants.OBJ_TREE" -->
        <!-- Badly formed XML comment ignored for member "F:NGit.Constants.OBJ_BLOB" -->
        <!-- Badly formed XML comment ignored for member "F:NGit.Constants.OBJ_TAG" -->
        <member name="F:NGit.Constants.OBJ_TYPE_5">
            <summary>In-pack object type: reserved for future use.</summary>
            <remarks>In-pack object type: reserved for future use.</remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "F:NGit.Constants.OBJ_OFS_DELTA" -->
        <!-- Badly formed XML comment ignored for member "F:NGit.Constants.OBJ_REF_DELTA" -->
        <member name="F:NGit.Constants.HASH_FUNCTION">
            <summary>Hash function used natively by Git for all objects.</summary>
            <remarks>Hash function used natively by Git for all objects.</remarks>
        </member>
        <member name="F:NGit.Constants.HEAD">
            <summary>Special name for the "HEAD" symbolic-ref.</summary>
            <remarks>Special name for the "HEAD" symbolic-ref.</remarks>
        </member>
        <member name="F:NGit.Constants.FETCH_HEAD">
            <summary>Special name for the "FETCH_HEAD" symbolic-ref.</summary>
            <remarks>Special name for the "FETCH_HEAD" symbolic-ref.</remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "F:NGit.Constants.TYPE_COMMIT" -->
        <!-- Badly formed XML comment ignored for member "F:NGit.Constants.TYPE_BLOB" -->
        <!-- Badly formed XML comment ignored for member "F:NGit.Constants.TYPE_TREE" -->
        <!-- Badly formed XML comment ignored for member "F:NGit.Constants.TYPE_TAG" -->
        <!-- Badly formed XML comment ignored for member "F:NGit.Constants.PACK_SIGNATURE" -->
        <member name="F:NGit.Constants.CHARACTER_ENCODING">
            <summary>Native character encoding for commit messages, file names...</summary>
            <remarks>Native character encoding for commit messages, file names...</remarks>
        </member>
        <member name="F:NGit.Constants.CHARSET">
            <summary>Native character encoding for commit messages, file names...</summary>
            <remarks>Native character encoding for commit messages, file names...</remarks>
        </member>
        <member name="F:NGit.Constants.MASTER">
            <summary>Default main branch name</summary>
        </member>
        <member name="F:NGit.Constants.STASH">
            <summary>Default stash branch name</summary>
        </member>
        <member name="F:NGit.Constants.R_HEADS">
            <summary>Prefix for branch refs</summary>
        </member>
        <member name="F:NGit.Constants.R_REMOTES">
            <summary>Prefix for remotes refs</summary>
        </member>
        <member name="F:NGit.Constants.R_TAGS">
            <summary>Prefix for tag refs</summary>
        </member>
        <member name="F:NGit.Constants.R_NOTES">
            <summary>Prefix for notes refs</summary>
        </member>
        <member name="F:NGit.Constants.R_NOTES_COMMITS">
            <summary>Standard notes ref</summary>
        </member>
        <member name="F:NGit.Constants.R_REFS">
            <summary>Prefix for any ref</summary>
        </member>
        <member name="F:NGit.Constants.R_STASH">
            <summary>Standard stash ref</summary>
        </member>
        <member name="F:NGit.Constants.LOGS">
            <summary>Logs folder name</summary>
        </member>
        <member name="F:NGit.Constants.INFO_REFS">
            <summary>Info refs folder</summary>
        </member>
        <member name="F:NGit.Constants.PACKED_REFS">
            <summary>Packed refs file</summary>
        </member>
        <member name="F:NGit.Constants.OS_USER_NAME_KEY">
            <summary>The environment variable that contains the system user name</summary>
        </member>
        <member name="F:NGit.Constants.GIT_AUTHOR_NAME_KEY">
            <summary>The environment variable that contains the author's name</summary>
        </member>
        <member name="F:NGit.Constants.GIT_AUTHOR_EMAIL_KEY">
            <summary>The environment variable that contains the author's email</summary>
        </member>
        <member name="F:NGit.Constants.GIT_COMMITTER_NAME_KEY">
            <summary>The environment variable that contains the commiter's name</summary>
        </member>
        <member name="F:NGit.Constants.GIT_COMMITTER_EMAIL_KEY">
            <summary>The environment variable that contains the commiter's email</summary>
        </member>
        <member name="F:NGit.Constants.GIT_CEILING_DIRECTORIES_KEY">
            <summary>
            The environment variable that limits how close to the root of the file
            systems JGit will traverse when looking for a repository root.
            </summary>
            <remarks>
            The environment variable that limits how close to the root of the file
            systems JGit will traverse when looking for a repository root.
            </remarks>
        </member>
        <member name="F:NGit.Constants.GIT_DIR_KEY">
            <summary>
            The environment variable that tells us which directory is the ".git"
            directory
            </summary>
        </member>
        <member name="F:NGit.Constants.GIT_WORK_TREE_KEY">
            <summary>
            The environment variable that tells us which directory is the working
            directory.
            </summary>
            <remarks>
            The environment variable that tells us which directory is the working
            directory.
            </remarks>
        </member>
        <member name="F:NGit.Constants.GIT_INDEX_FILE_KEY">
            <summary>The environment variable that tells us which file holds the Git index.</summary>
            <remarks>The environment variable that tells us which file holds the Git index.</remarks>
        </member>
        <member name="F:NGit.Constants.GIT_OBJECT_DIRECTORY_KEY">
            <summary>The environment variable that tells us where objects are stored</summary>
        </member>
        <member name="F:NGit.Constants.GIT_ALTERNATE_OBJECT_DIRECTORIES_KEY">
            <summary>
            The environment variable that tells us where to look for objects, besides
            the default objects directory.
            </summary>
            <remarks>
            The environment variable that tells us where to look for objects, besides
            the default objects directory.
            </remarks>
        </member>
        <member name="F:NGit.Constants.UNKNOWN_USER_DEFAULT">
            <summary>Default value for the user name if no other information is available</summary>
        </member>
        <member name="F:NGit.Constants.SIGNED_OFF_BY_TAG">
            <summary>Beginning of the common "Signed-off-by: " commit message line</summary>
        </member>
        <member name="F:NGit.Constants.GITIGNORE_FILENAME">
            <summary>A gitignore file name</summary>
        </member>
        <member name="F:NGit.Constants.DEFAULT_REMOTE_NAME">
            <summary>Default remote name used by clone, push and fetch operations</summary>
        </member>
        <member name="F:NGit.Constants.DOT_GIT">
            <summary>Default name for the Git repository directory</summary>
        </member>
        <member name="F:NGit.Constants.CONFIG">
            <summary>Default name for the Git repository configuration</summary>
        </member>
        <member name="F:NGit.Constants.DOT_GIT_EXT">
            <summary>A bare repository typically ends with this string</summary>
        </member>
        <member name="F:NGit.Constants.DOT_GIT_IGNORE">
            <summary>Name of the ignore file</summary>
        </member>
        <member name="F:NGit.Constants.DOT_GIT_MODULES">
            <summary>Name of the submodules file</summary>
        </member>
        <member name="M:NGit.Constants.NewMessageDigest">
            <summary>Create a new digest function for objects.</summary>
            <remarks>Create a new digest function for objects.</remarks>
            <returns>a new digest object.</returns>
            <exception cref="T:Sharpen.RuntimeException">
            this Java virtual machine does not support the required hash
            function. Very unlikely given that JGit uses a hash function
            that is in the Java reference specification.
            </exception>
        </member>
        <member name="M:NGit.Constants.TypeString(System.Int32)">
            <summary>Convert an OBJ_* type constant to a TYPE_* type constant.</summary>
            <remarks>Convert an OBJ_* type constant to a TYPE_* type constant.</remarks>
            <param name="typeCode">the type code, from a pack representation.</param>
            <returns>the canonical string name of this type.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Constants.EncodedTypeString(System.Int32)" -->
        <member name="M:NGit.Constants.DecodeTypeString(NGit.AnyObjectId,System.Byte[],System.Byte,NGit.Util.MutableInteger)">
            <summary>Parse an encoded type string into a type constant.</summary>
            <remarks>Parse an encoded type string into a type constant.</remarks>
            <param name="id">
            object id this type string came from; may be null if that is
            not known at the time the parse is occurring.
            </param>
            <param name="typeString">string version of the type code.</param>
            <param name="endMark">
            character immediately following the type string. Usually ' '
            (space) or '\n' (line feed).
            </param>
            <param name="offset">
            position within <code>typeString</code> where the parse
            should start. Updated with the new position (just past
            <code>endMark</code> when the parse is successful.
            </param>
            <returns>
            a type code constant (one of
            <see cref="F:NGit.Constants.OBJ_BLOB">OBJ_BLOB</see>
            ,
            <see cref="F:NGit.Constants.OBJ_COMMIT">OBJ_COMMIT</see>
            ,
            <see cref="F:NGit.Constants.OBJ_TAG">OBJ_TAG</see>
            ,
            <see cref="F:NGit.Constants.OBJ_TREE">OBJ_TREE</see>
            .
            </returns>
            <exception cref="T:NGit.Errors.CorruptObjectException">there is no valid type identified by <code>typeString</code>.
            	</exception>
        </member>
        <member name="M:NGit.Constants.EncodeASCII(System.Int64)">
            <summary>Convert an integer into its decimal representation.</summary>
            <remarks>Convert an integer into its decimal representation.</remarks>
            <param name="s">the integer to convert.</param>
            <returns>
            a decimal representation of the input integer. The returned array
            is the smallest array that will hold the value.
            </returns>
        </member>
        <member name="M:NGit.Constants.EncodeASCII(System.String)">
            <summary>Convert a string to US-ASCII encoding.</summary>
            <remarks>Convert a string to US-ASCII encoding.</remarks>
            <param name="s">
            the string to convert. Must not contain any characters over
            127 (outside of 7-bit ASCII).
            </param>
            <returns>
            a byte array of the same length as the input string, holding the
            same characters, in the same order.
            </returns>
            <exception cref="T:System.ArgumentException">
            the input string contains one or more characters outside of
            the 7-bit ASCII character space.
            </exception>
        </member>
        <member name="M:NGit.Constants.Encode(System.String)">
            <summary>Convert a string to a byte array in the standard character encoding.</summary>
            <remarks>Convert a string to a byte array in the standard character encoding.</remarks>
            <param name="str">the string to convert. May contain any Unicode characters.</param>
            <returns>
            a byte array representing the requested string, encoded using the
            default character encoding (UTF-8).
            </returns>
            <seealso cref="F:NGit.Constants.CHARACTER_ENCODING">CHARACTER_ENCODING</seealso>
        </member>
        <member name="F:NGit.Constants.MERGE_MSG">
            <summary>name of the file containing the commit msg for a merge commit</summary>
        </member>
        <member name="F:NGit.Constants.MERGE_HEAD">
            <summary>name of the file containing the IDs of the parents of a merge commit</summary>
        </member>
        <member name="F:NGit.Constants.CHERRY_PICK_HEAD">
            <summary>name of the file containing the ID of a cherry pick commit in case of conflicts
            	</summary>
        </member>
        <member name="F:NGit.Constants.SQUASH_MSG">
            <summary>name of the file containing the commit msg for a squash commit</summary>
        </member>
        <member name="F:NGit.Constants.ORIG_HEAD">
            <summary>
            name of the ref ORIG_HEAD used by certain commands to store the original
            value of HEAD
            </summary>
        </member>
        <member name="F:NGit.Constants.EMPTY_BLOB_ID">
            <summary>objectid for the empty blob</summary>
        </member>
        <member name="T:NGit.BlobBasedConfig">
            <summary>Configuration file based on the blobs stored in the repository.</summary>
            <remarks>
            Configuration file based on the blobs stored in the repository.
            This implementation currently only provides reading support, and is primarily
            useful for supporting the
            <code>.gitmodules</code>
            file.
            </remarks>
        </member>
        <member name="M:NGit.BlobBasedConfig.#ctor(NGit.Config,System.Byte[])">
            <summary>Parse a configuration from a byte array.</summary>
            <remarks>Parse a configuration from a byte array.</remarks>
            <param name="base">the base configuration file</param>
            <param name="blob">the byte array, should be UTF-8 encoded text.</param>
            <exception cref="T:NGit.Errors.ConfigInvalidException">the byte array is not a valid configuration format.
            	</exception>
        </member>
        <member name="M:NGit.BlobBasedConfig.#ctor(NGit.Config,NGit.Repository,NGit.AnyObjectId)">
            <summary>Load a configuration file from a blob.</summary>
            <remarks>Load a configuration file from a blob.</remarks>
            <param name="base">the base configuration file</param>
            <param name="db">the repository</param>
            <param name="objectId">the object identifier</param>
            <exception cref="T:System.IO.IOException">the blob cannot be read from the repository.
            	</exception>
            <exception cref="T:NGit.Errors.ConfigInvalidException">the blob is not a valid configuration format.
            	</exception>
        </member>
        <member name="M:NGit.BlobBasedConfig.Read(NGit.Repository,NGit.AnyObjectId)">
            <exception cref="T:NGit.Errors.MissingObjectException"></exception>
            <exception cref="T:NGit.Errors.IncorrectObjectTypeException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.BlobBasedConfig.Read(NGit.ObjectReader,NGit.AnyObjectId)">
            <exception cref="T:NGit.Errors.MissingObjectException"></exception>
            <exception cref="T:NGit.Errors.IncorrectObjectTypeException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.BlobBasedConfig.#ctor(NGit.Config,NGit.Repository,NGit.AnyObjectId,System.String)">
            <summary>Load a configuration file from a blob stored in a specific commit.</summary>
            <remarks>Load a configuration file from a blob stored in a specific commit.</remarks>
            <param name="base">the base configuration file</param>
            <param name="db">the repository containing the objects.</param>
            <param name="treeish">the tree (or commit) that contains the object</param>
            <param name="path">the path within the tree</param>
            <exception cref="T:System.IO.FileNotFoundException">the path does not exist in the commit's tree.
            	</exception>
            <exception cref="T:System.IO.IOException">the tree and/or blob cannot be accessed.</exception>
            <exception cref="T:NGit.Errors.ConfigInvalidException">the blob is not a valid configuration format.
            	</exception>
        </member>
        <member name="M:NGit.BlobBasedConfig.Read(NGit.Repository,NGit.AnyObjectId,System.String)">
            <exception cref="T:NGit.Errors.MissingObjectException"></exception>
            <exception cref="T:NGit.Errors.IncorrectObjectTypeException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.BlobBasedConfig.AsTree(NGit.ObjectReader,NGit.AnyObjectId)">
            <exception cref="T:NGit.Errors.MissingObjectException"></exception>
            <exception cref="T:NGit.Errors.IncorrectObjectTypeException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="T:NGit.Api.Errors.PatchApplyException">
            <summary>Exception thrown when applying a patch fails</summary>
            <since>2.0</since>
        </member>
        <member name="M:NGit.Api.Errors.PatchApplyException.#ctor(System.String,System.Exception)">
            <param name="message"></param>
            <param name="cause"></param>
        </member>
        <member name="M:NGit.Api.Errors.PatchApplyException.#ctor(System.String)">
            <param name="message"></param>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Api.SubmoduleSyncCommand" -->
        <member name="M:NGit.Api.SubmoduleSyncCommand.#ctor(NGit.Repository)">
            <param name="repo"></param>
        </member>
        <member name="M:NGit.Api.SubmoduleSyncCommand.AddPath(System.String)">
            <summary>Add repository-relative submodule path to synchronize</summary>
            <param name="path"></param>
            <returns>this command</returns>
        </member>
        <member name="M:NGit.Api.SubmoduleSyncCommand.GetHeadBranch(NGit.Repository)">
            <summary>Get branch that HEAD currently points to</summary>
            <param name="subRepo"></param>
            <returns>shortened branch name, null on failures</returns>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:NGit.Api.SubmoduleSyncCommand.Call">
            <exception cref="T:NGit.Api.Errors.GitAPIException"></exception>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Api.DiffCommand" -->
        <member name="M:NGit.Api.DiffCommand.#ctor(NGit.Repository)">
            <param name="repo"></param>
        </member>
        <member name="M:NGit.Api.DiffCommand.Call">
            <summary>
            Executes the
            <code>Diff</code>
            command with all the options and parameters
            collected by the setter methods (e.g.
            <see cref="M:NGit.Api.DiffCommand.SetCached(System.Boolean)">SetCached(bool)</see>
            of this
            class. Each instance of this class should only be used for one invocation
            of the command. Don't call this method twice on an instance.
            </summary>
            <returns>a DiffEntry for each path which is different</returns>
            <exception cref="T:NGit.Api.Errors.GitAPIException"></exception>
        </member>
        <member name="M:NGit.Api.DiffCommand.SetCached(System.Boolean)">
            <param name="cached">whether to view the changes you staged for the next commit</param>
            <returns>this instance</returns>
        </member>
        <member name="M:NGit.Api.DiffCommand.SetPathFilter(NGit.Treewalk.Filter.TreeFilter)">
            <param name="pathFilter">parameter, used to limit the diff to the named path</param>
            <returns>this instance</returns>
        </member>
        <member name="M:NGit.Api.DiffCommand.SetOldTree(NGit.Treewalk.AbstractTreeIterator)">
            <param name="oldTree">the previous state</param>
            <returns>this instance</returns>
        </member>
        <member name="M:NGit.Api.DiffCommand.SetNewTree(NGit.Treewalk.AbstractTreeIterator)">
            <param name="newTree">the updated state</param>
            <returns>this instance</returns>
        </member>
        <member name="M:NGit.Api.DiffCommand.SetShowNameAndStatusOnly(System.Boolean)">
            <param name="showNameAndStatusOnly">whether to return only names and status of changed files
            	</param>
            <returns>this instance</returns>
        </member>
        <member name="M:NGit.Api.DiffCommand.SetOutputStream(Sharpen.OutputStream)">
            <param name="out">the stream to write line data</param>
            <returns>this instance</returns>
        </member>
        <member name="M:NGit.Api.DiffCommand.SetContextLines(System.Int32)">
            <summary>Set number of context lines instead of the usual three.</summary>
            <remarks>Set number of context lines instead of the usual three.</remarks>
            <param name="contextLines">the number of context lines</param>
            <returns>this instance</returns>
        </member>
        <member name="M:NGit.Api.DiffCommand.SetSourcePrefix(System.String)">
            <summary>Set the given source prefix instead of "a/".</summary>
            <remarks>Set the given source prefix instead of "a/".</remarks>
            <param name="sourcePrefix">the prefix</param>
            <returns>this instance</returns>
        </member>
        <member name="M:NGit.Api.DiffCommand.SetDestinationPrefix(System.String)">
            <summary>Set the given destination prefix instead of "b/".</summary>
            <remarks>Set the given destination prefix instead of "b/".</remarks>
            <param name="destinationPrefix">the prefix</param>
            <returns>this instance</returns>
        </member>
        <member name="M:NGit.Api.DiffCommand.SetProgressMonitor(NGit.ProgressMonitor)">
            <summary>The progress monitor associated with the diff operation.</summary>
            <remarks>
            The progress monitor associated with the diff operation. By default, this
            is set to <code>NullProgressMonitor</code>
            </remarks>
            <seealso cref="T:NGit.NullProgressMonitor">NGit.NullProgressMonitor</seealso>
            <param name="monitor">a progress monitor</param>
            <returns>this instance</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Blame.Region" -->
        <member name="F:NGit.Blame.Region.next">
            <summary>Next entry in the region linked list.</summary>
            <remarks>Next entry in the region linked list.</remarks>
        </member>
        <member name="F:NGit.Blame.Region.resultStart">
            <summary>First position of this region in the result file blame is computing.</summary>
            <remarks>First position of this region in the result file blame is computing.</remarks>
        </member>
        <member name="F:NGit.Blame.Region.sourceStart">
            <summary>
            First position in the
            <see cref="T:NGit.Blame.Candidate">Candidate</see>
            that owns this Region.
            </summary>
        </member>
        <member name="F:NGit.Blame.Region.length">
            <summary>Length of the region, always &gt;= 1.</summary>
            <remarks>Length of the region, always &gt;= 1.</remarks>
        </member>
        <member name="M:NGit.Blame.Region.Copy(System.Int32)">
            <summary>Copy the entire result region, but at a new source position.</summary>
            <remarks>Copy the entire result region, but at a new source position.</remarks>
            <param name="newSource">the new source position.</param>
            <returns>the same result region, but offset for a new source.</returns>
        </member>
        <member name="M:NGit.Blame.Region.SplitFirst(System.Int32,System.Int32)">
            <summary>Split the region, assigning a new source position to the first half.</summary>
            <remarks>Split the region, assigning a new source position to the first half.</remarks>
            <param name="newSource">the new source position.</param>
            <param name="newLen">length of the new region.</param>
            <returns>the first half of the region, at the new source.</returns>
        </member>
        <member name="M:NGit.Blame.Region.SlideAndShrink(System.Int32)">
            <summary>
            Edit this region to remove the first
            <code>d</code>
            elements.
            </summary>
            <param name="d">number of elements to remove from the start of this region.</param>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Api.ShowNoteCommand" -->
        <member name="M:NGit.Api.ShowNoteCommand.#ctor(NGit.Repository)">
            <param name="repo"></param>
        </member>
        <member name="M:NGit.Api.ShowNoteCommand.Call">
            <exception cref="T:NGit.Api.Errors.GitAPIException"></exception>
        </member>
        <member name="M:NGit.Api.ShowNoteCommand.SetObjectId(NGit.Revwalk.RevObject)">
            <summary>Sets the object id of object you want a note on</summary>
            <param name="id"></param>
            <returns>
            
            <code>this</code>
            </returns>
        </member>
        <member name="M:NGit.Api.ShowNoteCommand.SetNotesRef(System.String)">
            <param name="notesRef">
            the ref to read notes from. Note, the default value of
            <see cref="F:NGit.Constants.R_NOTES_COMMITS">NGit.Constants.R_NOTES_COMMITS</see>
            will be used if nothing is
            set
            </param>
            <returns>
            
            <code>this</code>
            </returns>
            <seealso cref="F:NGit.Constants.R_NOTES_COMMITS">NGit.Constants.R_NOTES_COMMITS</seealso>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Diff.HistogramDiffIndex`1" -->
        <member name="F:NGit.Diff.HistogramDiffIndex`1.table">
            <summary>
            Keyed by
            <see cref="M:NGit.Diff.HistogramDiffIndex`1.Hash(NGit.Diff.HashedSequence{`0},System.Int32)">HistogramDiffIndex&lt;S&gt;.Hash(HashedSequence&lt;S&gt;, int)
            	</see>
            for
            <see cref="F:NGit.Diff.HistogramDiffIndex`1.recs">HistogramDiffIndex&lt;S&gt;.recs</see>
            index.
            </summary>
        </member>
        <member name="F:NGit.Diff.HistogramDiffIndex`1.keyShift">
            <summary>
            Number of low bits to discard from a key to index
            <see cref="F:NGit.Diff.HistogramDiffIndex`1.table">HistogramDiffIndex&lt;S&gt;.table</see>
            .
            </summary>
        </member>
        <member name="F:NGit.Diff.HistogramDiffIndex`1.recs">
            <summary>Describes a unique element in sequence A.</summary>
            <remarks>
            Describes a unique element in sequence A.
            The records in this table are actually 3-tuples of:
            <ul>
            <li>index of next record in this table that has same hash code</li>
            <li>index of first element in this occurrence chain</li>
            <li>occurrence count for this element (length of locs list)</li>
            </ul>
            The occurrence count is capped at
            <see cref="F:NGit.Diff.HistogramDiffIndex`1.MAX_CNT">HistogramDiffIndex&lt;S&gt;.MAX_CNT</see>
            , as the field is only
            a few bits wide. Elements that occur more frequently will have their
            count capped.
            </remarks>
        </member>
        <member name="F:NGit.Diff.HistogramDiffIndex`1.recCnt">
            <summary>
            Number of elements in
            <see cref="F:NGit.Diff.HistogramDiffIndex`1.recs">HistogramDiffIndex&lt;S&gt;.recs</see>
            ; also is the unique element count.
            </summary>
        </member>
        <member name="F:NGit.Diff.HistogramDiffIndex`1.next">
            <summary>
            For
            <code>ptr</code>
            ,
            <code>next[ptr - ptrShift]</code>
            has subsequent index.
            For the sequence element
            <code>ptr</code>
            , the value stored at location
            <code>next[ptr - ptrShift]</code>
            is the next occurrence of the exact same
            element in the sequence.
            Chains always run from the lowest index to the largest index. Therefore
            the array will store
            <code>next[1] = 2</code>
            , but never
            <code>next[2] = 1</code>
            .
            This allows a chain to terminate with
            <code>0</code>
            , as
            <code>0</code>
            would never
            be a valid next element.
            The array is sized to be
            <code>region.getLengthA()</code>
            and element indexes
            are converted to array indexes by subtracting
            <see cref="F:NGit.Diff.HistogramDiffIndex`1.ptrShift">HistogramDiffIndex&lt;S&gt;.ptrShift</see>
            , which is
            just a cached version of
            <code>region.beginA</code>
            .
            </summary>
        </member>
        <member name="F:NGit.Diff.HistogramDiffIndex`1.recIdx">
            <summary>
            For element
            <code>ptr</code>
            in A, index of the record in
            <see cref="F:NGit.Diff.HistogramDiffIndex`1.recs">HistogramDiffIndex&lt;S&gt;.recs</see>
            array.
            The record at
            <code>recs[recIdx[ptr - ptrShift]]</code>
            is the record
            describing all occurrences of the element appearing in sequence A at
            position
            <code>ptr</code>
            . The record is needed to get the occurrence count of
            the element, or to locate all other occurrences of that element within
            sequence A. This index provides constant-time access to the record, and
            avoids needing to scan the hash chain.
            </summary>
        </member>
        <member name="F:NGit.Diff.HistogramDiffIndex`1.ptrShift">
            <summary>
            Value to subtract from element indexes to key
            <see cref="F:NGit.Diff.HistogramDiffIndex`1.next">HistogramDiffIndex&lt;S&gt;.next</see>
            array.
            </summary>
        </member>
        <member name="T:NGit.Util.IO.EolCanonicalizingInputStream">
            <summary>An input stream which canonicalizes EOLs bytes on the fly to '\n'.</summary>
            <remarks>
            An input stream which canonicalizes EOLs bytes on the fly to '\n'.
            Optionally, a binary check on the first 8000 bytes is performed
            and in case of binary files, canonicalization is turned off
            (for the complete file).
            </remarks>
        </member>
        <member name="M:NGit.Util.IO.EolCanonicalizingInputStream.#ctor(Sharpen.InputStream,System.Boolean)">
            <summary>Creates a new InputStream, wrapping the specified stream</summary>
            <param name="in">raw input stream</param>
            <param name="detectBinary">whether binaries should be detected</param>
            <since>2.0</since>
        </member>
        <member name="M:NGit.Util.IO.EolCanonicalizingInputStream.Read">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Util.IO.EolCanonicalizingInputStream.Read(System.Byte[],System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Util.IO.EolCanonicalizingInputStream.Close">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Util.IO.EolCanonicalizingInputStream.FillBuffer">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="T:NGit.Util.FS">
            <summary>Abstraction to support various file system operations not in Java.</summary>
            <remarks>Abstraction to support various file system operations not in Java.</remarks>
        </member>
        <member name="F:NGit.Util.FS.DETECTED">
            <summary>The auto-detected implementation selected for this operating system and JRE.
            	</summary>
            <remarks>The auto-detected implementation selected for this operating system and JRE.
            	</remarks>
        </member>
        <member name="M:NGit.Util.FS.Detect">
            <summary>Auto-detect the appropriate file system abstraction.</summary>
            <remarks>Auto-detect the appropriate file system abstraction.</remarks>
            <returns>detected file system abstraction</returns>
        </member>
        <member name="M:NGit.Util.FS.Detect(System.Nullable{System.Boolean})">
            <summary>
            Auto-detect the appropriate file system abstraction, taking into account
            the presence of a Cygwin installation on the system.
            </summary>
            <remarks>
            Auto-detect the appropriate file system abstraction, taking into account
            the presence of a Cygwin installation on the system. Using jgit in
            combination with Cygwin requires a more elaborate (and possibly slower)
            resolution of file system paths.
            </remarks>
            <param name="cygwinUsed">
            <ul>
            <li><code>Boolean.TRUE</code> to assume that Cygwin is used in
            combination with jgit</li>
            <li><code>Boolean.FALSE</code> to assume that Cygwin is
            <b>not</b> used with jgit</li>
            <li><code>null</code> to auto-detect whether a Cygwin
            installation is present on the system and in this case assume
            that Cygwin is used</li>
            </ul>
            Note: this parameter is only relevant on Windows.
            </param>
            <returns>detected file system abstraction</returns>
        </member>
        <member name="M:NGit.Util.FS.#ctor">
            <summary>Constructs a file system abstraction.</summary>
            <remarks>Constructs a file system abstraction.</remarks>
        </member>
        <member name="M:NGit.Util.FS.#ctor(NGit.Util.FS)">
            <summary>Initialize this FS using another's current settings.</summary>
            <remarks>Initialize this FS using another's current settings.</remarks>
            <param name="src">the source FS to copy from.</param>
        </member>
        <member name="M:NGit.Util.FS.NewInstance">
            <returns>a new instance of the same type of FS.</returns>
        </member>
        <member name="M:NGit.Util.FS.SupportsExecute">
            <summary>Does this operating system and JRE support the execute flag on files?</summary>
            <returns>
            true if this implementation can provide reasonably accurate
            executable bit information; false otherwise.
            </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Util.FS.CanExecute(Sharpen.FilePath)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Util.FS.SetExecute(Sharpen.FilePath,System.Boolean)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Util.FS.Resolve(Sharpen.FilePath,System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Util.FS.UserHome" -->
        <member name="M:NGit.Util.FS.SetUserHome(Sharpen.FilePath)">
            <summary>Set the user's home directory location.</summary>
            <remarks>Set the user's home directory location.</remarks>
            <param name="path">
            the location of the user's preferences; null if there is no
            home directory for the current user.
            </param>
            <returns>
            
            <code>this</code>
            .
            </returns>
        </member>
        <member name="M:NGit.Util.FS.RetryFailedLockFileCommit">
            <summary>Does this file system have problems with atomic renames?</summary>
            <returns>true if the caller should retry a failed rename of a lock file.</returns>
        </member>
        <member name="M:NGit.Util.FS.UserHomeImpl">
            <summary>Determine the user's home directory (location where preferences are).</summary>
            <remarks>Determine the user's home directory (location where preferences are).</remarks>
            <returns>the user's home directory; null if the user does not have one.</returns>
        </member>
        <member name="M:NGit.Util.FS.SearchPath(System.String,System.String[])">
            <summary>Searches the given path to see if it contains one of the given files.</summary>
            <remarks>
            Searches the given path to see if it contains one of the given files.
            Returns the first it finds. Returns null if not found or if path is null.
            </remarks>
            <param name="path">List of paths to search separated by File.pathSeparator</param>
            <param name="lookFor">Files to search for in the given path</param>
            <returns>the first match found, or null</returns>
        </member>
        <member name="M:NGit.Util.FS.ReadPipe(Sharpen.FilePath,System.String[],System.String)">
            <summary>Execute a command and return a single line of output as a String</summary>
            <param name="dir">Working directory for the command</param>
            <param name="command">as component array</param>
            <param name="encoding"></param>
            <returns>the one-line output of the command</returns>
        </member>
        <member name="M:NGit.Util.FS.GitPrefix">
            <returns>the $prefix directory C Git would use.</returns>
        </member>
        <member name="M:NGit.Util.FS.DiscoverGitPrefix">
            <returns>the $prefix directory C Git would use.</returns>
        </member>
        <member name="M:NGit.Util.FS.SetGitPrefix(Sharpen.FilePath)">
            <summary>Set the $prefix directory C Git uses.</summary>
            <remarks>Set the $prefix directory C Git uses.</remarks>
            <param name="path">the directory. Null if C Git is not installed.</param>
            <returns>
            
            <code>this</code>
            </returns>
        </member>
        <member name="M:NGit.Util.FS.RunInShell(System.String,System.String[])">
            <summary>Initialize a ProcesssBuilder to run a command using the system shell.</summary>
            <remarks>Initialize a ProcesssBuilder to run a command using the system shell.</remarks>
            <param name="cmd">
            command to execute. This string should originate from the
            end-user, and thus is platform specific.
            </param>
            <param name="args">
            arguments to pass to command. These should be protected from
            shell evaluation.
            </param>
            <returns>
            a partially completed process builder. Caller should finish
            populating directory, environment, and then start the process.
            </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Treewalk.AbstractTreeIterator" -->
        <member name="F:NGit.Treewalk.AbstractTreeIterator.DEFAULT_PATH_SIZE">
            <summary>
            Default size for the
            <see cref="F:NGit.Treewalk.AbstractTreeIterator.path">path</see>
            buffer.
            </summary>
        </member>
        <member name="F:NGit.Treewalk.AbstractTreeIterator.zeroid">
            <summary>A dummy object id buffer that matches the zero ObjectId.</summary>
            <remarks>A dummy object id buffer that matches the zero ObjectId.</remarks>
        </member>
        <member name="F:NGit.Treewalk.AbstractTreeIterator.parent">
            <summary>Iterator for the parent tree; null if we are the root iterator.</summary>
            <remarks>Iterator for the parent tree; null if we are the root iterator.</remarks>
        </member>
        <member name="F:NGit.Treewalk.AbstractTreeIterator.matches">
            <summary>The iterator this current entry is path equal to.</summary>
            <remarks>The iterator this current entry is path equal to.</remarks>
        </member>
        <member name="F:NGit.Treewalk.AbstractTreeIterator.matchShift">
            <summary>Number of entries we moved forward to force a D/F conflict match.</summary>
            <remarks>Number of entries we moved forward to force a D/F conflict match.</remarks>
            <seealso cref="T:NGit.Treewalk.NameConflictTreeWalk">NameConflictTreeWalk</seealso>
        </member>
        <!-- Badly formed XML comment ignored for member "F:NGit.Treewalk.AbstractTreeIterator.mode" -->
        <!-- Badly formed XML comment ignored for member "F:NGit.Treewalk.AbstractTreeIterator.path" -->
        <!-- Badly formed XML comment ignored for member "F:NGit.Treewalk.AbstractTreeIterator.pathOffset" -->
        <!-- Badly formed XML comment ignored for member "F:NGit.Treewalk.AbstractTreeIterator.pathLen" -->
        <member name="M:NGit.Treewalk.AbstractTreeIterator.#ctor">
            <summary>Create a new iterator with no parent.</summary>
            <remarks>Create a new iterator with no parent.</remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Treewalk.AbstractTreeIterator.#ctor(System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Treewalk.AbstractTreeIterator.#ctor(System.Byte[])" -->
        <member name="M:NGit.Treewalk.AbstractTreeIterator.#ctor(NGit.Treewalk.AbstractTreeIterator)">
            <summary>Create an iterator for a subtree of an existing iterator.</summary>
            <remarks>Create an iterator for a subtree of an existing iterator.</remarks>
            <param name="p">parent tree iterator.</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Treewalk.AbstractTreeIterator.#ctor(NGit.Treewalk.AbstractTreeIterator,System.Byte[],System.Int32)" -->
        <member name="M:NGit.Treewalk.AbstractTreeIterator.GrowPath(System.Int32)">
            <summary>Grow the path buffer larger.</summary>
            <remarks>Grow the path buffer larger.</remarks>
            <param name="len">
            number of live bytes in the path buffer. This many bytes will
            be moved into the larger buffer.
            </param>
        </member>
        <member name="M:NGit.Treewalk.AbstractTreeIterator.EnsurePathCapacity(System.Int32,System.Int32)">
            <summary>
            Ensure that path is capable to hold at least
            <code>capacity</code>
            bytes
            </summary>
            <param name="capacity">the amount of bytes to hold</param>
            <param name="len">the amount of live bytes in path buffer</param>
        </member>
        <member name="M:NGit.Treewalk.AbstractTreeIterator.SetPathCapacity(System.Int32,System.Int32)">
            <summary>Set path buffer capacity to the specified size</summary>
            <param name="capacity">the new size</param>
            <param name="len">the amount of bytes to copy</param>
        </member>
        <member name="M:NGit.Treewalk.AbstractTreeIterator.PathCompare(NGit.Treewalk.AbstractTreeIterator)">
            <summary>Compare the path of this current entry to another iterator's entry.</summary>
            <remarks>Compare the path of this current entry to another iterator's entry.</remarks>
            <param name="p">the other iterator to compare the path against.</param>
            <returns>
            -1 if this entry sorts first; 0 if the entries are equal; 1 if
            p's entry sorts first.
            </returns>
        </member>
        <member name="M:NGit.Treewalk.AbstractTreeIterator.PathCompare(System.Byte[],System.Int32,System.Int32,System.Int32)">
            <summary>Compare the path of this current entry to a raw buffer.</summary>
            <remarks>Compare the path of this current entry to a raw buffer.</remarks>
            <param name="buf">the raw path buffer.</param>
            <param name="pos">position to start reading the raw buffer.</param>
            <param name="end">one past the end of the raw buffer (length is end - pos).</param>
            <param name="mode">the mode of the path.</param>
            <returns>
            -1 if this entry sorts first; 0 if the entries are equal; 1 if
            p's entry sorts first.
            </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Treewalk.AbstractTreeIterator.IdEqual(NGit.Treewalk.AbstractTreeIterator)" -->
        <member name="M:NGit.Treewalk.AbstractTreeIterator.GetEntryObjectId(NGit.MutableObjectId)">
            <summary>Obtain the ObjectId for the current entry.</summary>
            <remarks>Obtain the ObjectId for the current entry.</remarks>
            <param name="out">buffer to copy the object id into.</param>
        </member>
        <member name="M:NGit.Treewalk.AbstractTreeIterator.GetEntryPathBuffer">
            <returns>the internal buffer holding the current path.</returns>
        </member>
        <member name="M:NGit.Treewalk.AbstractTreeIterator.GetEntryPathLength">
            <returns>
            length of the path in
            <see cref="M:NGit.Treewalk.AbstractTreeIterator.GetEntryPathBuffer">GetEntryPathBuffer()</see>
            .
            </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Treewalk.AbstractTreeIterator.GetEntryPathHashCode" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Treewalk.AbstractTreeIterator.CreateSubtreeIterator(NGit.ObjectReader)" -->
        <member name="M:NGit.Treewalk.AbstractTreeIterator.CreateEmptyTreeIterator">
            <summary>Create a new iterator as though the current entry were a subtree.</summary>
            <remarks>Create a new iterator as though the current entry were a subtree.</remarks>
            <returns>a new empty tree iterator.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Treewalk.AbstractTreeIterator.CreateSubtreeIterator(NGit.ObjectReader,NGit.MutableObjectId)" -->
        <member name="M:NGit.Treewalk.AbstractTreeIterator.Reset">
            <summary>Position this iterator on the first entry.</summary>
            <remarks>
            Position this iterator on the first entry.
            The default implementation of this method uses
            <code>back(1)</code>
            until
            <code>first()</code>
            is true. This is most likely not the most efficient
            method of repositioning the iterator to its first entry, so subclasses
            are strongly encouraged to override the method.
            </remarks>
            <exception cref="T:NGit.Errors.CorruptObjectException">the tree is invalid.</exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Treewalk.AbstractTreeIterator.Next(System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Treewalk.AbstractTreeIterator.Back(System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Treewalk.AbstractTreeIterator.Skip" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Treewalk.AbstractTreeIterator.StopWalk" -->
        <member name="M:NGit.Treewalk.AbstractTreeIterator.GetNameOffset">
            <summary>
            JGit internal API for use by
            <see cref="T:NGit.Dircache.DirCacheCheckout">NGit.Dircache.DirCacheCheckout</see>
            </summary>
            <returns>
            start of name component part within
            <see cref="M:NGit.Treewalk.AbstractTreeIterator.GetEntryPathBuffer">GetEntryPathBuffer()</see>
            </returns>
            <since>2.0</since>
        </member>
        <member name="M:NGit.Treewalk.AbstractTreeIterator.GetName(System.Byte[],System.Int32)">
            <summary>
            Get the name component of the current entry path into the provided
            buffer.
            </summary>
            <remarks>
            Get the name component of the current entry path into the provided
            buffer.
            </remarks>
            <param name="buffer">
            the buffer to get the name into, it is assumed that buffer can
            hold the name
            </param>
            <param name="offset">the offset of the name in the buffer</param>
            <seealso cref="P:NGit.Treewalk.AbstractTreeIterator.NameLength">NameLength()</seealso>
        </member>
        <member name="P:NGit.Treewalk.AbstractTreeIterator.HasId">
            <returns>true if the entry has a valid ObjectId.</returns>
        </member>
        <member name="P:NGit.Treewalk.AbstractTreeIterator.EntryObjectId">
            <summary>Get the object id of the current entry.</summary>
            <remarks>Get the object id of the current entry.</remarks>
            <returns>an object id for the current entry.</returns>
        </member>
        <member name="P:NGit.Treewalk.AbstractTreeIterator.EntryFileMode">
            <returns>the file mode of the current entry.</returns>
        </member>
        <member name="P:NGit.Treewalk.AbstractTreeIterator.EntryRawMode">
            <returns>the file mode of the current entry as bits</returns>
        </member>
        <member name="P:NGit.Treewalk.AbstractTreeIterator.EntryPathString">
            <returns>path of the current entry, as a string.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "P:NGit.Treewalk.AbstractTreeIterator.IdBuffer" -->
        <member name="P:NGit.Treewalk.AbstractTreeIterator.IdOffset">
            <summary>
            Get the position within
            <see cref="P:NGit.Treewalk.AbstractTreeIterator.IdBuffer">IdBuffer()</see>
            of this entry's ObjectId.
            </summary>
            <returns>
            offset into the array returned by
            <see cref="P:NGit.Treewalk.AbstractTreeIterator.IdBuffer">IdBuffer()</see>
            where the
            ObjectId must be copied out of.
            </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "P:NGit.Treewalk.AbstractTreeIterator.First" -->
        <!-- Badly formed XML comment ignored for member "P:NGit.Treewalk.AbstractTreeIterator.Eof" -->
        <member name="P:NGit.Treewalk.AbstractTreeIterator.NameLength">
            <returns>the length of the name component of the path for the current entry</returns>
        </member>
        <member name="T:NGit.Storage.Pack.DeltaIndexScanner">
            <summary>
            Supports
            <see cref="T:NGit.Storage.Pack.DeltaIndex">DeltaIndex</see>
            by performing a partial scan of the content.
            </summary>
        </member>
        <member name="T:NGit.Storage.Pack.BinaryDelta">
            <summary>Recreate a stream from a base stream and a GIT pack delta.</summary>
            <remarks>
            Recreate a stream from a base stream and a GIT pack delta.
            <p>
            This entire class is heavily cribbed from <code>patch-delta.c</code> in the
            GIT project. The original delta patching code was written by Nicolas Pitre
            (&lt;nico@cam.org&gt;).
            </p>
            </remarks>
        </member>
        <member name="M:NGit.Storage.Pack.BinaryDelta.GetBaseSize(System.Byte[])">
            <summary>Length of the base object in the delta stream.</summary>
            <remarks>Length of the base object in the delta stream.</remarks>
            <param name="delta">the delta stream, or at least the header of it.</param>
            <returns>the base object's size.</returns>
        </member>
        <member name="M:NGit.Storage.Pack.BinaryDelta.GetResultSize(System.Byte[])">
            <summary>Length of the resulting object in the delta stream.</summary>
            <remarks>Length of the resulting object in the delta stream.</remarks>
            <param name="delta">the delta stream, or at least the header of it.</param>
            <returns>the resulting object's size.</returns>
        </member>
        <member name="M:NGit.Storage.Pack.BinaryDelta.Apply(System.Byte[],System.Byte[])">
            <summary>
            Apply the changes defined by delta to the data in base, yielding a new
            array of bytes.
            </summary>
            <remarks>
            Apply the changes defined by delta to the data in base, yielding a new
            array of bytes.
            </remarks>
            <param name="base">some byte representing an object of some kind.</param>
            <param name="delta">
            a git pack delta defining the transform from one version to
            another.
            </param>
            <returns>patched base</returns>
        </member>
        <member name="M:NGit.Storage.Pack.BinaryDelta.Apply(System.Byte[],System.Byte[],System.Byte[])">
            <summary>
            Apply the changes defined by delta to the data in base, yielding a new
            array of bytes.
            </summary>
            <remarks>
            Apply the changes defined by delta to the data in base, yielding a new
            array of bytes.
            </remarks>
            <param name="base">some byte representing an object of some kind.</param>
            <param name="delta">
            a git pack delta defining the transform from one version to
            another.
            </param>
            <param name="result">
            array to store the result into. If null the result will be
            allocated and returned.
            </param>
            <returns>
            either
            <code>result</code>
            , or the result array allocated.
            </returns>
        </member>
        <member name="M:NGit.Storage.Pack.BinaryDelta.Format(System.Byte[])">
            <summary>Format this delta as a human readable string.</summary>
            <remarks>Format this delta as a human readable string.</remarks>
            <param name="delta">the delta instruction sequence to format.</param>
            <returns>the formatted delta.</returns>
        </member>
        <member name="M:NGit.Storage.Pack.BinaryDelta.Format(System.Byte[],System.Boolean)">
            <summary>Format this delta as a human readable string.</summary>
            <remarks>Format this delta as a human readable string.</remarks>
            <param name="delta">the delta instruction sequence to format.</param>
            <param name="includeHeader">
            true if the header (base size and result size) should be
            included in the formatting.
            </param>
            <returns>the formatted delta.</returns>
        </member>
        <member name="T:NGit.ObjectLoader">
            <summary>Base class for a set of loaders for different representations of Git objects.
            	</summary>
            <remarks>
            Base class for a set of loaders for different representations of Git objects.
            New loaders are constructed for every object.
            </remarks>
        </member>
        <member name="M:NGit.ObjectLoader.GetType">
            <returns>
            Git in pack object type, see
            <see cref="T:NGit.Constants">Constants</see>
            .
            </returns>
        </member>
        <member name="M:NGit.ObjectLoader.GetSize">
            <returns>size of object in bytes</returns>
        </member>
        <member name="M:NGit.ObjectLoader.IsLarge">
            <returns>
            true if this object is too large to obtain as a byte array.
            Objects over a certain threshold should be accessed only by their
            <see cref="M:NGit.ObjectLoader.OpenStream">OpenStream()</see>
            to prevent overflowing the JVM heap.
            </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.ObjectLoader.GetBytes" -->
        <member name="M:NGit.ObjectLoader.GetBytes(System.Int32)">
            <summary>Obtain a copy of the bytes of this object.</summary>
            <remarks>
            Obtain a copy of the bytes of this object.
            If the object size is less than or equal to
            <code>sizeLimit</code>
            this method
            will provide it as a byte array, even if
            <see cref="M:NGit.ObjectLoader.IsLarge">IsLarge()</see>
            is true. This
            utility is useful for application code that absolutely must have the
            object as a single contiguous byte array in memory.
            Unlike
            <see cref="M:NGit.ObjectLoader.GetCachedBytes(System.Int32)">GetCachedBytes(int)</see>
            this method returns an array that
            might be modified by the caller.
            </remarks>
            <param name="sizeLimit">
            maximum number of bytes to return. If the object is larger
            than this limit,
            <see cref="T:NGit.Errors.LargeObjectException">NGit.Errors.LargeObjectException</see>
            will be thrown.
            </param>
            <returns>the bytes of this object.</returns>
            <exception cref="T:NGit.Errors.LargeObjectException">
            if the object is bigger than
            <code>sizeLimit</code>
            , or if
            <see cref="T:System.OutOfMemoryException">System.OutOfMemoryException</see>
            occurs during allocation of the
            result array. Callers should use
            <see cref="M:NGit.ObjectLoader.OpenStream">OpenStream()</see>
            instead to access the contents.
            </exception>
            <exception cref="T:NGit.Errors.MissingObjectException">the object is large, and it no longer exists.
            	</exception>
            <exception cref="T:System.IO.IOException">the object store cannot be accessed.</exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.ObjectLoader.GetCachedBytes" -->
        <member name="M:NGit.ObjectLoader.GetCachedBytes(System.Int32)">
            <summary>Obtain a reference to the (possibly cached) bytes of this object.</summary>
            <remarks>
            Obtain a reference to the (possibly cached) bytes of this object.
            If the object size is less than or equal to
            <code>sizeLimit</code>
            this method
            will provide it as a byte array, even if
            <see cref="M:NGit.ObjectLoader.IsLarge">IsLarge()</see>
            is true. This
            utility is useful for application code that absolutely must have the
            object as a single contiguous byte array in memory.
            This method offers direct access to the internal caches, potentially
            saving on data copies between the internal cache and higher level code.
            Callers who receive this reference <b>must not</b> modify its contents.
            Changes (if made) will affect the cache but not the repository itself.
            </remarks>
            <param name="sizeLimit">
            maximum number of bytes to return. If the object size is
            larger than this limit and
            <see cref="M:NGit.ObjectLoader.IsLarge">IsLarge()</see>
            is true,
            <see cref="T:NGit.Errors.LargeObjectException">NGit.Errors.LargeObjectException</see>
            will be thrown.
            </param>
            <returns>the cached bytes of this object. Do not modify it.</returns>
            <exception cref="T:NGit.Errors.LargeObjectException">
            if the object is bigger than
            <code>sizeLimit</code>
            , or if
            <see cref="T:System.OutOfMemoryException">System.OutOfMemoryException</see>
            occurs during allocation of the
            result array. Callers should use
            <see cref="M:NGit.ObjectLoader.OpenStream">OpenStream()</see>
            instead to access the contents.
            </exception>
            <exception cref="T:NGit.Errors.MissingObjectException">the object is large, and it no longer exists.
            	</exception>
            <exception cref="T:System.IO.IOException">the object store cannot be accessed.</exception>
        </member>
        <member name="M:NGit.ObjectLoader.OpenStream">
            <summary>Obtain an input stream to read this object's data.</summary>
            <remarks>Obtain an input stream to read this object's data.</remarks>
            <returns>
            a stream of this object's data. Caller must close the stream when
            through with it. The returned stream is buffered with a
            reasonable buffer size.
            </returns>
            <exception cref="T:NGit.Errors.MissingObjectException">the object no longer exists.
            	</exception>
            <exception cref="T:System.IO.IOException">the object store cannot be accessed.</exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.ObjectLoader.CopyTo(Sharpen.OutputStream)" -->
        <!-- Badly formed XML comment ignored for member "T:NGit.ObjectLoader.SmallObject" -->
        <member name="M:NGit.ObjectLoader.SmallObject.#ctor(System.Int32,System.Byte[])">
            <summary>Construct a small object loader.</summary>
            <remarks>Construct a small object loader.</remarks>
            <param name="type">type of the object.</param>
            <param name="data">
            the object's data array. This array will be returned as-is
            for the
            <see cref="M:NGit.ObjectLoader.SmallObject.GetCachedBytes">GetCachedBytes()</see>
            method.
            </param>
        </member>
        <member name="M:NGit.Storage.File.LargePackedWholeObject.GetCachedBytes">
            <exception cref="T:NGit.Errors.LargeObjectException"></exception>
        </member>
        <member name="M:NGit.Storage.File.LargePackedWholeObject.OpenStream">
            <exception cref="T:NGit.Errors.MissingObjectException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.LargePackedWholeObject.GetObjectId">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="T:NGit.Revwalk.RevTag">
            <summary>An annotated tag.</summary>
            <remarks>An annotated tag.</remarks>
        </member>
        <member name="T:NGit.Revwalk.RevObject">
            <summary>Base object type accessed during revision walking.</summary>
            <remarks>Base object type accessed during revision walking.</remarks>
        </member>
        <member name="M:NGit.Revwalk.RevObject.ParseHeaders(NGit.Revwalk.RevWalk)">
            <exception cref="T:NGit.Errors.MissingObjectException"></exception>
            <exception cref="T:NGit.Errors.IncorrectObjectTypeException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Revwalk.RevObject.ParseBody(NGit.Revwalk.RevWalk)">
            <exception cref="T:NGit.Errors.MissingObjectException"></exception>
            <exception cref="T:NGit.Errors.IncorrectObjectTypeException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Revwalk.RevObject.Has(NGit.Revwalk.RevFlag)">
            <summary>Test to see if the flag has been set on this object.</summary>
            <remarks>Test to see if the flag has been set on this object.</remarks>
            <param name="flag">the flag to test.</param>
            <returns>true if the flag has been added to this object; false if not.</returns>
        </member>
        <member name="M:NGit.Revwalk.RevObject.HasAny(NGit.Revwalk.RevFlagSet)">
            <summary>Test to see if any flag in the set has been set on this object.</summary>
            <remarks>Test to see if any flag in the set has been set on this object.</remarks>
            <param name="set">the flags to test.</param>
            <returns>
            true if any flag in the set has been added to this object; false
            if not.
            </returns>
        </member>
        <member name="M:NGit.Revwalk.RevObject.HasAll(NGit.Revwalk.RevFlagSet)">
            <summary>Test to see if all flags in the set have been set on this object.</summary>
            <remarks>Test to see if all flags in the set have been set on this object.</remarks>
            <param name="set">the flags to test.</param>
            <returns>
            true if all flags of the set have been added to this object;
            false if some or none have been added.
            </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Revwalk.RevObject.Add(NGit.Revwalk.RevFlag)" -->
        <member name="M:NGit.Revwalk.RevObject.Add(NGit.Revwalk.RevFlagSet)">
            <summary>Add a set of flags to this object.</summary>
            <remarks>Add a set of flags to this object.</remarks>
            <param name="set">the set of flags to mark on this object, for later testing.</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Revwalk.RevObject.Remove(NGit.Revwalk.RevFlag)" -->
        <member name="M:NGit.Revwalk.RevObject.Remove(NGit.Revwalk.RevFlagSet)">
            <summary>Remove a set of flags from this object.</summary>
            <remarks>Remove a set of flags from this object.</remarks>
            <param name="set">the flag to remove from this object.</param>
        </member>
        <member name="M:NGit.Revwalk.RevObject.AppendCoreFlags(System.Text.StringBuilder)">
            <param name="s">buffer to append a debug description of core RevFlags onto.</param>
        </member>
        <member name="P:NGit.Revwalk.RevObject.Type">
            <summary>Get Git object type.</summary>
            <remarks>
            Get Git object type. See
            <see cref="T:NGit.Constants">NGit.Constants</see>
            .
            </remarks>
            <returns>object type</returns>
        </member>
        <member name="P:NGit.Revwalk.RevObject.Id">
            <summary>Get the name of this object.</summary>
            <remarks>Get the name of this object.</remarks>
            <returns>unique hash of this object.</returns>
        </member>
        <member name="M:NGit.Revwalk.RevTag.Parse(System.Byte[])">
            <summary>Parse an annotated tag from its canonical format.</summary>
            <remarks>
            Parse an annotated tag from its canonical format.
            This method constructs a temporary revision pool, parses the tag as
            supplied, and returns it to the caller. Since the tag was built inside of
            a private revision pool its object pointer will be initialized, but will
            not have its headers loaded.
            Applications are discouraged from using this API. Callers usually need
            more than one object. Use
            <see cref="M:NGit.Revwalk.RevWalk.ParseTag(NGit.AnyObjectId)">RevWalk.ParseTag(NGit.AnyObjectId)
            	</see>
            to obtain
            a RevTag from an existing repository.
            </remarks>
            <param name="raw">the canonical formatted tag to be parsed.</param>
            <returns>
            the parsed tag, in an isolated revision pool that is not
            available to the caller.
            </returns>
            <exception cref="T:NGit.Errors.CorruptObjectException">the tag contains a malformed header that cannot be handled.
            	</exception>
        </member>
        <member name="M:NGit.Revwalk.RevTag.Parse(NGit.Revwalk.RevWalk,System.Byte[])">
            <summary>Parse an annotated tag from its canonical format.</summary>
            <remarks>
            Parse an annotated tag from its canonical format.
            This method inserts the tag directly into the caller supplied revision
            pool, making it appear as though the tag exists in the repository, even
            if it doesn't. The repository under the pool is not affected.
            </remarks>
            <param name="rw">
            the revision pool to allocate the tag within. The tag's object
            pointer will be obtained from this pool.
            </param>
            <param name="raw">the canonical formatted tag to be parsed.</param>
            <returns>
            the parsed tag, in an isolated revision pool that is not
            available to the caller.
            </returns>
            <exception cref="T:NGit.Errors.CorruptObjectException">the tag contains a malformed header that cannot be handled.
            	</exception>
        </member>
        <member name="M:NGit.Revwalk.RevTag.#ctor(NGit.AnyObjectId)">
            <summary>Create a new tag reference.</summary>
            <remarks>Create a new tag reference.</remarks>
            <param name="id">object name for the tag.</param>
        </member>
        <member name="M:NGit.Revwalk.RevTag.ParseHeaders(NGit.Revwalk.RevWalk)">
            <exception cref="T:NGit.Errors.MissingObjectException"></exception>
            <exception cref="T:NGit.Errors.IncorrectObjectTypeException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Revwalk.RevTag.ParseBody(NGit.Revwalk.RevWalk)">
            <exception cref="T:NGit.Errors.MissingObjectException"></exception>
            <exception cref="T:NGit.Errors.IncorrectObjectTypeException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Revwalk.RevTag.ParseCanonical(NGit.Revwalk.RevWalk,System.Byte[])">
            <exception cref="T:NGit.Errors.CorruptObjectException"></exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Revwalk.RevTag.GetTaggerIdent" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Revwalk.RevTag.GetFullMessage" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Revwalk.RevTag.GetShortMessage" -->
        <member name="M:NGit.Revwalk.RevTag.GetObject">
            <summary>Get a reference to the object this tag was placed on.</summary>
            <remarks>Get a reference to the object this tag was placed on.</remarks>
            <returns>object this tag refers to.</returns>
        </member>
        <member name="M:NGit.Revwalk.RevTag.GetTagName">
            <summary>Get the name of this tag, from the tag header.</summary>
            <remarks>Get the name of this tag, from the tag header.</remarks>
            <returns>name of the tag, according to the tag header.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Revwalk.MergeBaseGenerator" -->
        <!-- Badly formed XML comment ignored for member "T:NGit.Revwalk.Generator" -->
        <member name="F:NGit.Revwalk.Generator.SORT_COMMIT_TIME_DESC">
            <summary>Commits are sorted by commit date and time, descending.</summary>
            <remarks>Commits are sorted by commit date and time, descending.</remarks>
        </member>
        <member name="F:NGit.Revwalk.Generator.HAS_REWRITE">
            <summary>
            Output may have
            <see cref="F:NGit.Revwalk.RevWalk.REWRITE">RevWalk.REWRITE</see>
            marked on it.
            </summary>
        </member>
        <member name="F:NGit.Revwalk.Generator.NEEDS_REWRITE">
            <summary>
            Output needs
            <see cref="T:NGit.Revwalk.RewriteGenerator">RewriteGenerator</see>
            .
            </summary>
        </member>
        <member name="F:NGit.Revwalk.Generator.SORT_TOPO">
            <summary>Topological ordering is enforced (all children before parents).</summary>
            <remarks>Topological ordering is enforced (all children before parents).</remarks>
        </member>
        <member name="F:NGit.Revwalk.Generator.HAS_UNINTERESTING">
            <summary>
            Output may have
            <see cref="F:NGit.Revwalk.RevWalk.UNINTERESTING">RevWalk.UNINTERESTING</see>
            marked on it.
            </summary>
        </member>
        <member name="M:NGit.Revwalk.Generator.ShareFreeList(NGit.Revwalk.BlockRevQueue)">
            <summary>Connect the supplied queue to this generator's own free list (if any).</summary>
            <remarks>Connect the supplied queue to this generator's own free list (if any).</remarks>
            <param name="q">another FIFO queue that wants to share our queue's free list.</param>
        </member>
        <member name="M:NGit.Revwalk.Generator.OutputType">
            <summary>Obtain flags describing the output behavior of this generator.</summary>
            <remarks>Obtain flags describing the output behavior of this generator.</remarks>
            <returns>
            one or more of the constants declared in this class, describing
            how this generator produces its results.
            </returns>
        </member>
        <member name="M:NGit.Revwalk.Generator.Next">
            <summary>Return the next commit to the application, or the next generator.</summary>
            <remarks>Return the next commit to the application, or the next generator.</remarks>
            <returns>next available commit; null if no more are to be returned.</returns>
            <exception cref="T:NGit.Errors.MissingObjectException">NGit.Errors.MissingObjectException
            	</exception>
            <exception cref="T:NGit.Errors.IncorrectObjectTypeException">NGit.Errors.IncorrectObjectTypeException
            	</exception>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:NGit.Revwalk.MergeBaseGenerator.Next">
            <exception cref="T:NGit.Errors.MissingObjectException"></exception>
            <exception cref="T:NGit.Errors.IncorrectObjectTypeException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Revplot.PlotCommit`1" -->
        <member name="T:NGit.Revwalk.RevCommit">
            <summary>A commit reference to a commit in the DAG.</summary>
            <remarks>A commit reference to a commit in the DAG.</remarks>
        </member>
        <member name="M:NGit.Revwalk.RevCommit.Parse(System.Byte[])">
            <summary>Parse a commit from its canonical format.</summary>
            <remarks>
            Parse a commit from its canonical format.
            This method constructs a temporary revision pool, parses the commit as
            supplied, and returns it to the caller. Since the commit was built inside
            of a private revision pool its parent pointers will be initialized, but
            will not have their headers loaded.
            Applications are discouraged from using this API. Callers usually need
            more than one commit. Use
            <see cref="M:NGit.Revwalk.RevWalk.ParseCommit(NGit.AnyObjectId)">RevWalk.ParseCommit(NGit.AnyObjectId)
            	</see>
            to
            obtain a RevCommit from an existing repository.
            </remarks>
            <param name="raw">the canonical formatted commit to be parsed.</param>
            <returns>
            the parsed commit, in an isolated revision pool that is not
            available to the caller.
            </returns>
        </member>
        <member name="M:NGit.Revwalk.RevCommit.Parse(NGit.Revwalk.RevWalk,System.Byte[])">
            <summary>Parse a commit from its canonical format.</summary>
            <remarks>
            Parse a commit from its canonical format.
            This method inserts the commit directly into the caller supplied revision
            pool, making it appear as though the commit exists in the repository,
            even if it doesn't.  The repository under the pool is not affected.
            </remarks>
            <param name="rw">
            the revision pool to allocate the commit within. The commit's
            tree and parent pointers will be obtained from this pool.
            </param>
            <param name="raw">the canonical formatted commit to be parsed.</param>
            <returns>
            the parsed commit, in an isolated revision pool that is not
            available to the caller.
            </returns>
        </member>
        <member name="M:NGit.Revwalk.RevCommit.#ctor(NGit.AnyObjectId)">
            <summary>Create a new commit reference.</summary>
            <remarks>Create a new commit reference.</remarks>
            <param name="id">object name for the commit.</param>
        </member>
        <member name="M:NGit.Revwalk.RevCommit.ParseHeaders(NGit.Revwalk.RevWalk)">
            <exception cref="T:NGit.Errors.MissingObjectException"></exception>
            <exception cref="T:NGit.Errors.IncorrectObjectTypeException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Revwalk.RevCommit.ParseBody(NGit.Revwalk.RevWalk)">
            <exception cref="T:NGit.Errors.MissingObjectException"></exception>
            <exception cref="T:NGit.Errors.IncorrectObjectTypeException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Revwalk.RevCommit.Carry(NGit.Revwalk.RevFlag)" -->
        <member name="M:NGit.Revwalk.RevCommit.GetParent(System.Int32)">
            <summary>Get the nth parent from this commit's parent list.</summary>
            <remarks>Get the nth parent from this commit's parent list.</remarks>
            <param name="nth">
            parent index to obtain. Must be in the range 0 through
            <see cref="P:NGit.Revwalk.RevCommit.ParentCount">ParentCount()</see>
            -1.
            </param>
            <returns>the specified parent.</returns>
            <exception cref="T:System.IndexOutOfRangeException">an invalid parent index was specified.
            	</exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Revwalk.RevCommit.GetAuthorIdent" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Revwalk.RevCommit.GetCommitterIdent" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Revwalk.RevCommit.GetFullMessage" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Revwalk.RevCommit.GetShortMessage" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Revwalk.RevCommit.GetFooterLines" -->
        <member name="M:NGit.Revwalk.RevCommit.GetFooterLines(System.String)">
            <summary>Get the values of all footer lines with the given key.</summary>
            <remarks>Get the values of all footer lines with the given key.</remarks>
            <param name="keyName">footer key to find values of, case insensitive.</param>
            <returns>
            values of footers with key of
            <code>keyName</code>
            , ordered by their
            order of appearance. Duplicates may be returned if the same
            footer appeared more than once. Empty list if no footers appear
            with the specified key, or there are no footers at all.
            </returns>
            <seealso cref="M:NGit.Revwalk.RevCommit.GetFooterLines">GetFooterLines()</seealso>
        </member>
        <member name="M:NGit.Revwalk.RevCommit.GetFooterLines(NGit.Revwalk.FooterKey)">
            <summary>Get the values of all footer lines with the given key.</summary>
            <remarks>Get the values of all footer lines with the given key.</remarks>
            <param name="keyName">footer key to find values of, case insensitive.</param>
            <returns>
            values of footers with key of
            <code>keyName</code>
            , ordered by their
            order of appearance. Duplicates may be returned if the same
            footer appeared more than once. Empty list if no footers appear
            with the specified key, or there are no footers at all.
            </returns>
            <seealso cref="M:NGit.Revwalk.RevCommit.GetFooterLines">GetFooterLines()</seealso>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Revwalk.RevCommit.Reset" -->
        <member name="P:NGit.Revwalk.RevCommit.CommitTime">
            <summary>Time from the "committer " line of the buffer.</summary>
            <remarks>Time from the "committer " line of the buffer.</remarks>
            <returns>time, expressed as seconds since the epoch.</returns>
        </member>
        <member name="P:NGit.Revwalk.RevCommit.Tree">
            <summary>Get a reference to this commit's tree.</summary>
            <remarks>Get a reference to this commit's tree.</remarks>
            <returns>tree of this commit.</returns>
        </member>
        <member name="P:NGit.Revwalk.RevCommit.ParentCount">
            <summary>Get the number of parent commits listed in this commit.</summary>
            <remarks>Get the number of parent commits listed in this commit.</remarks>
            <returns>number of parents; always a positive value but can be 0.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "P:NGit.Revwalk.RevCommit.Parents" -->
        <!-- Badly formed XML comment ignored for member "P:NGit.Revwalk.RevCommit.RawBuffer" -->
        <!-- Badly formed XML comment ignored for member "P:NGit.Revwalk.RevCommit.Encoding" -->
        <member name="M:NGit.Revplot.PlotCommit`1.#ctor(NGit.AnyObjectId)">
            <summary>Create a new commit.</summary>
            <remarks>Create a new commit.</remarks>
            <param name="id">the identity of this commit.</param>
        </member>
        <member name="M:NGit.Revplot.PlotCommit`1.GetChildCount">
            <summary>Get the number of child commits listed in this commit.</summary>
            <remarks>Get the number of child commits listed in this commit.</remarks>
            <returns>number of children; always a positive value but can be 0.</returns>
        </member>
        <member name="M:NGit.Revplot.PlotCommit`1.GetChild(System.Int32)">
            <summary>Get the nth child from this commit's child list.</summary>
            <remarks>Get the nth child from this commit's child list.</remarks>
            <param name="nth">
            child index to obtain. Must be in the range 0 through
            <see cref="M:NGit.Revplot.PlotCommit`1.GetChildCount">PlotCommit&lt;L&gt;.GetChildCount()</see>
            -1.
            </param>
            <returns>the specified child.</returns>
            <exception cref="T:System.IndexOutOfRangeException">an invalid child index was specified.
            	</exception>
        </member>
        <member name="M:NGit.Revplot.PlotCommit`1.IsChild(NGit.Revplot.PlotCommit)">
            <summary>Determine if the given commit is a child (descendant) of this commit.</summary>
            <remarks>Determine if the given commit is a child (descendant) of this commit.</remarks>
            <param name="c">the commit to test.</param>
            <returns>true if the given commit built on top of this commit.</returns>
        </member>
        <member name="M:NGit.Revplot.PlotCommit`1.GetRefCount">
            <summary>Get the number of refs for this commit.</summary>
            <remarks>Get the number of refs for this commit.</remarks>
            <returns>number of refs; always a positive value but can be 0.</returns>
        </member>
        <member name="M:NGit.Revplot.PlotCommit`1.GetRef(System.Int32)">
            <summary>Get the nth Ref from this commit's ref list.</summary>
            <remarks>Get the nth Ref from this commit's ref list.</remarks>
            <param name="nth">
            ref index to obtain. Must be in the range 0 through
            <see cref="M:NGit.Revplot.PlotCommit`1.GetRefCount">PlotCommit&lt;L&gt;.GetRefCount()</see>
            -1.
            </param>
            <returns>the specified ref.</returns>
            <exception cref="T:System.IndexOutOfRangeException">an invalid ref index was specified.
            	</exception>
        </member>
        <member name="M:NGit.Revplot.PlotCommit`1.GetLane">
            <summary>Obtain the lane this commit has been plotted into.</summary>
            <remarks>Obtain the lane this commit has been plotted into.</remarks>
            <returns>the assigned lane for this commit.</returns>
        </member>
        <member name="T:NGit.Patch.FormatError">
            <summary>An error in a patch script</summary>
        </member>
        <member name="M:NGit.Patch.FormatError.GetSeverity">
            <returns>the severity of the error.</returns>
        </member>
        <member name="M:NGit.Patch.FormatError.GetMessage">
            <returns>a message describing the error.</returns>
        </member>
        <member name="M:NGit.Patch.FormatError.GetBuffer">
            <returns>the byte buffer holding the patch script.</returns>
        </member>
        <member name="M:NGit.Patch.FormatError.GetOffset">
            <returns>
            byte offset within
            <see cref="M:NGit.Patch.FormatError.GetBuffer">GetBuffer()</see>
            where the error is
            </returns>
        </member>
        <member name="M:NGit.Patch.FormatError.GetLineText">
            <returns>line of the patch script the error appears on.</returns>
        </member>
        <member name="T:NGit.Patch.FormatError.Severity">
            <summary>Classification of an error.</summary>
            <remarks>Classification of an error.</remarks>
        </member>
        <member name="T:NGit.Merge.ResolveMerger">
            <summary>A three-way merger performing a content-merge if necessary</summary>
        </member>
        <member name="T:NGit.Merge.ThreeWayMerger">
            <summary>A merge of 2 trees, using a common base ancestor tree.</summary>
            <remarks>A merge of 2 trees, using a common base ancestor tree.</remarks>
        </member>
        <member name="M:NGit.Merge.ThreeWayMerger.#ctor(NGit.Repository)">
            <summary>Create a new merge instance for a repository.</summary>
            <remarks>Create a new merge instance for a repository.</remarks>
            <param name="local">the repository this merger will read and write data on.</param>
        </member>
        <member name="M:NGit.Merge.ThreeWayMerger.#ctor(NGit.Repository,System.Boolean)">
            <summary>Create a new merge instance for a repository.</summary>
            <remarks>Create a new merge instance for a repository.</remarks>
            <param name="local">the repository this merger will read and write data on.</param>
            <param name="inCore">perform the merge in core with no working folder involved</param>
        </member>
        <member name="M:NGit.Merge.ThreeWayMerger.SetBase(NGit.AnyObjectId)">
            <summary>Set the common ancestor tree.</summary>
            <remarks>Set the common ancestor tree.</remarks>
            <param name="id">
            common base treeish; null to automatically compute the common
            base from the input commits during
            <see cref="M:NGit.Merge.ThreeWayMerger.Merge(NGit.AnyObjectId[])">Merge(NGit.AnyObjectId[])</see>
            .
            </param>
            <exception cref="T:NGit.Errors.IncorrectObjectTypeException">the object is not a treeish.
            	</exception>
            <exception cref="T:NGit.Errors.MissingObjectException">the object does not exist.</exception>
            <exception cref="T:System.IO.IOException">the object could not be read.</exception>
        </member>
        <member name="M:NGit.Merge.ThreeWayMerger.Merge(NGit.AnyObjectId[])">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Merge.ThreeWayMerger.MergeBase">
            <summary>Create an iterator to walk the merge base.</summary>
            <remarks>Create an iterator to walk the merge base.</remarks>
            <returns>
            an iterator over the caller-specified merge base, or the natural
            merge base of the two input commits.
            </returns>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:NGit.Merge.ResolveMerger.#ctor(NGit.Repository,System.Boolean)">
            <param name="local"></param>
            <param name="inCore"></param>
        </member>
        <member name="M:NGit.Merge.ResolveMerger.#ctor(NGit.Repository)">
            <param name="local"></param>
        </member>
        <member name="M:NGit.Merge.ResolveMerger.MergeImpl">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Merge.ResolveMerger.Checkout">
            <exception cref="T:NGit.Errors.NoWorkTreeException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Merge.ResolveMerger.CreateDir(Sharpen.FilePath)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Merge.ResolveMerger.CleanUp">
            <summary>Reverts the worktree after an unsuccessful merge.</summary>
            <remarks>
            Reverts the worktree after an unsuccessful merge. We know that for all
            modified files the old content was in the old index and the index
            contained only stage 0. In case if inCore operation just clear
            the history of modified files.
            </remarks>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
            <exception cref="T:NGit.Errors.CorruptObjectException">NGit.Errors.CorruptObjectException
            	</exception>
            <exception cref="T:NGit.Errors.NoWorkTreeException">NGit.Errors.NoWorkTreeException
            	</exception>
        </member>
        <member name="M:NGit.Merge.ResolveMerger.Add(System.Byte[],NGit.Treewalk.CanonicalTreeParser,System.Int32)">
            <summary>adds a new path with the specified stage to the index builder</summary>
            <param name="path"></param>
            <param name="p"></param>
            <param name="stage"></param>
            <returns>the entry which was added to the index</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Merge.ResolveMerger.ProcessEntry(NGit.Treewalk.CanonicalTreeParser,NGit.Treewalk.CanonicalTreeParser,NGit.Treewalk.CanonicalTreeParser,NGit.Dircache.DirCacheBuildIterator,NGit.Treewalk.WorkingTreeIterator)" -->
        <member name="M:NGit.Merge.ResolveMerger.ContentMerge(NGit.Treewalk.CanonicalTreeParser,NGit.Treewalk.CanonicalTreeParser,NGit.Treewalk.CanonicalTreeParser)">
            <summary>Does the content merge.</summary>
            <remarks>
            Does the content merge. The three texts base, ours and theirs are
            specified with
            <see cref="T:NGit.Treewalk.CanonicalTreeParser">NGit.Treewalk.CanonicalTreeParser</see>
            . If any of the parsers is
            specified as <code>null</code> then an empty text will be used instead.
            </remarks>
            <param name="base"></param>
            <param name="ours"></param>
            <param name="theirs"></param>
            <returns>the result of the content merge</returns>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:NGit.Merge.ResolveMerger.UpdateIndex(NGit.Treewalk.CanonicalTreeParser,NGit.Treewalk.CanonicalTreeParser,NGit.Treewalk.CanonicalTreeParser,NGit.Merge.MergeResult{NGit.Diff.RawText},Sharpen.FilePath)">
            <summary>Updates the index after a content merge has happened.</summary>
            <remarks>
            Updates the index after a content merge has happened. If no conflict has
            occurred this includes persisting the merged content to the object
            database. In case of conflicts this method takes care to write the
            correct stages to the index.
            </remarks>
            <param name="base"></param>
            <param name="ours"></param>
            <param name="theirs"></param>
            <param name="result"></param>
            <param name="of"></param>
            <exception cref="T:System.IO.FileNotFoundException">System.IO.FileNotFoundException
            	</exception>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:NGit.Merge.ResolveMerger.WriteMergedFile(NGit.Merge.MergeResult{NGit.Diff.RawText})">
            <summary>Writes merged file content to the working tree.</summary>
            <remarks>
            Writes merged file content to the working tree. In case
            <see cref="F:NGit.Merge.ResolveMerger.inCore">inCore</see>
            is set and we don't have a working tree the content is written to a
            temporary file
            </remarks>
            <param name="result">the result of the content merge</param>
            <returns>the file to which the merged content was written</returns>
            <exception cref="T:System.IO.FileNotFoundException">System.IO.FileNotFoundException
            	</exception>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:NGit.Merge.ResolveMerger.MergeFileModes(System.Int32,System.Int32,System.Int32)">
            <summary>Try to merge filemodes.</summary>
            <remarks>
            Try to merge filemodes. If only ours or theirs have changed the mode
            (compared to base) we choose that one. If ours and theirs have equal
            modes return that one. If also that is not the case the modes are not
            mergeable. Return
            <see cref="F:NGit.FileMode.MISSING">NGit.FileMode.MISSING</see>
            int that case.
            </remarks>
            <param name="modeB">filemode found in BASE</param>
            <param name="modeO">filemode found in OURS</param>
            <param name="modeT">filemode found in THEIRS</param>
            <returns>
            the merged filemode or
            <see cref="F:NGit.FileMode.MISSING">NGit.FileMode.MISSING</see>
            in case of a
            conflict
            </returns>
        </member>
        <member name="M:NGit.Merge.ResolveMerger.GetRawText(NGit.ObjectId,NGit.Repository)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Merge.ResolveMerger.SetCommitNames(System.String[])">
            <param name="commitNames">
            the names of the commits as they would appear in conflict
            markers
            </param>
        </member>
        <member name="M:NGit.Merge.ResolveMerger.GetCommitNames">
            <returns>
            the names of the commits as they would appear in conflict
            markers.
            </returns>
        </member>
        <member name="M:NGit.Merge.ResolveMerger.GetUnmergedPaths">
            <returns>
            the paths with conflicts. This is a subset of the files listed
            by
            <see cref="M:NGit.Merge.ResolveMerger.GetModifiedFiles">GetModifiedFiles()</see>
            </returns>
        </member>
        <member name="M:NGit.Merge.ResolveMerger.GetModifiedFiles">
            <returns>
            the paths of files which have been modified by this merge. A
            file will be modified if a content-merge works on this path or if
            the merge algorithm decides to take the theirs-version. This is a
            superset of the files listed by
            <see cref="M:NGit.Merge.ResolveMerger.GetUnmergedPaths">GetUnmergedPaths()</see>
            .
            </returns>
        </member>
        <member name="M:NGit.Merge.ResolveMerger.GetToBeCheckedOut">
            <returns>
            a map which maps the paths of files which have to be checked out
            because the merge created new fully-merged content for this file
            into the index. This means: the merge wrote a new stage 0 entry
            for this path.
            </returns>
        </member>
        <member name="M:NGit.Merge.ResolveMerger.GetMergeResults">
            <returns>the mergeResults</returns>
        </member>
        <member name="M:NGit.Merge.ResolveMerger.GetFailingPaths">
            <returns>
            lists paths causing this merge to fail (not stopped because of a
            conflict). <code>null</code> is returned if this merge didn't
            fail.
            </returns>
        </member>
        <member name="M:NGit.Merge.ResolveMerger.Failed">
            <summary>Returns whether this merge failed (i.e.</summary>
            <remarks>
            Returns whether this merge failed (i.e. not stopped because of a
            conflict)
            </remarks>
            <returns>
            <code>true</code> if a failure occurred, <code>false</code>
            otherwise
            </returns>
        </member>
        <member name="M:NGit.Merge.ResolveMerger.SetDirCache(NGit.Dircache.DirCache)">
            <summary>Sets the DirCache which shall be used by this merger.</summary>
            <remarks>
            Sets the DirCache which shall be used by this merger. If the DirCache is
            not set explicitly this merger will implicitly get and lock a default
            DirCache. If the DirCache is explicitly set the caller is responsible to
            lock it in advance. Finally the merger will call
            <see cref="M:NGit.Dircache.DirCache.Commit">NGit.Dircache.DirCache.Commit()</see>
            which requires that the DirCache is locked. If
            the
            <see cref="M:NGit.Merge.ResolveMerger.MergeImpl">MergeImpl()</see>
            returns without throwing an exception the lock
            will be released. In case of exceptions the caller is responsible to
            release the lock.
            </remarks>
            <param name="dc">the DirCache to set</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Merge.ResolveMerger.SetWorkingTreeIterator(NGit.Treewalk.WorkingTreeIterator)" -->
        <member name="T:NGit.Merge.ResolveMerger.MergeFailureReason">
            <summary>
            If the merge fails (means: not stopped because of unresolved conflicts)
            this enum is used to explain why it failed
            </summary>
        </member>
        <member name="T:NGit.Merge.MergeChunk">
            <summary>One chunk from a merge result.</summary>
            <remarks>
            One chunk from a merge result. Each chunk contains a range from a
            single sequence. In case of conflicts multiple chunks are reported for one
            conflict. The conflictState tells when conflicts start and end.
            </remarks>
        </member>
        <member name="M:NGit.Merge.MergeChunk.#ctor(System.Int32,System.Int32,System.Int32,NGit.Merge.MergeChunk.ConflictState)">
            <summary>Creates a new empty MergeChunk</summary>
            <param name="sequenceIndex">
            determines to which sequence this chunks belongs to. Same as
            in
            <see cref="M:NGit.Merge.MergeResult`1.Add(System.Int32,System.Int32,System.Int32,NGit.Merge.MergeChunk.ConflictState)">MergeResult&lt;S&gt;.Add(int, int, int, ConflictState)
            	</see>
            </param>
            <param name="begin">
            the first element from the specified sequence which should be
            included in the merge result. Indexes start with 0.
            </param>
            <param name="end">
            specifies the end of the range to be added. The element this
            index points to is the first element which not added to the
            merge result. All elements between begin (including begin) and
            this element are added.
            </param>
            <param name="conflictState">
            the state of this chunk. See
            <see cref="T:NGit.Merge.MergeChunk.ConflictState">ConflictState</see>
            </param>
        </member>
        <member name="M:NGit.Merge.MergeChunk.GetSequenceIndex">
            <returns>
            the index of the sequence to which sequence this chunks belongs
            to. Same as in
            <see cref="M:NGit.Merge.MergeResult`1.Add(System.Int32,System.Int32,System.Int32,NGit.Merge.MergeChunk.ConflictState)">MergeResult&lt;S&gt;.Add(int, int, int, ConflictState)
            	</see>
            </returns>
        </member>
        <member name="M:NGit.Merge.MergeChunk.GetBegin">
            <returns>
            the first element from the specified sequence which should be
            included in the merge result. Indexes start with 0.
            </returns>
        </member>
        <member name="M:NGit.Merge.MergeChunk.GetEnd">
            <returns>
            the end of the range of this chunk. The element this index
            points to is the first element which not added to the merge
            result. All elements between begin (including begin) and this
            element are added.
            </returns>
        </member>
        <member name="M:NGit.Merge.MergeChunk.GetConflictState">
            <returns>
            the state of this chunk. See
            <see cref="T:NGit.Merge.MergeChunk.ConflictState">ConflictState</see>
            </returns>
        </member>
        <member name="T:NGit.Merge.MergeChunk.ConflictState">
            <summary>A state telling whether a MergeChunk belongs to a conflict or not.</summary>
            <remarks>
            A state telling whether a MergeChunk belongs to a conflict or not. The
            first chunk of a conflict is reported with a special state to be able to
            distinguish the border between two consecutive conflicts
            </remarks>
        </member>
        <member name="M:NGit.Fnmatch.Head.GetNextHeads(System.Char)">
            <param name="c">the character which decides which heads are returned.</param>
            <returns>a list of heads based on the input.</returns>
        </member>
        <member name="M:NGit.Fnmatch.AbstractHead.SetNewHeads(System.Collections.Generic.IList{NGit.Fnmatch.Head})">
            <param name="newHeads">
            a list of
            <see cref="T:NGit.Fnmatch.Head">Head</see>
            s which will not be modified.
            </param>
        </member>
        <member name="T:NGit.Events.ConfigChangedEvent">
            <summary>Describes a change to one or more keys in the configuration.</summary>
            <remarks>Describes a change to one or more keys in the configuration.</remarks>
        </member>
        <member name="T:NGit.Errors.RevisionSyntaxException">
            <summary>
            This signals a revision or object reference was not
            properly formatted.
            </summary>
            <remarks>
            This signals a revision or object reference was not
            properly formatted.
            </remarks>
        </member>
        <member name="M:NGit.Errors.RevisionSyntaxException.#ctor(System.String)">
            <summary>
            Construct a RevisionSyntaxException indicating a syntax problem with a
            revision (or object) string.
            </summary>
            <remarks>
            Construct a RevisionSyntaxException indicating a syntax problem with a
            revision (or object) string.
            </remarks>
            <param name="revstr">The problematic revision string</param>
        </member>
        <member name="M:NGit.Errors.RevisionSyntaxException.#ctor(System.String,System.String)">
            <summary>
            Construct a RevisionSyntaxException indicating a syntax problem with a
            revision (or object) string.
            </summary>
            <remarks>
            Construct a RevisionSyntaxException indicating a syntax problem with a
            revision (or object) string.
            </remarks>
            <param name="message">a specific reason</param>
            <param name="revstr">The problematic revision string</param>
        </member>
        <member name="T:NGit.Errors.AmbiguousObjectException">
            <summary>
            An
            <see cref="T:NGit.AbbreviatedObjectId">NGit.AbbreviatedObjectId</see>
            cannot be extended.
            </summary>
        </member>
        <member name="M:NGit.Errors.AmbiguousObjectException.#ctor(NGit.AbbreviatedObjectId,System.Collections.Generic.ICollection{NGit.ObjectId})">
            <summary>Construct a MissingObjectException for the specified object id.</summary>
            <remarks>
            Construct a MissingObjectException for the specified object id. Expected
            type is reported to simplify tracking down the problem.
            </remarks>
            <param name="id">SHA-1</param>
            <param name="candidates">the candidate matches returned by the ObjectReader.</param>
        </member>
        <member name="M:NGit.Errors.AmbiguousObjectException.GetAbbreviatedObjectId">
            <returns>the AbbreviatedObjectId that has more than one result.</returns>
        </member>
        <member name="M:NGit.Errors.AmbiguousObjectException.GetCandidates">
            <returns>the matching candidates (or at least a subset of them).</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Dircache.DirCacheEditor" -->
        <!-- Badly formed XML comment ignored for member "T:NGit.Dircache.BaseDirCacheEditor" -->
        <member name="F:NGit.Dircache.BaseDirCacheEditor.cache">
            <summary>
            The cache instance this editor updates during
            <see cref="M:NGit.Dircache.BaseDirCacheEditor.Finish">Finish()</see>
            .
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:NGit.Dircache.BaseDirCacheEditor.entries" -->
        <member name="F:NGit.Dircache.BaseDirCacheEditor.entryCnt">
            <summary>
            Total number of valid entries in
            <see cref="F:NGit.Dircache.BaseDirCacheEditor.entries">entries</see>
            .
            </summary>
        </member>
        <member name="M:NGit.Dircache.BaseDirCacheEditor.#ctor(NGit.Dircache.DirCache,System.Int32)">
            <summary>Construct a new editor.</summary>
            <remarks>Construct a new editor.</remarks>
            <param name="dc">the cache this editor will eventually update.</param>
            <param name="ecnt">
            estimated number of entries the editor will have upon
            completion. This sizes the initial entry table.
            </param>
        </member>
        <member name="M:NGit.Dircache.BaseDirCacheEditor.GetDirCache">
            <returns>
            the cache we will update on
            <see cref="M:NGit.Dircache.BaseDirCacheEditor.Finish">Finish()</see>
            .
            </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Dircache.BaseDirCacheEditor.FastAdd(NGit.Dircache.DirCacheEntry)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Dircache.BaseDirCacheEditor.FastKeep(System.Int32,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Dircache.BaseDirCacheEditor.Finish" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Dircache.BaseDirCacheEditor.Replace" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Dircache.BaseDirCacheEditor.Commit" -->
        <member name="M:NGit.Dircache.DirCacheEditor.#ctor(NGit.Dircache.DirCache,System.Int32)">
            <summary>Construct a new editor.</summary>
            <remarks>Construct a new editor.</remarks>
            <param name="dc">the cache this editor will eventually update.</param>
            <param name="ecnt">
            estimated number of entries the editor will have upon
            completion. This sizes the initial entry table.
            </param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Dircache.DirCacheEditor.Add(NGit.Dircache.DirCacheEditor.PathEdit)" -->
        <member name="M:NGit.Dircache.DirCacheEditor.Commit">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Dircache.DirCacheEditor.PathEdit" -->
        <member name="M:NGit.Dircache.DirCacheEditor.PathEdit.#ctor(System.String)">
            <summary>Create a new update command by path name.</summary>
            <remarks>Create a new update command by path name.</remarks>
            <param name="entryPath">path of the file within the repository.</param>
        </member>
        <member name="M:NGit.Dircache.DirCacheEditor.PathEdit.#ctor(NGit.Dircache.DirCacheEntry)">
            <summary>Create a new update command for an existing entry instance.</summary>
            <remarks>Create a new update command for an existing entry instance.</remarks>
            <param name="ent">
            entry instance to match path of. Only the path of this
            entry is actually considered during command evaluation.
            </param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Dircache.DirCacheEditor.PathEdit.Apply(NGit.Dircache.DirCacheEntry)" -->
        <!-- Badly formed XML comment ignored for member "T:NGit.Dircache.DirCacheEditor.DeletePath" -->
        <member name="M:NGit.Dircache.DirCacheEditor.DeletePath.#ctor(System.String)">
            <summary>Create a new deletion command by path name.</summary>
            <remarks>Create a new deletion command by path name.</remarks>
            <param name="entryPath">path of the file within the repository.</param>
        </member>
        <member name="M:NGit.Dircache.DirCacheEditor.DeletePath.#ctor(NGit.Dircache.DirCacheEntry)">
            <summary>Create a new deletion command for an existing entry instance.</summary>
            <remarks>Create a new deletion command for an existing entry instance.</remarks>
            <param name="ent">
            entry instance to remove. Only the path of this entry is
            actually considered during command evaluation.
            </param>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Dircache.DirCacheEditor.DeleteTree" -->
        <member name="M:NGit.Dircache.DirCacheEditor.DeleteTree.#ctor(System.String)">
            <summary>Create a new tree deletion command by path name.</summary>
            <remarks>Create a new tree deletion command by path name.</remarks>
            <param name="entryPath">
            path of the subtree within the repository. If the path
            does not end with "/" a "/" is implicitly added to ensure
            only the subtree's contents are matched by the command.
            The special case "" (not "/"!) deletes all entries.
            </param>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Api.Errors.JGitInternalException" -->
        <member name="M:NGit.Api.Errors.JGitInternalException.#ctor(System.String,System.Exception)">
            <param name="message"></param>
            <param name="cause"></param>
        </member>
        <member name="M:NGit.Api.Errors.JGitInternalException.#ctor(System.String)">
            <param name="message"></param>
        </member>
        <member name="T:NGit.UserConfig">
            <summary>The standard "user" configuration parameters.</summary>
            <remarks>The standard "user" configuration parameters.</remarks>
        </member>
        <member name="F:NGit.UserConfig.KEY">
            <summary>
            Key for
            <see cref="!:Config.Get&lt;T&gt;(SectionParser&lt;T&gt;)">Config.Get&lt;T&gt;(SectionParser&lt;T&gt;)
            	</see>
            .
            </summary>
        </member>
        <member name="M:NGit.UserConfig.GetAuthorName">
            <returns>
            the author name as defined in the git variables and
            configurations. If no name could be found, try to use the system
            user name instead.
            </returns>
        </member>
        <member name="M:NGit.UserConfig.GetCommitterName">
            <returns>
            the committer name as defined in the git variables and
            configurations. If no name could be found, try to use the system
            user name instead.
            </returns>
        </member>
        <member name="M:NGit.UserConfig.GetAuthorEmail">
            <returns>
            the author email as defined in git variables and
            configurations. If no email could be found, try to
            propose one default with the user name and the
            host name.
            </returns>
        </member>
        <member name="M:NGit.UserConfig.GetCommitterEmail">
            <returns>
            the committer email as defined in git variables and
            configurations. If no email could be found, try to
            propose one default with the user name and the
            host name.
            </returns>
        </member>
        <member name="M:NGit.UserConfig.IsAuthorNameImplicit">
            <returns>
            true if the author name was not explicitly configured but
            constructed from information the system has about the logged on
            user
            </returns>
        </member>
        <member name="M:NGit.UserConfig.IsAuthorEmailImplicit">
            <returns>
            true if the author email was not explicitly configured but
            constructed from information the system has about the logged on
            user
            </returns>
        </member>
        <member name="M:NGit.UserConfig.IsCommitterNameImplicit">
            <returns>
            true if the committer name was not explicitly configured but
            constructed from information the system has about the logged on
            user
            </returns>
        </member>
        <member name="M:NGit.UserConfig.IsCommitterEmailImplicit">
            <returns>
            true if the author email was not explicitly configured but
            constructed from information the system has about the logged on
            user
            </returns>
        </member>
        <member name="M:NGit.UserConfig.GetDefaultUserName">
            <returns>
            try to get user name of the logged on user from the operating
            system
            </returns>
        </member>
        <member name="M:NGit.UserConfig.GetDefaultEmail">
            <returns>
            try to construct email for logged on user using system
            information
            </returns>
        </member>
        <member name="T:NGit.ProgressMonitor">
            <summary>A progress reporting interface.</summary>
            <remarks>A progress reporting interface.</remarks>
        </member>
        <member name="F:NGit.ProgressMonitor.UNKNOWN">
            <summary>Constant indicating the total work units cannot be predicted.</summary>
            <remarks>Constant indicating the total work units cannot be predicted.</remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.ProgressMonitor.Start(System.Int32)" -->
        <member name="M:NGit.ProgressMonitor.BeginTask(System.String,System.Int32)">
            <summary>Begin processing a single task.</summary>
            <remarks>Begin processing a single task.</remarks>
            <param name="title">
            title to describe the task. Callers should publish these as
            stable string constants that implementations could match
            against for translation support.
            </param>
            <param name="totalWork">
            total number of work units the application will perform;
            <see cref="F:NGit.ProgressMonitor.UNKNOWN">UNKNOWN</see>
            if it cannot be predicted in advance.
            </param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.ProgressMonitor.Update(System.Int32)" -->
        <member name="M:NGit.ProgressMonitor.EndTask">
            <summary>Finish the current task, so the next can begin.</summary>
            <remarks>Finish the current task, so the next can begin.</remarks>
        </member>
        <member name="M:NGit.ProgressMonitor.IsCancelled">
            <summary>Check for user task cancellation.</summary>
            <remarks>Check for user task cancellation.</remarks>
            <returns>true if the user asked the process to stop working.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.ObjectInserter" -->
        <member name="F:NGit.ObjectInserter.digest">
            <summary>Digest to compute the name of an object.</summary>
            <remarks>Digest to compute the name of an object.</remarks>
        </member>
        <member name="F:NGit.ObjectInserter.tempBuffer">
            <summary>Temporary working buffer for streaming data through.</summary>
            <remarks>Temporary working buffer for streaming data through.</remarks>
        </member>
        <member name="M:NGit.ObjectInserter.#ctor">
            <summary>Create a new inserter for a database.</summary>
            <remarks>Create a new inserter for a database.</remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.ObjectInserter.Buffer" -->
        <member name="M:NGit.ObjectInserter.Digest">
            <returns>digest to help compute an ObjectId</returns>
        </member>
        <member name="M:NGit.ObjectInserter.IdFor(System.Int32,System.Byte[])">
            <summary>Compute the name of an object, without inserting it.</summary>
            <remarks>Compute the name of an object, without inserting it.</remarks>
            <param name="type">type code of the object to store.</param>
            <param name="data">complete content of the object.</param>
            <returns>the name of the object.</returns>
        </member>
        <member name="M:NGit.ObjectInserter.IdFor(System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>Compute the name of an object, without inserting it.</summary>
            <remarks>Compute the name of an object, without inserting it.</remarks>
            <param name="type">type code of the object to store.</param>
            <param name="data">complete content of the object.</param>
            <param name="off">
            first position within
            <code>data</code>
            .
            </param>
            <param name="len">
            number of bytes to copy from
            <code>data</code>
            .
            </param>
            <returns>the name of the object.</returns>
        </member>
        <member name="M:NGit.ObjectInserter.IdFor(System.Int32,System.Int64,Sharpen.InputStream)">
            <summary>Compute the name of an object, without inserting it.</summary>
            <remarks>Compute the name of an object, without inserting it.</remarks>
            <param name="objectType">type code of the object to store.</param>
            <param name="length">
            number of bytes to scan from
            <code>in</code>
            .
            </param>
            <param name="in">
            stream providing the object content. The caller is responsible
            for closing the stream.
            </param>
            <returns>the name of the object.</returns>
            <exception cref="T:System.IO.IOException">the source stream could not be read.</exception>
        </member>
        <member name="M:NGit.ObjectInserter.IdFor(NGit.TreeFormatter)">
            <summary>Compute the ObjectId for the given tree without inserting it.</summary>
            <remarks>Compute the ObjectId for the given tree without inserting it.</remarks>
            <param name="formatter"></param>
            <returns>the computed ObjectId</returns>
        </member>
        <member name="M:NGit.ObjectInserter.Insert(NGit.TreeFormatter)">
            <summary>Insert a single tree into the store, returning its unique name.</summary>
            <remarks>Insert a single tree into the store, returning its unique name.</remarks>
            <param name="formatter">the formatter containing the proposed tree's data.</param>
            <returns>the name of the tree object.</returns>
            <exception cref="T:System.IO.IOException">the object could not be stored.</exception>
        </member>
        <member name="M:NGit.ObjectInserter.Insert(NGit.CommitBuilder)">
            <summary>Insert a single commit into the store, returning its unique name.</summary>
            <remarks>Insert a single commit into the store, returning its unique name.</remarks>
            <param name="builder">the builder containing the proposed commit's data.</param>
            <returns>the name of the commit object.</returns>
            <exception cref="T:System.IO.IOException">the object could not be stored.</exception>
        </member>
        <member name="M:NGit.ObjectInserter.Insert(NGit.TagBuilder)">
            <summary>Insert a single annotated tag into the store, returning its unique name.
            	</summary>
            <remarks>Insert a single annotated tag into the store, returning its unique name.
            	</remarks>
            <param name="builder">the builder containing the proposed tag's data.</param>
            <returns>the name of the tag object.</returns>
            <exception cref="T:System.IO.IOException">the object could not be stored.</exception>
        </member>
        <member name="M:NGit.ObjectInserter.Insert(System.Int32,System.Byte[])">
            <summary>Insert a single object into the store, returning its unique name.</summary>
            <remarks>Insert a single object into the store, returning its unique name.</remarks>
            <param name="type">type code of the object to store.</param>
            <param name="data">complete content of the object.</param>
            <returns>the name of the object.</returns>
            <exception cref="T:System.IO.IOException">the object could not be stored.</exception>
        </member>
        <member name="M:NGit.ObjectInserter.Insert(System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>Insert a single object into the store, returning its unique name.</summary>
            <remarks>Insert a single object into the store, returning its unique name.</remarks>
            <param name="type">type code of the object to store.</param>
            <param name="data">complete content of the object.</param>
            <param name="off">
            first position within
            <code>data</code>
            .
            </param>
            <param name="len">
            number of bytes to copy from
            <code>data</code>
            .
            </param>
            <returns>the name of the object.</returns>
            <exception cref="T:System.IO.IOException">the object could not be stored.</exception>
        </member>
        <member name="M:NGit.ObjectInserter.Insert(System.Int32,System.Int64,Sharpen.InputStream)">
            <summary>Insert a single object into the store, returning its unique name.</summary>
            <remarks>Insert a single object into the store, returning its unique name.</remarks>
            <param name="objectType">type code of the object to store.</param>
            <param name="length">
            number of bytes to copy from
            <code>in</code>
            .
            </param>
            <param name="in">
            stream providing the object content. The caller is responsible
            for closing the stream.
            </param>
            <returns>the name of the object.</returns>
            <exception cref="T:System.IO.IOException">
            the object could not be stored, or the source stream could
            not be read.
            </exception>
        </member>
        <member name="M:NGit.ObjectInserter.NewPackParser(Sharpen.InputStream)">
            <summary>Initialize a parser to read from a pack formatted stream.</summary>
            <remarks>Initialize a parser to read from a pack formatted stream.</remarks>
            <param name="in">
            the input stream. The stream is not closed by the parser, and
            must instead be closed by the caller once parsing is complete.
            </param>
            <returns>the pack parser.</returns>
            <exception cref="T:System.IO.IOException">
            the parser instance, which can be configured and then used to
            parse objects into the ObjectDatabase.
            </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.ObjectInserter.Flush" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.ObjectInserter.Release" -->
        <member name="T:NGit.ObjectInserter.Formatter">
            <summary>An inserter that can be used for formatting and id generation only.</summary>
            <remarks>An inserter that can be used for formatting and id generation only.</remarks>
        </member>
        <member name="M:NGit.ObjectInserter.Formatter.Insert(System.Int32,System.Int64,Sharpen.InputStream)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.ObjectInserter.Formatter.NewPackParser(Sharpen.InputStream)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.ObjectInserter.Formatter.Flush">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="T:NGit.ObjectInserter.Filter">
            <summary>Wraps a delegate ObjectInserter.</summary>
            <remarks>Wraps a delegate ObjectInserter.</remarks>
        </member>
        <member name="M:NGit.ObjectInserter.Filter.Delegate">
            <returns>delegate ObjectInserter to handle all processing.</returns>
        </member>
        <member name="M:NGit.ObjectInserter.Filter.IdFor(System.Int32,System.Int64,Sharpen.InputStream)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.ObjectInserter.Filter.Insert(System.Int32,System.Byte[])">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.ObjectInserter.Filter.Insert(System.Int32,System.Byte[],System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.ObjectInserter.Filter.Insert(System.Int32,System.Int64,Sharpen.InputStream)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.ObjectInserter.Filter.NewPackParser(Sharpen.InputStream)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.ObjectInserter.Filter.Flush">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="T:NGit.GitlinkTreeEntry">
            <summary>A tree entry representing a gitlink entry used for submodules.</summary>
            <remarks>
            A tree entry representing a gitlink entry used for submodules.
            Note. Java cannot really handle these as file system objects.
            </remarks>
        </member>
        <member name="M:NGit.GitlinkTreeEntry.#ctor(NGit.Tree,NGit.ObjectId,System.Byte[])">
            <summary>
            Construct a
            <see cref="T:NGit.GitlinkTreeEntry">GitlinkTreeEntry</see>
            with the specified name and SHA-1 in
            the specified parent
            </summary>
            <param name="parent"></param>
            <param name="id"></param>
            <param name="nameUTF8"></param>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.AsyncObjectSizeQueue`1" -->
        <member name="T:NGit.AsyncOperation">
            <summary>Asynchronous operation handle.</summary>
            <remarks>
            Asynchronous operation handle.
            Callers that start an asynchronous operation are supplied with a handle that
            may be used to attempt cancellation of the operation if the caller does not
            wish to continue.
            </remarks>
        </member>
        <member name="M:NGit.AsyncOperation.Cancel(System.Boolean)">
            <summary>Cancels the running task.</summary>
            <remarks>
            Cancels the running task.
            Attempts to cancel execution of this task. This attempt will fail if the
            task has already completed, already been cancelled, or could not be
            cancelled for some other reason. If successful, and this task has not
            started when cancel is called, this task should never run. If the task
            has already started, then the mayInterruptIfRunning parameter determines
            whether the thread executing this task should be interrupted in an
            attempt to stop the task.
            </remarks>
            <param name="mayInterruptIfRunning">
            true if the thread executing this task should be interrupted;
            otherwise, in-progress tasks are allowed to complete
            </param>
            <returns>
            false if the task could not be cancelled, typically because it
            has already completed normally; true otherwise
            </returns>
        </member>
        <member name="M:NGit.AsyncOperation.Release">
            <summary>Release resources used by the operation, including cancellation.</summary>
            <remarks>Release resources used by the operation, including cancellation.</remarks>
        </member>
        <member name="M:NGit.AsyncObjectSizeQueue`1.Next">
            <summary>Position this queue onto the next available result.</summary>
            <remarks>Position this queue onto the next available result.</remarks>
            <returns>
            true if there is a result available; false if the queue has
            finished its input iteration.
            </returns>
            <exception cref="T:NGit.Errors.MissingObjectException">
            the object does not exist. If the implementation is retaining
            the application's objects
            <see cref="M:NGit.AsyncObjectSizeQueue`1.GetCurrent">AsyncObjectSizeQueue&lt;T&gt;.GetCurrent()
            	</see>
            will be the
            current object that is missing. There may be more results
            still available, so the caller should continue invoking next
            to examine another result.
            </exception>
            <exception cref="T:System.IO.IOException">the object store cannot be accessed.</exception>
        </member>
        <member name="M:NGit.AsyncObjectSizeQueue`1.GetCurrent">
            <returns>
            the current object, null if the implementation lost track.
            Implementations may for performance reasons discard the caller's
            ObjectId and provider their own through
            <see cref="M:NGit.AsyncObjectSizeQueue`1.GetObjectId">AsyncObjectSizeQueue&lt;T&gt;.GetObjectId()
            	</see>
            .
            </returns>
        </member>
        <member name="M:NGit.AsyncObjectSizeQueue`1.GetObjectId">
            <returns>the ObjectId of the current object. Never null.</returns>
        </member>
        <member name="M:NGit.AsyncObjectSizeQueue`1.GetSize">
            <returns>the size of the current object.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Merge.SquashMessageFormatter" -->
        <member name="M:NGit.Merge.SquashMessageFormatter.#ctor">
            <summary>Create a new squash message formatter.</summary>
            <remarks>Create a new squash message formatter.</remarks>
        </member>
        <member name="M:NGit.Merge.SquashMessageFormatter.Format(System.Collections.Generic.IList{NGit.Revwalk.RevCommit},NGit.Ref)">
            <summary>Construct the squashed commit message.</summary>
            <remarks>Construct the squashed commit message.</remarks>
            <param name="squashedCommits">the squashed commits</param>
            <param name="target">the target branch</param>
            <returns>squashed commit message</returns>
        </member>
        <member name="T:NGit.Api.Errors.TransportException">
            <summary>Exception thrown when transport operation failed</summary>
        </member>
        <member name="M:NGit.Api.Errors.TransportException.#ctor(System.String)">
            <param name="msg">message describing the transport failure.</param>
        </member>
        <member name="M:NGit.Api.Errors.TransportException.#ctor(System.String,System.Exception)">
            <param name="msg">message describing the transport exception.</param>
            <param name="cause">why the transport failed.</param>
        </member>
        <member name="M:NGit.Transport.WalkEncryption.Encrypt(Sharpen.OutputStream)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Transport.WalkEncryption.Decrypt(Sharpen.InputStream)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Transport.WalkEncryption.Validate(Sharpen.HttpURLConnection,System.String)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Transport.WalkEncryption.ValidateImpl(Sharpen.HttpURLConnection,System.String,System.String,System.String)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Transport.WalkEncryption.NoEncryption.Validate(Sharpen.HttpURLConnection,System.String)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="T:NGit.Revwalk.Filter.SkipRevFilter">
            <summary>Filter that includes commits after a configured number are skipped.</summary>
            <remarks>Filter that includes commits after a configured number are skipped.</remarks>
        </member>
        <member name="M:NGit.Revwalk.Filter.SkipRevFilter.Create(System.Int32)">
            <summary>Create a new skip filter.</summary>
            <remarks>Create a new skip filter.</remarks>
            <param name="skip">the number of commits to skip</param>
            <returns>a new filter</returns>
        </member>
        <member name="M:NGit.Revwalk.Filter.SkipRevFilter.Include(NGit.Revwalk.RevWalk,NGit.Revwalk.RevCommit)">
            <exception cref="T:NGit.Errors.StopWalkException"></exception>
            <exception cref="T:NGit.Errors.MissingObjectException"></exception>
            <exception cref="T:NGit.Errors.IncorrectObjectTypeException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="T:NGit.Revwalk.RevWalkUtils">
            <summary>
            Utility methods for
            <see cref="T:NGit.Revwalk.RevWalk">RevWalk</see>
            .
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Revwalk.RevWalkUtils.Count(NGit.Revwalk.RevWalk,NGit.Revwalk.RevCommit,NGit.Revwalk.RevCommit)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Revwalk.RevWalkUtils.Find(NGit.Revwalk.RevWalk,NGit.Revwalk.RevCommit,NGit.Revwalk.RevCommit)" -->
        <!-- Badly formed XML comment ignored for member "T:NGit.Blame.BlameGenerator" -->
        <member name="F:NGit.Blame.BlameGenerator.revPool">
            <summary>Revision pool used to acquire commits from.</summary>
            <remarks>Revision pool used to acquire commits from.</remarks>
        </member>
        <member name="F:NGit.Blame.BlameGenerator.SEEN">
            <summary>Indicates the commit has already been processed.</summary>
            <remarks>Indicates the commit has already been processed.</remarks>
        </member>
        <member name="F:NGit.Blame.BlameGenerator.queue">
            <summary>Potential candidates, sorted by commit time descending.</summary>
            <remarks>Potential candidates, sorted by commit time descending.</remarks>
        </member>
        <member name="F:NGit.Blame.BlameGenerator.remaining">
            <summary>Number of lines that still need to be discovered.</summary>
            <remarks>Number of lines that still need to be discovered.</remarks>
        </member>
        <member name="F:NGit.Blame.BlameGenerator.currentSource">
            <summary>Blame is currently assigned to this source.</summary>
            <remarks>Blame is currently assigned to this source.</remarks>
        </member>
        <member name="M:NGit.Blame.BlameGenerator.#ctor(NGit.Repository,System.String)">
            <summary>Create a blame generator for the repository and path</summary>
            <param name="repository">repository to access revision data from.</param>
            <param name="path">initial path of the file to start scanning.</param>
        </member>
        <member name="M:NGit.Blame.BlameGenerator.GetRepository">
            <returns>repository being scanned for revision history.</returns>
        </member>
        <member name="M:NGit.Blame.BlameGenerator.GetResultPath">
            <returns>path file path being processed.</returns>
        </member>
        <member name="M:NGit.Blame.BlameGenerator.SetDiffAlgorithm(NGit.Diff.DiffAlgorithm)">
            <summary>Difference algorithm to use when comparing revisions.</summary>
            <remarks>Difference algorithm to use when comparing revisions.</remarks>
            <param name="algorithm"></param>
            <returns>
            
            <code>this</code>
            </returns>
        </member>
        <member name="M:NGit.Blame.BlameGenerator.SetTextComparator(NGit.Diff.RawTextComparator)">
            <summary>Text comparator to use when comparing revisions.</summary>
            <remarks>Text comparator to use when comparing revisions.</remarks>
            <param name="comparator"></param>
            <returns>
            
            <code>this</code>
            </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Blame.BlameGenerator.SetFollowFileRenames(System.Boolean)" -->
        <member name="M:NGit.Blame.BlameGenerator.GetRenameDetector">
            <summary>
            Obtain the RenameDetector if
            <code>setFollowFileRenames(true)</code>
            .
            </summary>
            <returns>
            the rename detector, allowing the application to configure its
            settings for rename score and breaking behavior.
            </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Blame.BlameGenerator.Push(System.String,System.Byte[])" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Blame.BlameGenerator.Push(System.String,NGit.Diff.RawText)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Blame.BlameGenerator.Push(System.String,NGit.AnyObjectId)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Blame.BlameGenerator.Reverse(NGit.AnyObjectId,NGit.AnyObjectId)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Blame.BlameGenerator.Reverse``1(NGit.AnyObjectId,System.Collections.Generic.ICollection{``0})" -->
        <member name="M:NGit.Blame.BlameGenerator.ComputeBlameResult">
            <summary>Execute the generator in a blocking fashion until all data is ready.</summary>
            <remarks>Execute the generator in a blocking fashion until all data is ready.</remarks>
            <returns>the complete result. Null if no file exists for the given path.</returns>
            <exception cref="T:System.IO.IOException">the repository cannot be read.</exception>
        </member>
        <member name="M:NGit.Blame.BlameGenerator.Next">
            <summary>Step the blame algorithm one iteration.</summary>
            <remarks>Step the blame algorithm one iteration.</remarks>
            <returns>
            true if the generator has found a region's source. The getSource
            and
            <see cref="M:NGit.Blame.BlameGenerator.GetResultStart">GetResultStart()</see>
            ,
            <see cref="M:NGit.Blame.BlameGenerator.GetResultEnd">GetResultEnd()</see>
            methods
            can be used to inspect the region found. False if there are no
            more regions to describe.
            </returns>
            <exception cref="T:System.IO.IOException">repository cannot be read.</exception>
        </member>
        <member name="M:NGit.Blame.BlameGenerator.Result(NGit.Blame.Candidate)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Blame.BlameGenerator.ReverseResult(NGit.Blame.Candidate,NGit.Blame.Candidate)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Blame.BlameGenerator.ProcessOne(NGit.Blame.Candidate)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Blame.BlameGenerator.Split(NGit.Blame.Candidate,NGit.Blame.Candidate)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Blame.BlameGenerator.ProcessMerge(NGit.Blame.Candidate)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Blame.BlameGenerator.GetSourceCommit" -->
        <member name="M:NGit.Blame.BlameGenerator.GetSourceAuthor">
            <returns>current author being blamed.</returns>
        </member>
        <member name="M:NGit.Blame.BlameGenerator.GetSourceCommitter">
            <returns>current committer being blamed.</returns>
        </member>
        <member name="M:NGit.Blame.BlameGenerator.GetSourcePath">
            <returns>path of the file being blamed.</returns>
        </member>
        <member name="M:NGit.Blame.BlameGenerator.GetRenameScore">
            <returns>
            rename score if a rename occurred in
            <see cref="M:NGit.Blame.BlameGenerator.GetSourceCommit">GetSourceCommit()</see>
            .
            </returns>
        </member>
        <member name="M:NGit.Blame.BlameGenerator.GetSourceStart">
            <returns>
            first line of the source data that has been blamed for the
            current region. This is line number of where the region was added
            during
            <see cref="M:NGit.Blame.BlameGenerator.GetSourceCommit">GetSourceCommit()</see>
            in file
            <see cref="M:NGit.Blame.BlameGenerator.GetSourcePath">GetSourcePath()</see>
            .
            </returns>
        </member>
        <member name="M:NGit.Blame.BlameGenerator.GetSourceEnd">
            <returns>
            one past the range of the source data that has been blamed for
            the current region. This is line number of where the region was
            added during
            <see cref="M:NGit.Blame.BlameGenerator.GetSourceCommit">GetSourceCommit()</see>
            in file
            <see cref="M:NGit.Blame.BlameGenerator.GetSourcePath">GetSourcePath()</see>
            .
            </returns>
        </member>
        <member name="M:NGit.Blame.BlameGenerator.GetResultStart">
            <returns>
            first line of the result that
            <see cref="M:NGit.Blame.BlameGenerator.GetSourceCommit">GetSourceCommit()</see>
            has been
            blamed for providing. Line numbers use 0 based indexing.
            </returns>
        </member>
        <member name="M:NGit.Blame.BlameGenerator.GetResultEnd">
            <returns>
            one past the range of the result that
            <see cref="M:NGit.Blame.BlameGenerator.GetSourceCommit">GetSourceCommit()</see>
            has been blamed for providing. Line numbers use 0 based indexing.
            Because a source cannot be blamed for an empty region of the
            result,
            <see cref="M:NGit.Blame.BlameGenerator.GetResultEnd">GetResultEnd()</see>
            is always at least one larger
            than
            <see cref="M:NGit.Blame.BlameGenerator.GetResultStart">GetResultStart()</see>
            .
            </returns>
        </member>
        <member name="M:NGit.Blame.BlameGenerator.GetRegionLength">
            <returns>
            number of lines in the current region being blamed to
            <see cref="M:NGit.Blame.BlameGenerator.GetSourceCommit">GetSourceCommit()</see>
            . This is always the value of the
            expression
            <code>getResultEnd() - getResultStart()</code>
            , but also
            <code>getSourceEnd() - getSourceStart()</code>
            .
            </returns>
        </member>
        <member name="M:NGit.Blame.BlameGenerator.GetSourceContents">
            <returns>
            complete contents of the source file blamed for the current
            output region. This is the contents of
            <see cref="M:NGit.Blame.BlameGenerator.GetSourcePath">GetSourcePath()</see>
            within
            <see cref="M:NGit.Blame.BlameGenerator.GetSourceCommit">GetSourceCommit()</see>
            . The source contents is
            temporarily available as an artifact of the blame algorithm. Most
            applications will want the result contents for display to users.
            </returns>
        </member>
        <member name="M:NGit.Blame.BlameGenerator.GetResultContents">
            <returns>
            complete file contents of the result file blame is annotating.
            This value is accessible only after being configured and only
            immediately before the first call to
            <see cref="M:NGit.Blame.BlameGenerator.Next">Next()</see>
            . Returns
            null if the path does not exist.
            </returns>
            <exception cref="T:System.IO.IOException">repository cannot be read.</exception>
            <exception cref="T:System.InvalidOperationException">
            <see cref="M:NGit.Blame.BlameGenerator.Next">Next()</see>
            has already been invoked.
            </exception>
        </member>
        <member name="M:NGit.Blame.BlameGenerator.Release">
            <summary>Release the current blame session.</summary>
            <remarks>Release the current blame session.</remarks>
        </member>
        <member name="M:NGit.Blame.BlameGenerator.Find(NGit.Revwalk.RevCommit,NGit.Treewalk.Filter.PathFilter)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Blame.BlameGenerator.FindRename(NGit.Revwalk.RevCommit,NGit.Revwalk.RevCommit,NGit.Treewalk.Filter.PathFilter)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Revwalk.ObjectListIterator" -->
        <member name="M:NGit.Revwalk.ObjectListIterator.#ctor(NGit.Revwalk.ObjectWalk)">
            <summary>Initialize the list iterator.</summary>
            <remarks>Initialize the list iterator.</remarks>
            <param name="walk">
            the revision pool the iterator will use when allocating the
            returned objects.
            </param>
        </member>
        <member name="M:NGit.Revwalk.ObjectListIterator.LookupAny(NGit.AnyObjectId,System.Int32)">
            <summary>Lookup an object from the revision pool.</summary>
            <remarks>Lookup an object from the revision pool.</remarks>
            <param name="id">the object to allocate.</param>
            <param name="type">
            the type of the object. The type must be accurate, as it is
            used to allocate the proper RevObject instance.
            </param>
            <returns>the object.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Revwalk.ObjectListIterator.Next" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Revwalk.ObjectListIterator.NextObject" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Revwalk.ObjectListIterator.GetPathHashCode" -->
        <member name="M:NGit.Revwalk.ObjectListIterator.Release">
            <summary>Release the resources associated with this iterator.</summary>
            <remarks>Release the resources associated with this iterator.</remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Notes.NoteMapMerger" -->
        <member name="M:NGit.Notes.NoteMapMerger.#ctor(NGit.Repository,NGit.Notes.NoteMerger,NGit.Merge.MergeStrategy)">
            <summary>
            Constructs a NoteMapMerger with custom
            <see cref="T:NGit.Notes.NoteMerger">NoteMerger</see>
            and custom
            <see cref="T:NGit.Merge.MergeStrategy">NGit.Merge.MergeStrategy</see>
            .
            </summary>
            <param name="db">Git repository</param>
            <param name="noteMerger">note merger for merging conflicting changes on a note</param>
            <param name="nonNotesMergeStrategy">merge strategy for merging non-note entries</param>
        </member>
        <member name="M:NGit.Notes.NoteMapMerger.#ctor(NGit.Repository)">
            <summary>
            Constructs a NoteMapMerger with
            <see cref="T:NGit.Notes.DefaultNoteMerger">DefaultNoteMerger</see>
            as the merger
            for notes and the
            <see cref="F:NGit.Merge.MergeStrategy.RESOLVE">NGit.Merge.MergeStrategy.RESOLVE</see>
            as the strategy for
            resolving conflicts on non-notes
            </summary>
            <param name="db">Git repository</param>
        </member>
        <member name="M:NGit.Notes.NoteMapMerger.Merge(NGit.Notes.NoteMap,NGit.Notes.NoteMap,NGit.Notes.NoteMap)">
            <summary>Performs the merge.</summary>
            <remarks>Performs the merge.</remarks>
            <param name="base">base version of the note tree</param>
            <param name="ours">ours version of the note tree</param>
            <param name="theirs">theirs version of the note tree</param>
            <returns>merge result as a new NoteMap</returns>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:NGit.Notes.NoteMapMerger.Merge(System.Int32,NGit.Notes.InMemoryNoteBucket,NGit.Notes.InMemoryNoteBucket,NGit.Notes.InMemoryNoteBucket)">
            <summary>
            This method is called only when it is known that there is some difference
            between base, ours and theirs.
            </summary>
            <remarks>
            This method is called only when it is known that there is some difference
            between base, ours and theirs.
            </remarks>
            <param name="treeDepth"></param>
            <param name="base"></param>
            <param name="ours"></param>
            <param name="theirs"></param>
            <returns>merge result as an InMemoryBucket</returns>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:NGit.Notes.NoteMapMerger.MergeFanoutBucket(System.Int32,NGit.Notes.FanoutBucket,NGit.Notes.FanoutBucket,NGit.Notes.FanoutBucket)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Notes.NoteMapMerger.AddIfNotNull(NGit.Notes.FanoutBucket,System.Int32,NGit.Notes.NoteBucket)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Notes.NoteMapMerger.MergeLeafBucket(System.Int32,NGit.Notes.LeafBucket,NGit.Notes.LeafBucket,NGit.Notes.LeafBucket)">
            <exception cref="T:NGit.Errors.MissingObjectException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Notes.NoteMapMerger.MergeNonNotes(NGit.Notes.NonNoteEntry,NGit.Notes.NonNoteEntry,NGit.Notes.NonNoteEntry)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Notes.NoteMapMerger.Write(NGit.Notes.NonNoteEntry)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="T:NGit.Errors.UnsupportedCredentialItem">
            <summary>
            An exception thrown when a
            <see cref="T:NGit.Transport.CredentialItem">NGit.Transport.CredentialItem</see>
            is requested from a
            <see cref="T:NGit.Transport.CredentialsProvider">NGit.Transport.CredentialsProvider
            	</see>
            which is not supported by this provider.
            </summary>
        </member>
        <member name="M:NGit.Errors.UnsupportedCredentialItem.#ctor(NGit.Transport.URIish,System.String)">
            <summary>
            Constructs an UnsupportedCredentialItem with the specified detail message
            prefixed with provided URI.
            </summary>
            <remarks>
            Constructs an UnsupportedCredentialItem with the specified detail message
            prefixed with provided URI.
            </remarks>
            <param name="uri">URI used for transport</param>
            <param name="s">message</param>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Transport.TransportLocal" -->
        <!-- Badly formed XML comment ignored for member "T:NGit.Transport.PackTransport" -->
        <member name="M:NGit.Transport.TransportLocal.OpenFetch">
            <exception cref="T:NGit.Errors.TransportException"></exception>
        </member>
        <member name="M:NGit.Transport.TransportLocal.OpenPush">
            <exception cref="T:System.NotSupportedException"></exception>
            <exception cref="T:NGit.Errors.TransportException"></exception>
        </member>
        <member name="M:NGit.Transport.TransportLocal.Spawn(System.String)">
            <exception cref="T:NGit.Errors.TransportException"></exception>
        </member>
        <member name="M:NGit.Transport.TransportLocal._TransportProtocol_96.Open(NGit.Transport.URIish,NGit.Repository,System.String)">
            <exception cref="T:NGit.Errors.NoRemoteRepositoryException"></exception>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Transport.BasePackFetchConnection" -->
        <member name="T:NGit.Transport.BasePackConnection">
            <summary>Base helper class for pack-based operations implementations.</summary>
            <remarks>
            Base helper class for pack-based operations implementations. Provides partial
            implementation of pack-protocol - refs advertising and capabilities support,
            and some other helper methods.
            </remarks>
            <seealso cref="T:NGit.Transport.BasePackFetchConnection">BasePackFetchConnection</seealso>
            <seealso cref="T:NGit.Transport.BasePackPushConnection">BasePackPushConnection</seealso>
        </member>
        <member name="T:NGit.Transport.BaseConnection">
            <summary>Base helper class for implementing operations connections.</summary>
            <remarks>Base helper class for implementing operations connections.</remarks>
            <seealso cref="T:NGit.Transport.BasePackConnection">BasePackConnection</seealso>
            <seealso cref="T:NGit.Transport.BaseFetchConnection">BaseFetchConnection</seealso>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Transport.Connection" -->
        <member name="M:NGit.Transport.Connection.GetRefsMap">
            <summary>
            Get the complete map of refs advertised as available for fetching or
            pushing.
            </summary>
            <remarks>
            Get the complete map of refs advertised as available for fetching or
            pushing.
            </remarks>
            <returns>
            available/advertised refs: map of refname to ref. Never null. Not
            modifiable. The collection can be empty if the remote side has no
            refs (it is an empty/newly created repository).
            </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Transport.Connection.GetRefs" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Transport.Connection.GetRef(System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Transport.Connection.Close" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Transport.Connection.GetMessages" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Transport.BaseConnection.Available(System.Collections.Generic.IDictionary{System.String,NGit.Ref})" -->
        <member name="M:NGit.Transport.BaseConnection.MarkStartedOperation">
            <summary>Helper method for ensuring one-operation per connection.</summary>
            <remarks>
            Helper method for ensuring one-operation per connection. Check whether
            operation was already marked as started, and mark it as started.
            </remarks>
            <exception cref="T:NGit.Errors.TransportException">if operation was already marked as started.
            	</exception>
        </member>
        <member name="M:NGit.Transport.BaseConnection.GetMessageWriter">
            <summary>Get the writer that buffers messages from the remote side.</summary>
            <remarks>Get the writer that buffers messages from the remote side.</remarks>
            <returns>writer to store messages from the remote.</returns>
        </member>
        <member name="M:NGit.Transport.BaseConnection.SetMessageWriter(System.IO.TextWriter)">
            <summary>Set the writer that buffers messages from the remote side.</summary>
            <remarks>Set the writer that buffers messages from the remote side.</remarks>
            <param name="writer">
            the writer that messages will be delivered to. The writer's
            <code>toString()</code>
            method should be overridden to return the
            complete contents.
            </param>
        </member>
        <member name="F:NGit.Transport.BasePackConnection.local">
            <summary>The repository this transport fetches into, or pushes out of.</summary>
            <remarks>The repository this transport fetches into, or pushes out of.</remarks>
        </member>
        <member name="F:NGit.Transport.BasePackConnection.uri">
            <summary>Remote repository location.</summary>
            <remarks>Remote repository location.</remarks>
        </member>
        <member name="F:NGit.Transport.BasePackConnection.transport">
            <summary>
            A transport connected to
            <see cref="F:NGit.Transport.BasePackConnection.uri">uri</see>
            .
            </summary>
        </member>
        <member name="F:NGit.Transport.BasePackConnection.timeoutIn">
            <summary>Low-level input stream, if a timeout was configured.</summary>
            <remarks>Low-level input stream, if a timeout was configured.</remarks>
        </member>
        <member name="F:NGit.Transport.BasePackConnection.timeoutOut">
            <summary>Low-level output stream, if a timeout was configured.</summary>
            <remarks>Low-level output stream, if a timeout was configured.</remarks>
        </member>
        <member name="F:NGit.Transport.BasePackConnection.myTimer">
            <summary>
            Timer to manage
            <see cref="F:NGit.Transport.BasePackConnection.timeoutIn">timeoutIn</see>
            and
            <see cref="F:NGit.Transport.BasePackConnection.timeoutOut">timeoutOut</see>
            .
            </summary>
        </member>
        <member name="F:NGit.Transport.BasePackConnection.in">
            <summary>Input stream reading from the remote.</summary>
            <remarks>Input stream reading from the remote.</remarks>
        </member>
        <member name="F:NGit.Transport.BasePackConnection.out">
            <summary>Output stream sending to the remote.</summary>
            <remarks>Output stream sending to the remote.</remarks>
        </member>
        <member name="F:NGit.Transport.BasePackConnection.pckIn">
            <summary>
            Packet line decoder around
            <see cref="F:NGit.Transport.BasePackConnection.in">@in</see>
            .
            </summary>
        </member>
        <member name="F:NGit.Transport.BasePackConnection.pckOut">
            <summary>
            Packet line encoder around
            <see cref="F:NGit.Transport.BasePackConnection.out">@out</see>
            .
            </summary>
        </member>
        <member name="F:NGit.Transport.BasePackConnection.outNeedsEnd">
            <summary>
            Send
            <see cref="M:NGit.Transport.PacketLineOut.End">PacketLineOut.End()</see>
            before closing
            <see cref="F:NGit.Transport.BasePackConnection.out">@out</see>
            ?
            </summary>
        </member>
        <member name="F:NGit.Transport.BasePackConnection.statelessRPC">
            <summary>True if this is a stateless RPC connection.</summary>
            <remarks>True if this is a stateless RPC connection.</remarks>
        </member>
        <member name="F:NGit.Transport.BasePackConnection.remoteCapablities">
            <summary>Capability tokens advertised by the remote side.</summary>
            <remarks>Capability tokens advertised by the remote side.</remarks>
        </member>
        <member name="F:NGit.Transport.BasePackConnection.additionalHaves">
            <summary>Extra objects the remote has, but which aren't offered as refs.</summary>
            <remarks>Extra objects the remote has, but which aren't offered as refs.</remarks>
        </member>
        <member name="M:NGit.Transport.BasePackConnection.Init(Sharpen.InputStream,Sharpen.OutputStream)">
            <summary>Configure this connection with the directional pipes.</summary>
            <remarks>Configure this connection with the directional pipes.</remarks>
            <param name="myIn">
            input stream to receive data from the peer. Caller must ensure
            the input is buffered, otherwise read performance may suffer.
            </param>
            <param name="myOut">
            output stream to transmit data to the peer. Caller must ensure
            the output is buffered, otherwise write performance may
            suffer.
            </param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Transport.BasePackConnection.ReadAdvertisedRefs" -->
        <member name="M:NGit.Transport.BasePackConnection.ReadAdvertisedRefsImpl">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Transport.BasePackConnection.NoRepository">
            <summary>Create an exception to indicate problems finding a remote repository.</summary>
            <remarks>
            Create an exception to indicate problems finding a remote repository. The
            caller is expected to throw the returned exception.
            Subclasses may override this method to provide better diagnostics.
            </remarks>
            <returns>
            a TransportException saying a repository cannot be found and
            possibly why.
            </returns>
        </member>
        <member name="M:NGit.Transport.BasePackConnection.EndOut">
            <summary>Tell the peer we are disconnecting, if it cares to know.</summary>
            <remarks>Tell the peer we are disconnecting, if it cares to know.</remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Transport.FetchConnection" -->
        <member name="M:NGit.Transport.FetchConnection.Fetch(NGit.ProgressMonitor,System.Collections.Generic.ICollection{NGit.Ref},System.Collections.Generic.ICollection{NGit.ObjectId})">
            <summary>Fetch objects we don't have but that are reachable from advertised refs.
            	</summary>
            <remarks>
            Fetch objects we don't have but that are reachable from advertised refs.
            <p>
            Only one call per connection is allowed. Subsequent calls will result in
            <see cref="T:NGit.Errors.TransportException">NGit.Errors.TransportException</see>
            .
            </p>
            <p>
            Implementations are free to use network connections as necessary to
            efficiently (for both client and server) transfer objects from the remote
            repository into this repository. When possible implementations should
            avoid replacing/overwriting/duplicating an object already available in
            the local destination repository. Locally available objects and packs
            should always be preferred over remotely available objects and packs.
            <see cref="M:NGit.Transport.Transport.IsFetchThin">Transport.IsFetchThin()</see>
            should be honored if applicable.
            </p>
            </remarks>
            <param name="monitor">
            progress monitor to inform the end-user about the amount of
            work completed, or to indicate cancellation. Implementations
            should poll the monitor at regular intervals to look for
            cancellation requests from the user.
            </param>
            <param name="want">
            one or more refs advertised by this connection that the caller
            wants to store locally.
            </param>
            <param name="have">
            additional objects known to exist in the destination
            repository, especially if they aren't yet reachable by the ref
            database. Connections should take this set as an addition to
            what is reachable through all Refs, not in replace of it.
            </param>
            <exception cref="T:NGit.Errors.TransportException">
            objects could not be copied due to a network failure,
            protocol error, or error on remote side, or connection was
            already used for fetch.
            </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Transport.FetchConnection.DidFetchIncludeTags" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Transport.FetchConnection.DidFetchTestConnectivity" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Transport.FetchConnection.SetPackLockMessage(System.String)" -->
        <member name="M:NGit.Transport.FetchConnection.GetPackLocks">
            <summary>
            All locks created by the last
            <see cref="!:Fetch(NGit.ProgressMonitor, System.Collections.Generic.ICollection&lt;E&gt;, System.Collections.Generic.ICollection&lt;E&gt;)&#xA;            	">Fetch(NGit.ProgressMonitor, System.Collections.Generic.ICollection&lt;E&gt;, System.Collections.Generic.ICollection&lt;E&gt;)
            	</see>
            call.
            </summary>
            <returns>
            collection (possibly empty) of locks created by the last call to
            fetch. The caller must release these after refs are updated in
            order to safely permit garbage collection.
            </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "F:NGit.Transport.BasePackFetchConnection.MAX_HAVES" -->
        <!-- Badly formed XML comment ignored for member "F:NGit.Transport.BasePackFetchConnection.MIN_CLIENT_BUFFER" -->
        <member name="F:NGit.Transport.BasePackFetchConnection.OPTION_INCLUDE_TAG">
            <summary>Include tags if we are also including the referenced objects.</summary>
            <remarks>Include tags if we are also including the referenced objects.</remarks>
            <since>2.0</since>
        </member>
        <member name="F:NGit.Transport.BasePackFetchConnection.OPTION_MULTI_ACK">
            <summary>Mutli-ACK support for improved negotiation.</summary>
            <remarks>Mutli-ACK support for improved negotiation.</remarks>
            <since>2.0</since>
        </member>
        <member name="F:NGit.Transport.BasePackFetchConnection.OPTION_MULTI_ACK_DETAILED">
            <summary>Mutli-ACK detailed support for improved negotiation.</summary>
            <remarks>Mutli-ACK detailed support for improved negotiation.</remarks>
            <since>2.0</since>
        </member>
        <member name="F:NGit.Transport.BasePackFetchConnection.OPTION_THIN_PACK">
            <summary>The client supports packs with deltas but not their bases.</summary>
            <remarks>The client supports packs with deltas but not their bases.</remarks>
            <since>2.0</since>
        </member>
        <member name="F:NGit.Transport.BasePackFetchConnection.OPTION_SIDE_BAND">
            <summary>The client supports using the side-band for progress messages.</summary>
            <remarks>The client supports using the side-band for progress messages.</remarks>
            <since>2.0</since>
        </member>
        <member name="F:NGit.Transport.BasePackFetchConnection.OPTION_SIDE_BAND_64K">
            <summary>The client supports using the 64K side-band for progress messages.</summary>
            <remarks>The client supports using the 64K side-band for progress messages.</remarks>
            <since>2.0</since>
        </member>
        <member name="F:NGit.Transport.BasePackFetchConnection.OPTION_OFS_DELTA">
            <summary>The client supports packs with OFS deltas.</summary>
            <remarks>The client supports packs with OFS deltas.</remarks>
            <since>2.0</since>
        </member>
        <member name="F:NGit.Transport.BasePackFetchConnection.OPTION_SHALLOW">
            <summary>The client supports shallow fetches.</summary>
            <remarks>The client supports shallow fetches.</remarks>
            <since>2.0</since>
        </member>
        <member name="F:NGit.Transport.BasePackFetchConnection.OPTION_NO_PROGRESS">
            <summary>The client does not want progress messages and will ignore them.</summary>
            <remarks>The client does not want progress messages and will ignore them.</remarks>
            <since>2.0</since>
        </member>
        <member name="F:NGit.Transport.BasePackFetchConnection.OPTION_NO_DONE">
            <summary>The client supports receiving a pack before it has sent "done".</summary>
            <remarks>The client supports receiving a pack before it has sent "done".</remarks>
            <since>2.0</since>
        </member>
        <member name="F:NGit.Transport.BasePackFetchConnection.reachableCommits">
            <summary>All commits that are immediately reachable by a local ref.</summary>
            <remarks>All commits that are immediately reachable by a local ref.</remarks>
        </member>
        <member name="F:NGit.Transport.BasePackFetchConnection.REACHABLE">
            <summary>Marks an object as having all its dependencies.</summary>
            <remarks>Marks an object as having all its dependencies.</remarks>
        </member>
        <member name="F:NGit.Transport.BasePackFetchConnection.COMMON">
            <summary>Marks a commit known to both sides of the connection.</summary>
            <remarks>Marks a commit known to both sides of the connection.</remarks>
        </member>
        <member name="F:NGit.Transport.BasePackFetchConnection.STATE">
            <summary>
            Like
            <see cref="F:NGit.Transport.BasePackFetchConnection.COMMON">COMMON</see>
            but means its also in
            <see cref="F:NGit.Transport.BasePackFetchConnection.pckState">pckState</see>
            .
            </summary>
        </member>
        <member name="F:NGit.Transport.BasePackFetchConnection.ADVERTISED">
            <summary>Marks a commit listed in the advertised refs.</summary>
            <remarks>Marks a commit listed in the advertised refs.</remarks>
        </member>
        <member name="F:NGit.Transport.BasePackFetchConnection.state">
            <summary>
            RPC state, if
            <see cref="F:NGit.Transport.BasePackConnection.statelessRPC">BasePackConnection.statelessRPC</see>
            is true.
            </summary>
        </member>
        <member name="M:NGit.Transport.BasePackFetchConnection.#ctor(NGit.Transport.PackTransport)">
            <summary>Create a new connection to fetch using the native git transport.</summary>
            <remarks>Create a new connection to fetch using the native git transport.</remarks>
            <param name="packTransport">the transport.</param>
        </member>
        <member name="M:NGit.Transport.BasePackFetchConnection.Fetch(NGit.ProgressMonitor,System.Collections.Generic.ICollection{NGit.Ref},System.Collections.Generic.ICollection{NGit.ObjectId})">
            <exception cref="T:NGit.Errors.TransportException"></exception>
        </member>
        <member name="M:NGit.Transport.BasePackFetchConnection.DoFetch(NGit.ProgressMonitor,System.Collections.Generic.ICollection{NGit.Ref},System.Collections.Generic.ICollection{NGit.ObjectId})">
            <summary>Execute common ancestor negotiation and fetch the objects.</summary>
            <remarks>Execute common ancestor negotiation and fetch the objects.</remarks>
            <param name="monitor">progress monitor to receive status updates.</param>
            <param name="want">the advertised remote references the caller wants to fetch.</param>
            <param name="have">
            additional objects to assume that already exist locally. This
            will be added to the set of objects reachable from the
            destination repository's references.
            </param>
            <exception cref="T:NGit.Errors.TransportException">if any exception occurs.</exception>
        </member>
        <member name="M:NGit.Transport.BasePackFetchConnection.MarkReachable(System.Collections.Generic.ICollection{NGit.ObjectId},System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Transport.BasePackFetchConnection.SendWants(System.Collections.Generic.ICollection{NGit.Ref})">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Transport.BasePackFetchConnection.EnableCapabilities">
            <exception cref="T:NGit.Errors.TransportException"></exception>
        </member>
        <member name="M:NGit.Transport.BasePackFetchConnection.Negotiate(NGit.ProgressMonitor)">
            <exception cref="T:System.IO.IOException"></exception>
            <exception cref="T:NGit.Transport.BasePackFetchConnection.CancelledException"></exception>
        </member>
        <member name="M:NGit.Transport.BasePackFetchConnection.NegotiateBegin">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Transport.BasePackFetchConnection.MarkCommon(NGit.Revwalk.RevObject,NGit.Transport.PacketLineIn.AckNackResult)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Transport.BasePackFetchConnection.ReceivePack(NGit.ProgressMonitor)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Transport.BasePackFetchConnection.OnReceivePack">
            <summary>
            Notification event delivered just before the pack is received from the
            network.
            </summary>
            <remarks>
            Notification event delivered just before the pack is received from the
            network. This event can be used by RPC such as
            <see cref="T:NGit.Transport.TransportHttp">TransportHttp</see>
            to
            disable its request magic and ensure the pack stream is read correctly.
            </remarks>
            <since>2.0</since>
        </member>
        <member name="M:NGit.Transport.TransportLocal.InternalLocalFetchConnection.#ctor(NGit.Transport.TransportLocal)">
            <exception cref="T:NGit.Errors.TransportException"></exception>
        </member>
        <member name="M:NGit.Transport.TransportLocal.ForkLocalFetchConnection.#ctor(NGit.Transport.TransportLocal)">
            <exception cref="T:NGit.Errors.TransportException"></exception>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Transport.BasePackPushConnection" -->
        <!-- Badly formed XML comment ignored for member "T:NGit.Transport.PushConnection" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Transport.PushConnection.Push(NGit.ProgressMonitor,System.Collections.Generic.IDictionary{System.String,NGit.Transport.RemoteRefUpdate})" -->
        <member name="F:NGit.Transport.BasePackPushConnection.CAPABILITY_REPORT_STATUS">
            <summary>The client expects a status report after the server processes the pack.</summary>
            <remarks>The client expects a status report after the server processes the pack.</remarks>
            <since>2.0</since>
        </member>
        <member name="F:NGit.Transport.BasePackPushConnection.CAPABILITY_DELETE_REFS">
            <summary>The server supports deleting refs.</summary>
            <remarks>The server supports deleting refs.</remarks>
            <since>2.0</since>
        </member>
        <member name="F:NGit.Transport.BasePackPushConnection.CAPABILITY_OFS_DELTA">
            <summary>The server supports packs with OFS deltas.</summary>
            <remarks>The server supports packs with OFS deltas.</remarks>
            <since>2.0</since>
        </member>
        <member name="F:NGit.Transport.BasePackPushConnection.CAPABILITY_SIDE_BAND_64K">
            <summary>The client supports using the 64K side-band for progress messages.</summary>
            <remarks>The client supports using the 64K side-band for progress messages.</remarks>
            <since>2.0</since>
        </member>
        <member name="F:NGit.Transport.BasePackPushConnection.packTransferTime">
            <summary>Time in milliseconds spent transferring the pack data.</summary>
            <remarks>Time in milliseconds spent transferring the pack data.</remarks>
        </member>
        <member name="M:NGit.Transport.BasePackPushConnection.#ctor(NGit.Transport.PackTransport)">
            <summary>Create a new connection to push using the native git transport.</summary>
            <remarks>Create a new connection to push using the native git transport.</remarks>
            <param name="packTransport">the transport.</param>
        </member>
        <member name="M:NGit.Transport.BasePackPushConnection.Push(NGit.ProgressMonitor,System.Collections.Generic.IDictionary{System.String,NGit.Transport.RemoteRefUpdate})">
            <exception cref="T:NGit.Errors.TransportException"></exception>
        </member>
        <member name="M:NGit.Transport.BasePackPushConnection.DoPush(NGit.ProgressMonitor,System.Collections.Generic.IDictionary{System.String,NGit.Transport.RemoteRefUpdate})">
            <summary>Push one or more objects and update the remote repository.</summary>
            <remarks>Push one or more objects and update the remote repository.</remarks>
            <param name="monitor">progress monitor to receive status updates.</param>
            <param name="refUpdates">update commands to be applied to the remote repository.</param>
            <exception cref="T:NGit.Errors.TransportException">if any exception occurs.</exception>
        </member>
        <member name="M:NGit.Transport.BasePackPushConnection.WriteCommands(System.Collections.Generic.ICollection{NGit.Transport.RemoteRefUpdate},NGit.ProgressMonitor)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Transport.BasePackPushConnection.WritePack(System.Collections.Generic.IDictionary{System.String,NGit.Transport.RemoteRefUpdate},NGit.ProgressMonitor)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Transport.BasePackPushConnection.ReadStatusReport(System.Collections.Generic.IDictionary{System.String,NGit.Transport.RemoteRefUpdate})">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Transport.BasePackPushConnection.ReadStringLongTimeout">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Transport.TransportLocal.InternalLocalPushConnection.#ctor(NGit.Transport.TransportLocal)">
            <exception cref="T:NGit.Errors.TransportException"></exception>
        </member>
        <member name="M:NGit.Transport.TransportLocal.ForkLocalPushConnection.#ctor(NGit.Transport.TransportLocal)">
            <exception cref="T:NGit.Errors.TransportException"></exception>
        </member>
        <member name="T:NGit.Transport.UploadPack">
            <summary>Implements the server side of a fetch connection, transmitting objects.</summary>
            <remarks>Implements the server side of a fetch connection, transmitting objects.</remarks>
        </member>
        <member name="F:NGit.Transport.UploadPack.db">
            <summary>Database we read the objects from.</summary>
            <remarks>Database we read the objects from.</remarks>
        </member>
        <member name="F:NGit.Transport.UploadPack.walk">
            <summary>
            Revision traversal support over
            <see cref="F:NGit.Transport.UploadPack.db">db</see>
            .
            </summary>
        </member>
        <member name="F:NGit.Transport.UploadPack.packConfig">
            <summary>Configuration to pass into the PackWriter.</summary>
            <remarks>Configuration to pass into the PackWriter.</remarks>
        </member>
        <member name="F:NGit.Transport.UploadPack.timeout">
            <summary>Timeout in seconds to wait for client interaction.</summary>
            <remarks>Timeout in seconds to wait for client interaction.</remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "F:NGit.Transport.UploadPack.biDirectionalPipe" -->
        <member name="F:NGit.Transport.UploadPack.timer">
            <summary>
            Timer to manage
            <see cref="F:NGit.Transport.UploadPack.timeout">timeout</see>
            .
            </summary>
        </member>
        <member name="F:NGit.Transport.UploadPack.refs">
            <summary>The refs we advertised as existing at the start of the connection.</summary>
            <remarks>The refs we advertised as existing at the start of the connection.</remarks>
        </member>
        <member name="F:NGit.Transport.UploadPack.advertiseRefsHook">
            <summary>Hook used while advertising the refs to the client.</summary>
            <remarks>Hook used while advertising the refs to the client.</remarks>
        </member>
        <member name="F:NGit.Transport.UploadPack.refFilter">
            <summary>Filter used while advertising the refs to the client.</summary>
            <remarks>Filter used while advertising the refs to the client.</remarks>
        </member>
        <member name="F:NGit.Transport.UploadPack.preUploadHook">
            <summary>Hook handling the various upload phases.</summary>
            <remarks>Hook handling the various upload phases.</remarks>
        </member>
        <member name="F:NGit.Transport.UploadPack.options">
            <summary>Capabilities requested by the client.</summary>
            <remarks>Capabilities requested by the client.</remarks>
        </member>
        <member name="F:NGit.Transport.UploadPack.wantIds">
            <summary>Raw ObjectIds the client has asked for, before validating them.</summary>
            <remarks>Raw ObjectIds the client has asked for, before validating them.</remarks>
        </member>
        <member name="F:NGit.Transport.UploadPack.wantAll">
            <summary>Objects the client wants to obtain.</summary>
            <remarks>Objects the client wants to obtain.</remarks>
        </member>
        <member name="F:NGit.Transport.UploadPack.commonBase">
            <summary>Objects on both sides, these don't have to be sent.</summary>
            <remarks>Objects on both sides, these don't have to be sent.</remarks>
        </member>
        <member name="F:NGit.Transport.UploadPack.clientShallowCommits">
            <summary>Shallow commits the client already has.</summary>
            <remarks>Shallow commits the client already has.</remarks>
        </member>
        <member name="F:NGit.Transport.UploadPack.unshallowCommits">
            <summary>Shallow commits on the client which are now becoming unshallow</summary>
        </member>
        <member name="F:NGit.Transport.UploadPack.depth">
            <summary>Desired depth from the client on a shallow request.</summary>
            <remarks>Desired depth from the client on a shallow request.</remarks>
        </member>
        <member name="F:NGit.Transport.UploadPack.oldestTime">
            <summary>Commit time of the oldest common commit, in seconds.</summary>
            <remarks>Commit time of the oldest common commit, in seconds.</remarks>
        </member>
        <member name="F:NGit.Transport.UploadPack.okToGiveUp">
            <summary>
            null if
            <see cref="F:NGit.Transport.UploadPack.commonBase">commonBase</see>
            should be examined again.
            </summary>
        </member>
        <member name="F:NGit.Transport.UploadPack.advertised">
            <summary>Objects we sent in our advertisement list, clients can ask for these.</summary>
            <remarks>Objects we sent in our advertisement list, clients can ask for these.</remarks>
        </member>
        <member name="F:NGit.Transport.UploadPack.WANT">
            <summary>Marked on objects the client has asked us to give them.</summary>
            <remarks>Marked on objects the client has asked us to give them.</remarks>
        </member>
        <member name="F:NGit.Transport.UploadPack.PEER_HAS">
            <summary>Marked on objects both we and the client have.</summary>
            <remarks>Marked on objects both we and the client have.</remarks>
        </member>
        <member name="F:NGit.Transport.UploadPack.COMMON">
            <summary>
            Marked on objects in
            <see cref="F:NGit.Transport.UploadPack.commonBase">commonBase</see>
            .
            </summary>
        </member>
        <member name="F:NGit.Transport.UploadPack.SATISFIED">
            <summary>Objects where we found a path from the want list to a common base.</summary>
            <remarks>Objects where we found a path from the want list to a common base.</remarks>
        </member>
        <member name="M:NGit.Transport.UploadPack.#ctor(NGit.Repository)">
            <summary>Create a new pack upload for an open repository.</summary>
            <remarks>Create a new pack upload for an open repository.</remarks>
            <param name="copyFrom">the source repository.</param>
        </member>
        <member name="M:NGit.Transport.UploadPack.GetRepository">
            <returns>the repository this upload is reading from.</returns>
        </member>
        <member name="M:NGit.Transport.UploadPack.GetRevWalk">
            <returns>the RevWalk instance used by this connection.</returns>
        </member>
        <member name="M:NGit.Transport.UploadPack.GetAdvertisedRefs">
            <summary>Get refs which were advertised to the client.</summary>
            <remarks>Get refs which were advertised to the client.</remarks>
            <returns>
            all refs which were advertised to the client, or null if
            <see cref="!:SetAdvertisedRefs(System.Collections.Generic.IDictionary&lt;K, V&gt;)">SetAdvertisedRefs(System.Collections.Generic.IDictionary&lt;K, V&gt;)
            	</see>
            has not been called yet.
            </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Transport.UploadPack.SetAdvertisedRefs(System.Collections.Generic.IDictionary{System.String,NGit.Ref})" -->
        <member name="M:NGit.Transport.UploadPack.GetTimeout">
            <returns>timeout (in seconds) before aborting an IO operation.</returns>
        </member>
        <member name="M:NGit.Transport.UploadPack.SetTimeout(System.Int32)">
            <summary>Set the timeout before willing to abort an IO call.</summary>
            <remarks>Set the timeout before willing to abort an IO call.</remarks>
            <param name="seconds">
            number of seconds to wait (with no data transfer occurring)
            before aborting an IO read or write operation with the
            connected client.
            </param>
        </member>
        <member name="M:NGit.Transport.UploadPack.IsBiDirectionalPipe">
            <returns>
            true if this class expects a bi-directional pipe opened between
            the client and itself. The default is true.
            </returns>
        </member>
        <member name="M:NGit.Transport.UploadPack.SetBiDirectionalPipe(System.Boolean)">
            <param name="twoWay">
            if true, this class will assume the socket is a fully
            bidirectional pipe between the two peers and takes advantage
            of that by first transmitting the known refs, then waiting to
            read commands. If false, this class assumes it must read the
            commands before writing output and does not perform the
            initial advertising.
            </param>
        </member>
        <member name="M:NGit.Transport.UploadPack.GetRequestPolicy">
            <returns>policy used by the service to validate client requests.</returns>
        </member>
        <member name="M:NGit.Transport.UploadPack.SetRequestPolicy(NGit.Transport.UploadPack.RequestPolicy)">
            <param name="policy">
            the policy used to enforce validation of a client's want list.
            By default the policy is
            <see cref="F:NGit.Transport.UploadPack.RequestPolicy.ADVERTISED">RequestPolicy.ADVERTISED</see>
            ,
            which is the Git default requiring clients to only ask for an
            object that a reference directly points to. This may be relaxed
            to
            <see cref="F:NGit.Transport.UploadPack.RequestPolicy.REACHABLE_COMMIT">RequestPolicy.REACHABLE_COMMIT</see>
            when callers
            have
            <see cref="M:NGit.Transport.UploadPack.SetBiDirectionalPipe(System.Boolean)">SetBiDirectionalPipe(bool)</see>
            set to false.
            </param>
        </member>
        <member name="M:NGit.Transport.UploadPack.GetAdvertiseRefsHook">
            <returns>the hook used while advertising the refs to the client</returns>
        </member>
        <member name="M:NGit.Transport.UploadPack.GetRefFilter">
            <returns>the filter used while advertising the refs to the client</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Transport.UploadPack.SetAdvertiseRefsHook(NGit.Transport.AdvertiseRefsHook)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Transport.UploadPack.SetRefFilter(NGit.Transport.RefFilter)" -->
        <member name="M:NGit.Transport.UploadPack.GetPreUploadHook">
            <returns>the configured upload hook.</returns>
        </member>
        <member name="M:NGit.Transport.UploadPack.SetPreUploadHook(NGit.Transport.PreUploadHook)">
            <summary>Set the hook that controls how this instance will behave.</summary>
            <remarks>Set the hook that controls how this instance will behave.</remarks>
            <param name="hook">the hook; if null no special actions are taken.</param>
        </member>
        <member name="M:NGit.Transport.UploadPack.SetPackConfig(NGit.Storage.Pack.PackConfig)">
            <summary>Set the configuration used by the pack generator.</summary>
            <remarks>Set the configuration used by the pack generator.</remarks>
            <param name="pc">
            configuration controlling packing parameters. If null the
            source repository's settings will be used.
            </param>
        </member>
        <member name="M:NGit.Transport.UploadPack.GetLogger">
            <returns>the configured logger.</returns>
        </member>
        <member name="M:NGit.Transport.UploadPack.SetLogger(NGit.Transport.UploadPackLogger)">
            <summary>Set the logger.</summary>
            <remarks>Set the logger.</remarks>
            <param name="logger">the logger instance. If null, no logging occurs.</param>
        </member>
        <member name="M:NGit.Transport.UploadPack.IsSideBand">
            <summary>Check whether the client expects a side-band stream.</summary>
            <remarks>Check whether the client expects a side-band stream.</remarks>
            <returns>
            true if the client has advertised a side-band capability, false
            otherwise.
            </returns>
            <exception cref="T:NGit.Transport.RequestNotYetReadException">
            if the client's request has not yet been read from the wire, so
            we do not know if they expect side-band. Note that the client
            may have already written the request, it just has not been
            read.
            </exception>
            <exception cref="T:NGit.Transport.RequestNotYetReadException"></exception>
        </member>
        <member name="M:NGit.Transport.UploadPack.Upload(Sharpen.InputStream,Sharpen.OutputStream,Sharpen.OutputStream)">
            <summary>Execute the upload task on the socket.</summary>
            <remarks>Execute the upload task on the socket.</remarks>
            <param name="input">
            raw input to read client commands from. Caller must ensure the
            input is buffered, otherwise read performance may suffer.
            </param>
            <param name="output">
            response back to the Git network client, to write the pack
            data onto. Caller must ensure the output is buffered,
            otherwise write performance may suffer.
            </param>
            <param name="messages">
            secondary "notice" channel to send additional messages out
            through. When run over SSH this should be tied back to the
            standard error channel of the command execution. For most
            other network connections this should be null.
            </param>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:NGit.Transport.UploadPack.GetPackStatistics">
            <summary>Get the PackWriter's statistics if a pack was sent to the client.</summary>
            <remarks>Get the PackWriter's statistics if a pack was sent to the client.</remarks>
            <returns>
            statistics about pack output, if a pack was sent. Null if no pack
            was sent, such as during the negotation phase of a smart HTTP
            connection, or if the client was already up-to-date.
            </returns>
        </member>
        <member name="M:NGit.Transport.UploadPack.Service">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Transport.UploadPack.ProcessShallow">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Transport.UploadPack.SendAdvertisedRefs(NGit.Transport.RefAdvertiser)">
            <summary>Generate an advertisement of available refs and capabilities.</summary>
            <remarks>Generate an advertisement of available refs and capabilities.</remarks>
            <param name="adv">the advertisement formatter.</param>
            <exception cref="T:System.IO.IOException">the formatter failed to write an advertisement.
            	</exception>
            <exception cref="T:NGit.Transport.ServiceMayNotContinueException">the hook denied advertisement.</exception>
            <exception cref="T:NGit.Transport.ServiceMayNotContinueException"></exception>
        </member>
        <member name="M:NGit.Transport.UploadPack.RecvWants">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Transport.UploadPack.Negotiate">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Transport.UploadPack.ProcessHaveLines(System.Collections.Generic.IList{NGit.ObjectId},NGit.ObjectId)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Transport.UploadPack.CheckNotAdvertisedWants(System.Collections.Generic.ICollection{NGit.Revwalk.RevObject})">
            <exception cref="T:NGit.Errors.MissingObjectException"></exception>
            <exception cref="T:NGit.Errors.IncorrectObjectTypeException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Transport.UploadPack.OkToGiveUp">
            <exception cref="T:NGit.Errors.PackProtocolException"></exception>
        </member>
        <member name="M:NGit.Transport.UploadPack.OkToGiveUpImp">
            <exception cref="T:NGit.Errors.PackProtocolException"></exception>
        </member>
        <member name="M:NGit.Transport.UploadPack.WantSatisfied(NGit.Revwalk.RevObject)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Transport.UploadPack.SendPack">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Transport.UploadPack.SendPack(System.Boolean)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="T:NGit.Transport.UploadPack.RequestPolicy">
            <summary>Policy the server uses to validate client requests</summary>
        </member>
        <member name="T:NGit.Transport.UploadPack.FirstLine">
            <summary>Data in the first line of a request, the line itself plus options.</summary>
            <remarks>Data in the first line of a request, the line itself plus options.</remarks>
        </member>
        <member name="M:NGit.Transport.UploadPack.FirstLine.#ctor(System.String)">
            <summary>Parse the first line of a receive-pack request.</summary>
            <remarks>Parse the first line of a receive-pack request.</remarks>
            <param name="line">line from the client.</param>
        </member>
        <member name="M:NGit.Transport.UploadPack.FirstLine.GetLine">
            <returns>non-capabilities part of the line.</returns>
        </member>
        <member name="M:NGit.Transport.UploadPack.FirstLine.GetOptions">
            <returns>options parsed from the line.</returns>
        </member>
        <member name="T:NGit.Errors.PackProtocolException">
            <summary>Indicates a protocol error has occurred while fetching/pushing objects.</summary>
            <remarks>Indicates a protocol error has occurred while fetching/pushing objects.</remarks>
        </member>
        <member name="T:NGit.Errors.TransportException">
            <summary>Indicates a protocol error has occurred while fetching/pushing objects.</summary>
            <remarks>Indicates a protocol error has occurred while fetching/pushing objects.</remarks>
        </member>
        <member name="M:NGit.Errors.TransportException.#ctor(NGit.Transport.URIish,System.String)">
            <summary>
            Constructs an TransportException with the specified detail message
            prefixed with provided URI.
            </summary>
            <remarks>
            Constructs an TransportException with the specified detail message
            prefixed with provided URI.
            </remarks>
            <param name="uri">URI used for transport</param>
            <param name="s">message</param>
        </member>
        <member name="M:NGit.Errors.TransportException.#ctor(NGit.Transport.URIish,System.String,System.Exception)">
            <summary>
            Constructs an TransportException with the specified detail message
            prefixed with provided URI.
            </summary>
            <remarks>
            Constructs an TransportException with the specified detail message
            prefixed with provided URI.
            </remarks>
            <param name="uri">URI used for transport</param>
            <param name="s">message</param>
            <param name="cause">root cause exception</param>
        </member>
        <member name="M:NGit.Errors.TransportException.#ctor(System.String)">
            <summary>Constructs an TransportException with the specified detail message.</summary>
            <remarks>Constructs an TransportException with the specified detail message.</remarks>
            <param name="s">message</param>
        </member>
        <member name="M:NGit.Errors.TransportException.#ctor(System.String,System.Exception)">
            <summary>Constructs an TransportException with the specified detail message.</summary>
            <remarks>Constructs an TransportException with the specified detail message.</remarks>
            <param name="s">message</param>
            <param name="cause">root cause exception</param>
        </member>
        <member name="M:NGit.Errors.PackProtocolException.#ctor(NGit.Transport.URIish,System.String)">
            <summary>
            Constructs an PackProtocolException with the specified detail message
            prefixed with provided URI.
            </summary>
            <remarks>
            Constructs an PackProtocolException with the specified detail message
            prefixed with provided URI.
            </remarks>
            <param name="uri">URI used for transport</param>
            <param name="s">message</param>
        </member>
        <member name="M:NGit.Errors.PackProtocolException.#ctor(NGit.Transport.URIish,System.String,System.Exception)">
            <summary>
            Constructs an PackProtocolException with the specified detail message
            prefixed with provided URI.
            </summary>
            <remarks>
            Constructs an PackProtocolException with the specified detail message
            prefixed with provided URI.
            </remarks>
            <param name="uri">URI used for transport</param>
            <param name="s">message</param>
            <param name="cause">root cause exception</param>
        </member>
        <member name="M:NGit.Errors.PackProtocolException.#ctor(System.String)">
            <summary>Constructs an PackProtocolException with the specified detail message.</summary>
            <remarks>Constructs an PackProtocolException with the specified detail message.</remarks>
            <param name="s">message</param>
        </member>
        <member name="M:NGit.Errors.PackProtocolException.#ctor(System.String,System.Exception)">
            <summary>Constructs an PackProtocolException with the specified detail message.</summary>
            <remarks>Constructs an PackProtocolException with the specified detail message.</remarks>
            <param name="s">message</param>
            <param name="cause">root cause exception</param>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Util.IO.InterruptTimer" -->
        <member name="M:NGit.Util.IO.InterruptTimer.#ctor">
            <summary>Create a new timer with a default thread name.</summary>
            <remarks>Create a new timer with a default thread name.</remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Util.IO.InterruptTimer.#ctor(System.String)" -->
        <member name="M:NGit.Util.IO.InterruptTimer.Begin(System.Int32)">
            <summary>Arm the interrupt timer before entering a blocking operation.</summary>
            <remarks>Arm the interrupt timer before entering a blocking operation.</remarks>
            <param name="timeout">
            number of milliseconds before the interrupt should trigger.
            Must be &gt; 0.
            </param>
        </member>
        <member name="M:NGit.Util.IO.InterruptTimer.End">
            <summary>Disable the interrupt timer, as the operation is complete.</summary>
            <remarks>Disable the interrupt timer, as the operation is complete.</remarks>
        </member>
        <member name="M:NGit.Util.IO.InterruptTimer.Terminate">
            <summary>Shutdown the timer thread, and wait for it to terminate.</summary>
            <remarks>Shutdown the timer thread, and wait for it to terminate.</remarks>
        </member>
        <member name="T:NGit.Util.MutableInteger">
            <summary>A boxed integer that can be modified.</summary>
            <remarks>A boxed integer that can be modified.</remarks>
        </member>
        <member name="F:NGit.Util.MutableInteger.value">
            <summary>Current value of this boxed value.</summary>
            <remarks>Current value of this boxed value.</remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Treewalk.Filter.OrTreeFilter" -->
        <!-- Badly formed XML comment ignored for member "T:NGit.Treewalk.Filter.TreeFilter" -->
        <member name="F:NGit.Treewalk.Filter.TreeFilter.ALL">
            <summary>Selects all tree entries.</summary>
            <remarks>Selects all tree entries.</remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "F:NGit.Treewalk.Filter.TreeFilter.ANY_DIFF" -->
        <member name="M:NGit.Treewalk.Filter.TreeFilter.Negate">
            <summary>Create a new filter that does the opposite of this filter.</summary>
            <remarks>Create a new filter that does the opposite of this filter.</remarks>
            <returns>a new filter that includes tree entries this filter rejects.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Treewalk.Filter.TreeFilter.Include(NGit.Treewalk.TreeWalk)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Treewalk.Filter.TreeFilter.ShouldBeRecursive" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Treewalk.Filter.TreeFilter.Clone" -->
        <member name="M:NGit.Treewalk.Filter.OrTreeFilter.Create(NGit.Treewalk.Filter.TreeFilter,NGit.Treewalk.Filter.TreeFilter)">
            <summary>Create a filter with two filters, one of which must match.</summary>
            <remarks>Create a filter with two filters, one of which must match.</remarks>
            <param name="a">first filter to test.</param>
            <param name="b">second filter to test.</param>
            <returns>a filter that must match at least one input filter.</returns>
        </member>
        <member name="M:NGit.Treewalk.Filter.OrTreeFilter.Create(NGit.Treewalk.Filter.TreeFilter[])">
            <summary>Create a filter around many filters, one of which must match.</summary>
            <remarks>Create a filter around many filters, one of which must match.</remarks>
            <param name="list">
            list of filters to match against. Must contain at least 2
            filters.
            </param>
            <returns>a filter that must match at least one input filter.</returns>
        </member>
        <member name="M:NGit.Treewalk.Filter.OrTreeFilter.Create(System.Collections.Generic.ICollection{NGit.Treewalk.Filter.TreeFilter})">
            <summary>Create a filter around many filters, one of which must match.</summary>
            <remarks>Create a filter around many filters, one of which must match.</remarks>
            <param name="list">
            list of filters to match against. Must contain at least 2
            filters.
            </param>
            <returns>a filter that must match at least one input filter.</returns>
        </member>
        <member name="M:NGit.Treewalk.Filter.OrTreeFilter.Binary.Include(NGit.Treewalk.TreeWalk)">
            <exception cref="T:NGit.Errors.MissingObjectException"></exception>
            <exception cref="T:NGit.Errors.IncorrectObjectTypeException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Treewalk.Filter.OrTreeFilter.List.Include(NGit.Treewalk.TreeWalk)">
            <exception cref="T:NGit.Errors.MissingObjectException"></exception>
            <exception cref="T:NGit.Errors.IncorrectObjectTypeException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Storage.File.WindowCache" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Storage.File.WindowCache.Reconfigure(System.Int32,System.Int32,System.Boolean,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Storage.File.WindowCache.Reconfigure(NGit.Storage.File.WindowCacheConfig)" -->
        <member name="M:NGit.Storage.File.WindowCache.Get(NGit.Storage.File.PackFile,System.Int64)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="F:NGit.Storage.File.WindowCache.queue">
            <summary>ReferenceQueue to cleanup released and garbage collected windows.</summary>
            <remarks>ReferenceQueue to cleanup released and garbage collected windows.</remarks>
        </member>
        <member name="F:NGit.Storage.File.WindowCache.tableSize">
            <summary>
            Number of entries in
            <see cref="F:NGit.Storage.File.WindowCache.table">table</see>
            .
            </summary>
        </member>
        <member name="F:NGit.Storage.File.WindowCache.clock">
            <summary>Access clock for loose LRU.</summary>
            <remarks>Access clock for loose LRU.</remarks>
        </member>
        <member name="F:NGit.Storage.File.WindowCache.table">
            <summary>Hash bucket directory; entries are chained below.</summary>
            <remarks>Hash bucket directory; entries are chained below.</remarks>
        </member>
        <member name="F:NGit.Storage.File.WindowCache.locks">
            <summary>Locks to prevent concurrent loads for same (PackFile,position).</summary>
            <remarks>Locks to prevent concurrent loads for same (PackFile,position).</remarks>
        </member>
        <member name="F:NGit.Storage.File.WindowCache.evictLock">
            <summary>Lock to elect the eviction thread after a load occurs.</summary>
            <remarks>Lock to elect the eviction thread after a load occurs.</remarks>
        </member>
        <member name="F:NGit.Storage.File.WindowCache.evictBatch">
            <summary>
            Number of
            <see cref="F:NGit.Storage.File.WindowCache.table">table</see>
            buckets to scan for an eviction window.
            </summary>
        </member>
        <member name="M:NGit.Storage.File.WindowCache.Load(NGit.Storage.File.PackFile,System.Int64)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.WindowCache.GetOrLoad(NGit.Storage.File.PackFile,System.Int64)">
            <summary>Lookup a cached object, creating and loading it if it doesn't exist.</summary>
            <remarks>Lookup a cached object, creating and loading it if it doesn't exist.</remarks>
            <param name="pack">the pack that "contains" the cached object.</param>
            <param name="position">offset within <code>pack</code> of the object.</param>
            <returns>the object reference.</returns>
            <exception cref="T:System.IO.IOException">
            the object reference was not in the cache and could not be
            obtained by
            <see cref="M:NGit.Storage.File.WindowCache.Load(NGit.Storage.File.PackFile,System.Int64)">Load(PackFile, long)</see>
            .
            </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Storage.File.WindowCache.RemoveAll" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Storage.File.WindowCache.RemoveAll(NGit.Storage.File.PackFile)" -->
        <member name="F:NGit.Storage.File.WindowCache.Entry.next">
            <summary>Next entry in the hash table's chain list.</summary>
            <remarks>Next entry in the hash table's chain list.</remarks>
        </member>
        <member name="F:NGit.Storage.File.WindowCache.Entry.ref">
            <summary>The referenced object.</summary>
            <remarks>The referenced object.</remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "F:NGit.Storage.File.WindowCache.Entry.dead" -->
        <member name="T:NGit.Storage.File.WindowCache.Ref">
            <summary>A soft reference wrapped around a cached object.</summary>
            <remarks>A soft reference wrapped around a cached object.</remarks>
        </member>
        <member name="T:NGit.Revwalk.Filter.NotRevFilter">
            <summary>Includes a commit only if the subfilter does not include the commit.</summary>
            <remarks>Includes a commit only if the subfilter does not include the commit.</remarks>
        </member>
        <member name="M:NGit.Revwalk.Filter.NotRevFilter.Create(NGit.Revwalk.Filter.RevFilter)">
            <summary>Create a filter that negates the result of another filter.</summary>
            <remarks>Create a filter that negates the result of another filter.</remarks>
            <param name="a">filter to negate.</param>
            <returns>a filter that does the reverse of <code>a</code>.</returns>
        </member>
        <member name="M:NGit.Revwalk.Filter.NotRevFilter.Include(NGit.Revwalk.RevWalk,NGit.Revwalk.RevCommit)">
            <exception cref="T:NGit.Errors.MissingObjectException"></exception>
            <exception cref="T:NGit.Errors.IncorrectObjectTypeException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Revwalk.RevWalk" -->
        <!-- Badly formed XML comment ignored for member "F:NGit.Revwalk.RevWalk.PARSED" -->
        <!-- Badly formed XML comment ignored for member "F:NGit.Revwalk.RevWalk.SEEN" -->
        <!-- Badly formed XML comment ignored for member "F:NGit.Revwalk.RevWalk.UNINTERESTING" -->
        <!-- Badly formed XML comment ignored for member "F:NGit.Revwalk.RevWalk.REWRITE" -->
        <!-- Badly formed XML comment ignored for member "F:NGit.Revwalk.RevWalk.TEMP_MARK" -->
        <!-- Badly formed XML comment ignored for member "F:NGit.Revwalk.RevWalk.TOPO_DELAY" -->
        <member name="F:NGit.Revwalk.RevWalk.RESERVED_FLAGS">
            <summary>Number of flag bits we keep internal for our own use.</summary>
            <remarks>Number of flag bits we keep internal for our own use. See above flags.</remarks>
        </member>
        <member name="F:NGit.Revwalk.RevWalk.repository">
            <summary>Exists <b>ONLY</b> to support legacy Tag and Commit objects.</summary>
            <remarks>Exists <b>ONLY</b> to support legacy Tag and Commit objects.</remarks>
        </member>
        <member name="M:NGit.Revwalk.RevWalk.#ctor(NGit.Repository)">
            <summary>Create a new revision walker for a given repository.</summary>
            <remarks>Create a new revision walker for a given repository.</remarks>
            <param name="repo">
            the repository the walker will obtain data from. An
            ObjectReader will be created by the walker, and must be
            released by the caller.
            </param>
        </member>
        <member name="M:NGit.Revwalk.RevWalk.#ctor(NGit.ObjectReader)">
            <summary>Create a new revision walker for a given repository.</summary>
            <remarks>Create a new revision walker for a given repository.</remarks>
            <param name="or">
            the reader the walker will obtain data from. The reader should
            be released by the caller when the walker is no longer
            required.
            </param>
        </member>
        <member name="M:NGit.Revwalk.RevWalk.GetObjectReader">
            <returns>the reader this walker is using to load objects.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Revwalk.RevWalk.Release" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Revwalk.RevWalk.MarkStart(NGit.Revwalk.RevCommit)" -->
        <member name="M:NGit.Revwalk.RevWalk.MarkStart(System.Collections.Generic.ICollection{NGit.Revwalk.RevCommit})">
            <summary>Mark commits to start graph traversal from.</summary>
            <remarks>Mark commits to start graph traversal from.</remarks>
            <param name="list">
            commits to start traversing from. The commits passed must be
            from this same revision walker.
            </param>
            <exception cref="T:NGit.Errors.MissingObjectException">
            one of the commits supplied is not available from the object
            database. This usually indicates the supplied commit is
            invalid, but the reference was constructed during an earlier
            invocation to
            <see cref="M:NGit.Revwalk.RevWalk.LookupCommit(NGit.AnyObjectId)">LookupCommit(NGit.AnyObjectId)</see>
            .
            </exception>
            <exception cref="T:NGit.Errors.IncorrectObjectTypeException">
            the object was not parsed yet and it was discovered during
            parsing that it is not actually a commit. This usually
            indicates the caller supplied a non-commit SHA-1 to
            <see cref="M:NGit.Revwalk.RevWalk.LookupCommit(NGit.AnyObjectId)">LookupCommit(NGit.AnyObjectId)</see>
            .
            </exception>
            <exception cref="T:System.IO.IOException">a pack file or loose object could not be read.
            	</exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Revwalk.RevWalk.MarkUninteresting(NGit.Revwalk.RevCommit)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Revwalk.RevWalk.IsMergedInto(NGit.Revwalk.RevCommit,NGit.Revwalk.RevCommit)" -->
        <member name="M:NGit.Revwalk.RevWalk.Next">
            <summary>Pop the next most recent commit.</summary>
            <remarks>Pop the next most recent commit.</remarks>
            <returns>next most recent commit; null if traversal is over.</returns>
            <exception cref="T:NGit.Errors.MissingObjectException">
            one or or more of the next commit's parents are not available
            from the object database, but were thought to be candidates
            for traversal. This usually indicates a broken link.
            </exception>
            <exception cref="T:NGit.Errors.IncorrectObjectTypeException">
            one or or more of the next commit's parents are not actually
            commit objects.
            </exception>
            <exception cref="T:System.IO.IOException">a pack file or loose object could not be read.
            	</exception>
        </member>
        <member name="M:NGit.Revwalk.RevWalk.GetRevSort">
            <summary>Obtain the sort types applied to the commits returned.</summary>
            <remarks>Obtain the sort types applied to the commits returned.</remarks>
            <returns>
            the sorting strategies employed. At least one strategy is always
            used, but that strategy may be
            <see cref="F:NGit.Revwalk.RevSort.NONE">RevSort.NONE</see>
            .
            </returns>
        </member>
        <member name="M:NGit.Revwalk.RevWalk.HasRevSort(NGit.Revwalk.RevSort)">
            <summary>Check whether the provided sorting strategy is enabled.</summary>
            <remarks>Check whether the provided sorting strategy is enabled.</remarks>
            <param name="sort">a sorting strategy to look for.</param>
            <returns>true if this strategy is enabled, false otherwise</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Revwalk.RevWalk.Sort(NGit.Revwalk.RevSort)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Revwalk.RevWalk.Sort(NGit.Revwalk.RevSort,System.Boolean)" -->
        <member name="M:NGit.Revwalk.RevWalk.GetRevFilter">
            <summary>Get the currently configured commit filter.</summary>
            <remarks>Get the currently configured commit filter.</remarks>
            <returns>the current filter. Never null as a filter is always needed.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Revwalk.RevWalk.SetRevFilter(NGit.Revwalk.Filter.RevFilter)" -->
        <member name="M:NGit.Revwalk.RevWalk.GetTreeFilter">
            <summary>Get the tree filter used to simplify commits by modified paths.</summary>
            <remarks>Get the tree filter used to simplify commits by modified paths.</remarks>
            <returns>
            the current filter. Never null as a filter is always needed. If
            no filter is being applied
            <see cref="F:NGit.Treewalk.Filter.TreeFilter.ALL">NGit.Treewalk.Filter.TreeFilter.ALL
            	</see>
            is returned.
            </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Revwalk.RevWalk.SetTreeFilter(NGit.Treewalk.Filter.TreeFilter)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Revwalk.RevWalk.IsRetainBody" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Revwalk.RevWalk.SetRetainBody(System.Boolean)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Revwalk.RevWalk.LookupBlob(NGit.AnyObjectId)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Revwalk.RevWalk.LookupTree(NGit.AnyObjectId)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Revwalk.RevWalk.LookupCommit(NGit.AnyObjectId)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Revwalk.RevWalk.LookupTag(NGit.AnyObjectId)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Revwalk.RevWalk.LookupAny(NGit.AnyObjectId,System.Int32)" -->
        <member name="M:NGit.Revwalk.RevWalk.LookupOrNull(NGit.AnyObjectId)">
            <summary>Locate an object that was previously allocated in this walk.</summary>
            <remarks>Locate an object that was previously allocated in this walk.</remarks>
            <param name="id">name of the object.</param>
            <returns>
            reference to the object if it has been previously located;
            otherwise null.
            </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Revwalk.RevWalk.ParseCommit(NGit.AnyObjectId)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Revwalk.RevWalk.ParseTree(NGit.AnyObjectId)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Revwalk.RevWalk.ParseTag(NGit.AnyObjectId)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Revwalk.RevWalk.ParseAny(NGit.AnyObjectId)" -->
        <member name="M:NGit.Revwalk.RevWalk.ParseNew(NGit.AnyObjectId,NGit.ObjectLoader)">
            <exception cref="T:NGit.Errors.LargeObjectException"></exception>
            <exception cref="T:NGit.Errors.CorruptObjectException"></exception>
            <exception cref="T:NGit.Errors.MissingObjectException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Revwalk.RevWalk.GetCachedBytes(NGit.Revwalk.RevObject)">
            <exception cref="T:NGit.Errors.LargeObjectException"></exception>
            <exception cref="T:NGit.Errors.MissingObjectException"></exception>
            <exception cref="T:NGit.Errors.IncorrectObjectTypeException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Revwalk.RevWalk.GetCachedBytes(NGit.Revwalk.RevObject,NGit.ObjectLoader)">
            <exception cref="T:NGit.Errors.LargeObjectException"></exception>
            <exception cref="T:NGit.Errors.MissingObjectException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Revwalk.RevWalk.ParseAny``1(Sharpen.Iterable{``0},System.Boolean)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Revwalk.RevWalk.ParseHeaders(NGit.Revwalk.RevObject)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Revwalk.RevWalk.ParseBody(NGit.Revwalk.RevObject)" -->
        <member name="M:NGit.Revwalk.RevWalk.Peel(NGit.Revwalk.RevObject)">
            <summary>Peel back annotated tags until a non-tag object is found.</summary>
            <remarks>Peel back annotated tags until a non-tag object is found.</remarks>
            <param name="obj">the starting object.</param>
            <returns>
            If
            <code>obj</code>
            is not an annotated tag,
            <code>obj</code>
            . Otherwise
            the first non-tag object that
            <code>obj</code>
            references. The
            returned object's headers have been parsed.
            </returns>
            <exception cref="T:NGit.Errors.MissingObjectException">a referenced object cannot be found.
            	</exception>
            <exception cref="T:System.IO.IOException">a pack file or loose object could not be read.
            	</exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Revwalk.RevWalk.NewFlag(System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Revwalk.RevWalk.Carry(NGit.Revwalk.RevFlag)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Revwalk.RevWalk.Carry(System.Collections.Generic.ICollection{NGit.Revwalk.RevFlag})" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Revwalk.RevWalk.DisposeFlag(NGit.Revwalk.RevFlag)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Revwalk.RevWalk.Reset" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Revwalk.RevWalk.ResetRetain(NGit.Revwalk.RevFlagSet)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Revwalk.RevWalk.ResetRetain(NGit.Revwalk.RevFlag[])" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Revwalk.RevWalk.Reset(System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Revwalk.RevWalk.Dispose" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Revwalk.RevWalk.Iterator" -->
        <member name="M:NGit.Revwalk.RevWalk.AssertNotStarted">
            <summary>Throws an exception if we have started producing output.</summary>
            <remarks>Throws an exception if we have started producing output.</remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Revwalk.RevWalk.ToObjectWalkWithSameObjects" -->
        <member name="M:NGit.Revwalk.RevWalk.CreateCommit(NGit.AnyObjectId)">
            <summary>Construct a new unparsed commit for the given object.</summary>
            <remarks>Construct a new unparsed commit for the given object.</remarks>
            <param name="id">the object this walker requires a commit reference for.</param>
            <returns>a new unparsed reference for the object.</returns>
        </member>
        <member name="T:NGit.Revwalk.AsyncRevObjectQueue">
            <summary>Queue to lookup and parse objects asynchronously.</summary>
            <remarks>
            Queue to lookup and parse objects asynchronously.
            A queue may perform background lookup of objects and supply them (possibly
            out-of-order) to the application.
            </remarks>
        </member>
        <member name="M:NGit.Revwalk.AsyncRevObjectQueue.Next">
            <summary>Obtain the next object.</summary>
            <remarks>Obtain the next object.</remarks>
            <returns>the object; null if there are no more objects remaining.</returns>
            <exception cref="T:NGit.Errors.MissingObjectException">
            the object does not exist. There may be more objects
            remaining in the iteration, the application should call
            <see cref="M:NGit.Revwalk.AsyncRevObjectQueue.Next">Next()</see>
            again.
            </exception>
            <exception cref="T:System.IO.IOException">the object store cannot be accessed.</exception>
        </member>
        <member name="M:NGit.Revwalk.RevWalk._AsyncRevObjectQueue_914`1.Next">
            <exception cref="T:NGit.Errors.MissingObjectException"></exception>
            <exception cref="T:NGit.Errors.IncorrectObjectTypeException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="T:NGit.Revwalk.LIFORevQueue">
            <summary>A queue of commits in LIFO order.</summary>
            <remarks>A queue of commits in LIFO order.</remarks>
        </member>
        <member name="F:NGit.Revwalk.AbstractRevQueue.outputType">
            <summary>Current output flags set for this generator instance.</summary>
            <remarks>Current output flags set for this generator instance.</remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Revwalk.AbstractRevQueue.Add(NGit.Revwalk.RevCommit)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Revwalk.AbstractRevQueue.Add(NGit.Revwalk.RevCommit,NGit.Revwalk.RevFlag)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Revwalk.AbstractRevQueue.AddParents(NGit.Revwalk.RevCommit,NGit.Revwalk.RevFlag)" -->
        <member name="M:NGit.Revwalk.AbstractRevQueue.Next">
            <summary>Remove the first commit from the queue.</summary>
            <remarks>Remove the first commit from the queue.</remarks>
            <returns>the first commit of this queue.</returns>
        </member>
        <member name="M:NGit.Revwalk.AbstractRevQueue.Clear">
            <summary>Remove all entries from this queue.</summary>
            <remarks>Remove all entries from this queue.</remarks>
        </member>
        <member name="M:NGit.Revwalk.BlockRevQueue.#ctor">
            <summary>Create an empty revision queue.</summary>
            <remarks>Create an empty revision queue.</remarks>
        </member>
        <member name="M:NGit.Revwalk.BlockRevQueue.#ctor(NGit.Revwalk.Generator)">
            <exception cref="T:NGit.Errors.MissingObjectException"></exception>
            <exception cref="T:NGit.Errors.IncorrectObjectTypeException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Revwalk.BlockRevQueue.ShareFreeList(NGit.Revwalk.BlockRevQueue)" -->
        <member name="F:NGit.Revwalk.BlockRevQueue.Block.next">
            <summary>Next block in our chain of blocks; null if we are the last.</summary>
            <remarks>Next block in our chain of blocks; null if we are the last.</remarks>
        </member>
        <member name="F:NGit.Revwalk.BlockRevQueue.Block.commits">
            <summary>Our table of queued commits.</summary>
            <remarks>Our table of queued commits.</remarks>
        </member>
        <member name="F:NGit.Revwalk.BlockRevQueue.Block.headIndex">
            <summary>
            Next valid entry in
            <see cref="F:NGit.Revwalk.BlockRevQueue.Block.commits">commits</see>
            .
            </summary>
        </member>
        <member name="F:NGit.Revwalk.BlockRevQueue.Block.tailIndex">
            <summary>
            Next free entry in
            <see cref="F:NGit.Revwalk.BlockRevQueue.Block.commits">commits</see>
            for addition at.
            </summary>
        </member>
        <member name="M:NGit.Revwalk.LIFORevQueue.#ctor">
            <summary>Create an empty LIFO queue.</summary>
            <remarks>Create an empty LIFO queue.</remarks>
        </member>
        <member name="M:NGit.Revwalk.LIFORevQueue.#ctor(NGit.Revwalk.Generator)">
            <exception cref="T:NGit.Errors.MissingObjectException"></exception>
            <exception cref="T:NGit.Errors.IncorrectObjectTypeException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="T:NGit.Patch.FileHeader">
            <summary>Patch header describing an action for a single file path.</summary>
            <remarks>Patch header describing an action for a single file path.</remarks>
        </member>
        <member name="T:NGit.Diff.DiffEntry">
            <summary>A value class representing a change to a file</summary>
        </member>
        <member name="F:NGit.Diff.DiffEntry.A_ZERO">
            <summary>Magical SHA1 used for file adds or deletes</summary>
        </member>
        <member name="F:NGit.Diff.DiffEntry.DEV_NULL">
            <summary>Magical file name used for file adds or deletes.</summary>
            <remarks>Magical file name used for file adds or deletes.</remarks>
        </member>
        <member name="M:NGit.Diff.DiffEntry.#ctor">
            <summary>Create an empty DiffEntry</summary>
        </member>
        <member name="M:NGit.Diff.DiffEntry.Scan(NGit.Treewalk.TreeWalk)">
            <summary>Convert the TreeWalk into DiffEntry headers.</summary>
            <remarks>Convert the TreeWalk into DiffEntry headers.</remarks>
            <param name="walk">the TreeWalk to walk through. Must have exactly two trees.</param>
            <returns>headers describing the changed files.</returns>
            <exception cref="T:System.IO.IOException">the repository cannot be accessed.</exception>
            <exception cref="T:System.ArgumentException">When given TreeWalk doesn't have exactly two trees.
            	</exception>
        </member>
        <member name="M:NGit.Diff.DiffEntry.Scan(NGit.Treewalk.TreeWalk,System.Boolean)">
            <summary>
            Convert the TreeWalk into DiffEntry headers, depending on
            <code>includeTrees</code>
            it will add tree objects into result or not.
            </summary>
            <param name="walk">
            the TreeWalk to walk through. Must have exactly two trees and
            when
            <code>includeTrees</code>
            parameter is
            <code>true</code>
            it can't
            be recursive.
            </param>
            <param name="includeTrees">include tree object's.</param>
            <returns>headers describing the changed files.</returns>
            <exception cref="T:System.IO.IOException">the repository cannot be accessed.</exception>
            <exception cref="T:System.ArgumentException">
            when
            <code>includeTrees</code>
            is true and given TreeWalk is
            recursive. Or when given TreeWalk doesn't have exactly two
            trees
            </exception>
        </member>
        <member name="M:NGit.Diff.DiffEntry.BreakModify(NGit.Diff.DiffEntry)">
            <summary>Breaks apart a DiffEntry into two entries, one DELETE and one ADD.</summary>
            <remarks>Breaks apart a DiffEntry into two entries, one DELETE and one ADD.</remarks>
            <param name="entry">the DiffEntry to break apart.</param>
            <returns>
            a list containing two entries. Calling
            <see cref="M:NGit.Diff.DiffEntry.GetChangeType">GetChangeType()</see>
            on the first entry will return ChangeType.DELETE. Calling it on
            the second entry will return ChangeType.ADD.
            </returns>
        </member>
        <member name="F:NGit.Diff.DiffEntry.oldPath">
            <summary>File name of the old (pre-image).</summary>
            <remarks>File name of the old (pre-image).</remarks>
        </member>
        <member name="F:NGit.Diff.DiffEntry.newPath">
            <summary>File name of the new (post-image).</summary>
            <remarks>File name of the new (post-image).</remarks>
        </member>
        <member name="F:NGit.Diff.DiffEntry.oldMode">
            <summary>Old mode of the file, if described by the patch, else null.</summary>
            <remarks>Old mode of the file, if described by the patch, else null.</remarks>
        </member>
        <member name="F:NGit.Diff.DiffEntry.newMode">
            <summary>New mode of the file, if described by the patch, else null.</summary>
            <remarks>New mode of the file, if described by the patch, else null.</remarks>
        </member>
        <member name="F:NGit.Diff.DiffEntry.changeType">
            <summary>General type of change indicated by the patch.</summary>
            <remarks>General type of change indicated by the patch.</remarks>
        </member>
        <member name="F:NGit.Diff.DiffEntry.score">
            <summary>
            Similarity score if
            <see cref="F:NGit.Diff.DiffEntry.changeType">changeType</see>
            is a copy or rename.
            </summary>
        </member>
        <member name="F:NGit.Diff.DiffEntry.oldId">
            <summary>ObjectId listed on the index line for the old (pre-image)</summary>
        </member>
        <member name="F:NGit.Diff.DiffEntry.newId">
            <summary>ObjectId listed on the index line for the new (post-image)</summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Diff.DiffEntry.GetOldPath" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Diff.DiffEntry.GetNewPath" -->
        <member name="M:NGit.Diff.DiffEntry.GetPath(NGit.Diff.DiffEntry.Side)">
            <summary>Get the path associated with this file.</summary>
            <remarks>Get the path associated with this file.</remarks>
            <param name="side">which path to obtain.</param>
            <returns>name for this file.</returns>
        </member>
        <member name="M:NGit.Diff.DiffEntry.GetOldMode">
            <returns>the old file mode, if described in the patch</returns>
        </member>
        <member name="M:NGit.Diff.DiffEntry.GetNewMode">
            <returns>the new file mode, if described in the patch</returns>
        </member>
        <member name="M:NGit.Diff.DiffEntry.GetMode(NGit.Diff.DiffEntry.Side)">
            <summary>Get the mode associated with this file.</summary>
            <remarks>Get the mode associated with this file.</remarks>
            <param name="side">which mode to obtain.</param>
            <returns>the mode.</returns>
        </member>
        <member name="M:NGit.Diff.DiffEntry.GetChangeType">
            <returns>
            the type of change this patch makes on
            <see cref="M:NGit.Diff.DiffEntry.GetNewPath">GetNewPath()</see>
            
            </returns>
        </member>
        <member name="M:NGit.Diff.DiffEntry.GetScore">
            <returns>
            similarity score between
            <see cref="M:NGit.Diff.DiffEntry.GetOldPath">GetOldPath()</see>
            and
            <see cref="M:NGit.Diff.DiffEntry.GetNewPath">GetNewPath()</see>
            if
            <see cref="M:NGit.Diff.DiffEntry.GetChangeType">GetChangeType()</see>
            is
            <see cref="F:NGit.Diff.DiffEntry.ChangeType.COPY">ChangeType.COPY</see>
            or
            <see cref="F:NGit.Diff.DiffEntry.ChangeType.RENAME">ChangeType.RENAME</see>
            .
            </returns>
        </member>
        <member name="M:NGit.Diff.DiffEntry.GetOldId">
            <summary>Get the old object id from the <code>index</code>.</summary>
            <remarks>Get the old object id from the <code>index</code>.</remarks>
            <returns>the object id; null if there is no index line</returns>
        </member>
        <member name="M:NGit.Diff.DiffEntry.GetNewId">
            <summary>Get the new object id from the <code>index</code>.</summary>
            <remarks>Get the new object id from the <code>index</code>.</remarks>
            <returns>the object id; null if there is no index line</returns>
        </member>
        <member name="M:NGit.Diff.DiffEntry.GetId(NGit.Diff.DiffEntry.Side)">
            <summary>Get the object id.</summary>
            <remarks>Get the object id.</remarks>
            <param name="side">the side of the id to get.</param>
            <returns>the object id; null if there is no index line</returns>
        </member>
        <member name="T:NGit.Diff.DiffEntry.ChangeType">
            <summary>General type of change a single file-level patch describes.</summary>
            <remarks>General type of change a single file-level patch describes.</remarks>
        </member>
        <member name="T:NGit.Diff.DiffEntry.Side">
            <summary>Specify the old or new side for more generalized access.</summary>
            <remarks>Specify the old or new side for more generalized access.</remarks>
        </member>
        <member name="F:NGit.Patch.FileHeader.buf">
            <summary>Buffer holding the patch data for this file.</summary>
            <remarks>Buffer holding the patch data for this file.</remarks>
        </member>
        <member name="F:NGit.Patch.FileHeader.startOffset">
            <summary>
            Offset within
            <see cref="F:NGit.Patch.FileHeader.buf">buf</see>
            to the "diff ..." line.
            </summary>
        </member>
        <member name="F:NGit.Patch.FileHeader.endOffset">
            <summary>
            Position 1 past the end of this file within
            <see cref="F:NGit.Patch.FileHeader.buf">buf</see>
            .
            </summary>
        </member>
        <member name="F:NGit.Patch.FileHeader.patchType">
            <summary>Type of patch used to modify this file</summary>
        </member>
        <member name="F:NGit.Patch.FileHeader.hunks">
            <summary>The hunks of this file</summary>
        </member>
        <member name="F:NGit.Patch.FileHeader.forwardBinaryHunk">
            <summary>
            If
            <see cref="F:NGit.Patch.FileHeader.patchType">patchType</see>
            is
            <see cref="F:NGit.Patch.FileHeader.PatchType.GIT_BINARY">PatchType.GIT_BINARY</see>
            , the new image
            </summary>
        </member>
        <member name="F:NGit.Patch.FileHeader.reverseBinaryHunk">
            <summary>
            If
            <see cref="F:NGit.Patch.FileHeader.patchType">patchType</see>
            is
            <see cref="F:NGit.Patch.FileHeader.PatchType.GIT_BINARY">PatchType.GIT_BINARY</see>
            , the old image
            </summary>
        </member>
        <member name="M:NGit.Patch.FileHeader.#ctor(System.Byte[],NGit.Diff.EditList,NGit.Patch.FileHeader.PatchType)">
            <summary>Constructs a new FileHeader</summary>
            <param name="headerLines">buffer holding the diff header for this file</param>
            <param name="edits">the edits for this file</param>
            <param name="type">the type of patch used to modify this file</param>
        </member>
        <member name="M:NGit.Patch.FileHeader.GetBuffer">
            <returns>the byte array holding this file's patch script.</returns>
        </member>
        <member name="M:NGit.Patch.FileHeader.GetStartOffset">
            <returns>
            offset the start of this file's script in
            <see cref="M:NGit.Patch.FileHeader.GetBuffer">GetBuffer()</see>
            .
            </returns>
        </member>
        <member name="M:NGit.Patch.FileHeader.GetEndOffset">
            <returns>offset one past the end of the file script.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Patch.FileHeader.GetScriptText" -->
        <member name="M:NGit.Patch.FileHeader.GetScriptText(System.Text.Encoding,System.Text.Encoding)">
            <summary>Convert the patch script for this file into a string.</summary>
            <remarks>Convert the patch script for this file into a string.</remarks>
            <param name="oldCharset">hint character set to decode the old lines with.</param>
            <param name="newCharset">hint character set to decode the new lines with.</param>
            <returns>the patch script, as a Unicode string.</returns>
        </member>
        <member name="M:NGit.Patch.FileHeader.GetPatchType">
            <returns>style of patch used to modify this file</returns>
        </member>
        <member name="M:NGit.Patch.FileHeader.HasMetaDataChanges">
            <returns>true if this patch modifies metadata about a file</returns>
        </member>
        <member name="M:NGit.Patch.FileHeader.GetHunks">
            <returns>hunks altering this file; in order of appearance in patch</returns>
        </member>
        <member name="M:NGit.Patch.FileHeader.GetForwardBinaryHunk">
            <returns>
            if a
            <see cref="F:NGit.Patch.FileHeader.PatchType.GIT_BINARY">PatchType.GIT_BINARY</see>
            , the new-image delta/literal
            </returns>
        </member>
        <member name="M:NGit.Patch.FileHeader.GetReverseBinaryHunk">
            <returns>
            if a
            <see cref="F:NGit.Patch.FileHeader.PatchType.GIT_BINARY">PatchType.GIT_BINARY</see>
            , the old-image delta/literal
            </returns>
        </member>
        <member name="M:NGit.Patch.FileHeader.ToEditList">
            <returns>a list describing the content edits performed on this file.</returns>
        </member>
        <member name="M:NGit.Patch.FileHeader.ParseGitFileName(System.Int32,System.Int32)">
            <summary>Parse a "diff --git" or "diff --cc" line.</summary>
            <remarks>Parse a "diff --git" or "diff --cc" line.</remarks>
            <param name="ptr">first character after the "diff --git " or "diff --cc " part.</param>
            <param name="end">one past the last position to parse.</param>
            <returns>first character after the LF at the end of the line; -1 on error.</returns>
        </member>
        <member name="M:NGit.Patch.FileHeader.IsHunkHdr(System.Byte[],System.Int32,System.Int32)">
            <summary>Determine if this is a patch hunk header.</summary>
            <remarks>Determine if this is a patch hunk header.</remarks>
            <param name="buf">the buffer to scan</param>
            <param name="start">first position in the buffer to evaluate</param>
            <param name="end">
            last position to consider; usually the end of the buffer (
            <code>buf.length</code>) or the first position on the next
            line. This is only used to avoid very long runs of '@' from
            killing the scan loop.
            </param>
            <returns>
            the number of "ancestor revisions" in the hunk header. A
            traditional two-way diff ("@@ -...") returns 1; a combined diff
            for a 3 way-merge returns 3. If this is not a hunk header, 0 is
            returned instead.
            </returns>
        </member>
        <member name="T:NGit.Patch.FileHeader.PatchType">
            <summary>Type of patch used by this file.</summary>
            <remarks>Type of patch used by this file.</remarks>
        </member>
        <member name="T:NGit.Events.RepositoryListener">
            <summary>A listener can register for event delivery.</summary>
            <remarks>A listener can register for event delivery.</remarks>
        </member>
        <member name="T:NGit.Errors.TranslationBundleLoadingException">
            <summary>
            This exception will be thrown when a translation bundle loading
            fails.
            </summary>
            <remarks>
            This exception will be thrown when a translation bundle loading
            fails.
            </remarks>
        </member>
        <member name="T:NGit.Errors.TranslationBundleException">
            <summary>Common base class for all translation bundle related exceptions.</summary>
            <remarks>Common base class for all translation bundle related exceptions.</remarks>
        </member>
        <member name="M:NGit.Errors.TranslationBundleException.#ctor(System.String,System.Type,System.Globalization.CultureInfo,System.Exception)">
            <summary>
            To construct an instance of
            <see cref="T:NGit.Errors.TranslationBundleException">TranslationBundleException</see>
            </summary>
            <param name="message">exception message</param>
            <param name="bundleClass">bundle class for which the exception occurred</param>
            <param name="locale">locale for which the exception occurred</param>
            <param name="cause">
            original exception that caused this exception. Usually thrown
            from the
            <see cref="T:Sharpen.ResourceBundle">Sharpen.ResourceBundle</see>
            class.
            </param>
        </member>
        <member name="M:NGit.Errors.TranslationBundleException.GetBundleClass">
            <returns>bundle class for which the exception occurred</returns>
        </member>
        <member name="M:NGit.Errors.TranslationBundleException.GetLocale">
            <returns>locale for which the exception occurred</returns>
        </member>
        <member name="M:NGit.Errors.TranslationBundleLoadingException.#ctor(System.Type,System.Globalization.CultureInfo,System.Exception)">
            <summary>
            Construct a
            <see cref="T:NGit.Errors.TranslationBundleLoadingException">TranslationBundleLoadingException</see>
            for the specified
            bundle class and locale.
            </summary>
            <param name="bundleClass">the bundle class for which the loading failed</param>
            <param name="locale">the locale for which the loading failed</param>
            <param name="cause">
            the original exception thrown from the
            <see cref="M:Sharpen.ResourceBundle.GetBundle(System.String,System.Globalization.CultureInfo)">Sharpen.ResourceBundle.GetBundle(string, System.Globalization.CultureInfo)</see>
            method.
            </param>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.RepositoryBuilder" -->
        <!-- Badly formed XML comment ignored for member "T:NGit.BaseRepositoryBuilder`2" -->
        <member name="M:NGit.BaseRepositoryBuilder`2.GetSymRef(Sharpen.FilePath,Sharpen.FilePath)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="F:NGit.BaseRepositoryBuilder`2.ceilingDirectories">
            <summary>Directories limiting the search for a Git repository.</summary>
            <remarks>Directories limiting the search for a Git repository.</remarks>
        </member>
        <member name="F:NGit.BaseRepositoryBuilder`2.bare">
            <summary>True only if the caller wants to force bare behavior.</summary>
            <remarks>True only if the caller wants to force bare behavior.</remarks>
        </member>
        <member name="F:NGit.BaseRepositoryBuilder`2.mustExist">
            <summary>True if the caller requires the repository to exist.</summary>
            <remarks>True if the caller requires the repository to exist.</remarks>
        </member>
        <member name="F:NGit.BaseRepositoryBuilder`2.config">
            <summary>Configuration file of target repository, lazily loaded if required.</summary>
            <remarks>Configuration file of target repository, lazily loaded if required.</remarks>
        </member>
        <member name="M:NGit.BaseRepositoryBuilder`2.SetFS(NGit.Util.FS)">
            <summary>Set the file system abstraction needed by this repository.</summary>
            <remarks>Set the file system abstraction needed by this repository.</remarks>
            <param name="fs">the abstraction.</param>
            <returns>
            
            <code>this</code>
            (for chaining calls).
            </returns>
        </member>
        <member name="M:NGit.BaseRepositoryBuilder`2.GetFS">
            <returns>the file system abstraction, or null if not set.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.BaseRepositoryBuilder`2.SetGitDir(Sharpen.FilePath)" -->
        <member name="M:NGit.BaseRepositoryBuilder`2.GetGitDir">
            <returns>the meta data directory; null if not set.</returns>
        </member>
        <member name="M:NGit.BaseRepositoryBuilder`2.SetObjectDirectory(Sharpen.FilePath)">
            <summary>Set the directory storing the repository's objects.</summary>
            <remarks>Set the directory storing the repository's objects.</remarks>
            <param name="objectDirectory">
            <code>GIT_OBJECT_DIRECTORY</code>
            , the directory where the
            repository's object files are stored.
            </param>
            <returns>
            
            <code>this</code>
            (for chaining calls).
            </returns>
        </member>
        <member name="M:NGit.BaseRepositoryBuilder`2.GetObjectDirectory">
            <returns>the object directory; null if not set.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.BaseRepositoryBuilder`2.AddAlternateObjectDirectory(Sharpen.FilePath)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.BaseRepositoryBuilder`2.AddAlternateObjectDirectories(System.Collections.Generic.ICollection{Sharpen.FilePath})" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.BaseRepositoryBuilder`2.AddAlternateObjectDirectories(Sharpen.FilePath[])" -->
        <member name="M:NGit.BaseRepositoryBuilder`2.GetAlternateObjectDirectories">
            <returns>ordered array of alternate directories; null if non were set.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.BaseRepositoryBuilder`2.SetBare" -->
        <member name="M:NGit.BaseRepositoryBuilder`2.IsBare">
            <returns>
            true if this repository was forced bare by
            <see cref="M:NGit.BaseRepositoryBuilder`2.SetBare">BaseRepositoryBuilder&lt;B, R&gt;.SetBare()
            	</see>
            .
            </returns>
        </member>
        <member name="M:NGit.BaseRepositoryBuilder`2.SetMustExist(System.Boolean)">
            <summary>Require the repository to exist before it can be opened.</summary>
            <remarks>Require the repository to exist before it can be opened.</remarks>
            <param name="mustExist">
            true if it must exist; false if it can be missing and created
            after being built.
            </param>
            <returns>
            
            <code>this</code>
            (for chaining calls).
            </returns>
        </member>
        <member name="M:NGit.BaseRepositoryBuilder`2.IsMustExist">
            <returns>true if the repository must exist before being opened.</returns>
        </member>
        <member name="M:NGit.BaseRepositoryBuilder`2.SetWorkTree(Sharpen.FilePath)">
            <summary>Set the top level directory of the working files.</summary>
            <remarks>Set the top level directory of the working files.</remarks>
            <param name="workTree">
            <code>GIT_WORK_TREE</code>
            , the working directory of the checkout.
            </param>
            <returns>
            
            <code>this</code>
            (for chaining calls).
            </returns>
        </member>
        <member name="M:NGit.BaseRepositoryBuilder`2.GetWorkTree">
            <returns>the work tree directory, or null if not set.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.BaseRepositoryBuilder`2.SetIndexFile(Sharpen.FilePath)" -->
        <member name="M:NGit.BaseRepositoryBuilder`2.GetIndexFile">
            <returns>the index file location, or null if not set.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.BaseRepositoryBuilder`2.ReadEnvironment" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.BaseRepositoryBuilder`2.ReadEnvironment(NGit.Util.SystemReader)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.BaseRepositoryBuilder`2.AddCeilingDirectory(Sharpen.FilePath)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.BaseRepositoryBuilder`2.AddCeilingDirectories(System.Collections.Generic.ICollection{Sharpen.FilePath})" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.BaseRepositoryBuilder`2.AddCeilingDirectories(Sharpen.FilePath[])" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.BaseRepositoryBuilder`2.FindGitDir" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.BaseRepositoryBuilder`2.FindGitDir(Sharpen.FilePath)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.BaseRepositoryBuilder`2.Setup" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.BaseRepositoryBuilder`2.Build" -->
        <member name="M:NGit.BaseRepositoryBuilder`2.RequireGitDirOrWorkTree">
            <summary>
            Require either
            <code>gitDir</code>
            or
            <code>workTree</code>
            to be set.
            </summary>
        </member>
        <member name="M:NGit.BaseRepositoryBuilder`2.SetupGitDir">
            <summary>Perform standard gitDir initialization.</summary>
            <remarks>Perform standard gitDir initialization.</remarks>
            <exception cref="T:System.IO.IOException">the repository could not be accessed</exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.BaseRepositoryBuilder`2.SetupWorkTree" -->
        <member name="M:NGit.BaseRepositoryBuilder`2.SetupInternals">
            <summary>Configure the internal implementation details of the repository.</summary>
            <remarks>Configure the internal implementation details of the repository.</remarks>
            <exception cref="T:System.IO.IOException">the repository could not be accessed</exception>
        </member>
        <member name="M:NGit.BaseRepositoryBuilder`2.GetConfig">
            <summary>Get the cached repository configuration, loading if not yet available.</summary>
            <remarks>Get the cached repository configuration, loading if not yet available.</remarks>
            <returns>the configuration of the repository.</returns>
            <exception cref="T:System.IO.IOException">the configuration is not available, or is badly formed.
            	</exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.BaseRepositoryBuilder`2.LoadConfig" -->
        <member name="M:NGit.BaseRepositoryBuilder`2.GuessWorkTreeOrFail">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.BaseRepositoryBuilder`2.SafeFS">
            <returns>
            the configured FS, or
            <see cref="F:NGit.Util.FS.DETECTED">NGit.Util.FS.DETECTED</see>
            .
            </returns>
        </member>
        <member name="M:NGit.BaseRepositoryBuilder`2.Self">
            <returns>
            
            <code>this</code>
            
            </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Ref" -->
        <member name="M:NGit.Ref.GetName">
            <summary>What this ref is called within the repository.</summary>
            <remarks>What this ref is called within the repository.</remarks>
            <returns>name of this ref.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Ref.IsSymbolic" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Ref.GetLeaf" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Ref.GetTarget" -->
        <member name="M:NGit.Ref.GetObjectId">
            <summary>Cached value of this ref.</summary>
            <remarks>Cached value of this ref.</remarks>
            <returns>the value of this ref at the last time we read it.</returns>
        </member>
        <member name="M:NGit.Ref.GetPeeledObjectId">
            <summary>Cached value of <code>ref^{}</code> (the ref peeled to commit).</summary>
            <remarks>Cached value of <code>ref^{}</code> (the ref peeled to commit).</remarks>
            <returns>
            if this ref is an annotated tag the id of the commit (or tree or
            blob) that the annotated tag refers to; null if this ref does not
            refer to an annotated tag.
            </returns>
        </member>
        <member name="M:NGit.Ref.IsPeeled">
            <returns>whether the Ref represents a peeled tag</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Ref.GetStorage" -->
        <member name="T:NGit.RefStorage">
            <summary>
            Location where a
            <see cref="T:NGit.Ref">Ref</see>
            is stored.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:NGit.RefStorage.NEW" -->
        <!-- Badly formed XML comment ignored for member "F:NGit.RefStorage.LOOSE" -->
        <!-- Badly formed XML comment ignored for member "F:NGit.RefStorage.PACKED" -->
        <!-- Badly formed XML comment ignored for member "F:NGit.RefStorage.LOOSE_PACKED" -->
        <!-- Badly formed XML comment ignored for member "F:NGit.RefStorage.NETWORK" -->
        <member name="M:NGit.RefStorage.IsLoose">
            <returns>true if this storage has a loose file.</returns>
        </member>
        <member name="M:NGit.RefStorage.IsPacked">
            <returns>true if this storage is inside the packed file.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Transport.BaseReceivePack" -->
        <member name="F:NGit.Transport.BaseReceivePack.db">
            <summary>Database we write the stored objects into.</summary>
            <remarks>Database we write the stored objects into.</remarks>
        </member>
        <member name="F:NGit.Transport.BaseReceivePack.walk">
            <summary>
            Revision traversal support over
            <see cref="F:NGit.Transport.BaseReceivePack.db">db</see>
            .
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:NGit.Transport.BaseReceivePack.biDirectionalPipe" -->
        <member name="F:NGit.Transport.BaseReceivePack.expectDataAfterPackFooter">
            <summary>Expecting data after the pack footer</summary>
        </member>
        <member name="F:NGit.Transport.BaseReceivePack.checkReceivedObjects">
            <summary>Should an incoming transfer validate objects?</summary>
        </member>
        <member name="F:NGit.Transport.BaseReceivePack.allowCreates">
            <summary>Should an incoming transfer permit create requests?</summary>
        </member>
        <member name="F:NGit.Transport.BaseReceivePack.allowDeletes">
            <summary>Should an incoming transfer permit delete requests?</summary>
        </member>
        <member name="F:NGit.Transport.BaseReceivePack.allowNonFastForwards">
            <summary>Should an incoming transfer permit non-fast-forward requests?</summary>
        </member>
        <member name="F:NGit.Transport.BaseReceivePack.refLogIdent">
            <summary>Identity to record action as within the reflog.</summary>
            <remarks>Identity to record action as within the reflog.</remarks>
        </member>
        <member name="F:NGit.Transport.BaseReceivePack.advertiseRefsHook">
            <summary>Hook used while advertising the refs to the client.</summary>
            <remarks>Hook used while advertising the refs to the client.</remarks>
        </member>
        <member name="F:NGit.Transport.BaseReceivePack.refFilter">
            <summary>Filter used while advertising the refs to the client.</summary>
            <remarks>Filter used while advertising the refs to the client.</remarks>
        </member>
        <member name="F:NGit.Transport.BaseReceivePack.timeout">
            <summary>Timeout in seconds to wait for client interaction.</summary>
            <remarks>Timeout in seconds to wait for client interaction.</remarks>
        </member>
        <member name="F:NGit.Transport.BaseReceivePack.timer">
            <summary>
            Timer to manage
            <see cref="F:NGit.Transport.BaseReceivePack.timeout">timeout</see>
            .
            </summary>
        </member>
        <member name="F:NGit.Transport.BaseReceivePack.rawIn">
            <summary>Raw input stream.</summary>
            <remarks>Raw input stream.</remarks>
        </member>
        <member name="F:NGit.Transport.BaseReceivePack.rawOut">
            <summary>Raw output stream.</summary>
            <remarks>Raw output stream.</remarks>
        </member>
        <member name="F:NGit.Transport.BaseReceivePack.msgOut">
            <summary>Optional message output stream.</summary>
            <remarks>Optional message output stream.</remarks>
        </member>
        <member name="F:NGit.Transport.BaseReceivePack.pckIn">
            <summary>
            Packet line input stream around
            <see cref="F:NGit.Transport.BaseReceivePack.rawIn">rawIn</see>
            .
            </summary>
        </member>
        <member name="F:NGit.Transport.BaseReceivePack.pckOut">
            <summary>
            Packet line output stream around
            <see cref="F:NGit.Transport.BaseReceivePack.rawOut">rawOut</see>
            .
            </summary>
        </member>
        <member name="F:NGit.Transport.BaseReceivePack.refs">
            <summary>The refs we advertised as existing at the start of the connection.</summary>
            <remarks>The refs we advertised as existing at the start of the connection.</remarks>
        </member>
        <member name="F:NGit.Transport.BaseReceivePack.advertisedHaves">
            <summary>All SHA-1s shown to the client, which can be possible edges.</summary>
            <remarks>All SHA-1s shown to the client, which can be possible edges.</remarks>
        </member>
        <member name="F:NGit.Transport.BaseReceivePack.enabledCapabilities">
            <summary>Capabilities requested by the client.</summary>
            <remarks>Capabilities requested by the client.</remarks>
        </member>
        <member name="F:NGit.Transport.BaseReceivePack.reportStatus">
            <summary>
            If
            <see cref="F:NGit.Transport.BasePackPushConnection.CAPABILITY_REPORT_STATUS">BasePackPushConnection.CAPABILITY_REPORT_STATUS
            	</see>
            is enabled.
            </summary>
        </member>
        <member name="F:NGit.Transport.BaseReceivePack.sideBand">
            <summary>
            If
            <see cref="F:NGit.Transport.BasePackPushConnection.CAPABILITY_SIDE_BAND_64K">BasePackPushConnection.CAPABILITY_SIDE_BAND_64K
            	</see>
            is enabled.
            </summary>
        </member>
        <member name="F:NGit.Transport.BaseReceivePack.packLock">
            <summary>Lock around the received pack file, while updating refs.</summary>
            <remarks>Lock around the received pack file, while updating refs.</remarks>
        </member>
        <member name="F:NGit.Transport.BaseReceivePack.maxObjectSizeLimit">
            <summary>Git object size limit</summary>
        </member>
        <member name="M:NGit.Transport.BaseReceivePack.#ctor(NGit.Repository)">
            <summary>Create a new pack receive for an open repository.</summary>
            <remarks>Create a new pack receive for an open repository.</remarks>
            <param name="into">the destination repository.</param>
        </member>
        <member name="M:NGit.Transport.BaseReceivePack.GetLockMessageProcessName">
            <returns>the process name used for pack lock messages.</returns>
        </member>
        <member name="M:NGit.Transport.BaseReceivePack.GetRepository">
            <returns>the repository this receive completes into.</returns>
        </member>
        <member name="M:NGit.Transport.BaseReceivePack.GetRevWalk">
            <returns>the RevWalk instance used by this connection.</returns>
        </member>
        <member name="M:NGit.Transport.BaseReceivePack.GetAdvertisedRefs">
            <summary>Get refs which were advertised to the client.</summary>
            <remarks>Get refs which were advertised to the client.</remarks>
            <returns>
            all refs which were advertised to the client, or null if
            <see cref="!:SetAdvertisedRefs(System.Collections.Generic.IDictionary&lt;K, V&gt;, System.Collections.Generic.ICollection&lt;E&gt;)&#xA;            	">SetAdvertisedRefs(System.Collections.Generic.IDictionary&lt;K, V&gt;, System.Collections.Generic.ICollection&lt;E&gt;)
            	</see>
            has not been called yet.
            </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Transport.BaseReceivePack.SetAdvertisedRefs(System.Collections.Generic.IDictionary{System.String,NGit.Ref},System.Collections.Generic.ICollection{NGit.ObjectId})" -->
        <member name="M:NGit.Transport.BaseReceivePack.GetAdvertisedObjects">
            <summary>Get objects advertised to the client.</summary>
            <remarks>Get objects advertised to the client.</remarks>
            <returns>
            the set of objects advertised to the as present in this repository,
            or null if
            <see cref="!:SetAdvertisedRefs(System.Collections.Generic.IDictionary&lt;K, V&gt;, System.Collections.Generic.ICollection&lt;E&gt;)&#xA;            	">SetAdvertisedRefs(System.Collections.Generic.IDictionary&lt;K, V&gt;, System.Collections.Generic.ICollection&lt;E&gt;)
            	</see>
            has not been called
            yet.
            </returns>
        </member>
        <member name="M:NGit.Transport.BaseReceivePack.IsCheckReferencedObjectsAreReachable">
            <returns>
            true if this instance will validate all referenced, but not
            supplied by the client, objects are reachable from another
            reference.
            </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Transport.BaseReceivePack.SetCheckReferencedObjectsAreReachable(System.Boolean)" -->
        <member name="M:NGit.Transport.BaseReceivePack.IsBiDirectionalPipe">
            <returns>
            true if this class expects a bi-directional pipe opened between
            the client and itself. The default is true.
            </returns>
        </member>
        <member name="M:NGit.Transport.BaseReceivePack.SetBiDirectionalPipe(System.Boolean)">
            <param name="twoWay">
            if true, this class will assume the socket is a fully
            bidirectional pipe between the two peers and takes advantage
            of that by first transmitting the known refs, then waiting to
            read commands. If false, this class assumes it must read the
            commands before writing output and does not perform the
            initial advertising.
            </param>
        </member>
        <member name="M:NGit.Transport.BaseReceivePack.IsExpectDataAfterPackFooter">
            <returns>true if there is data expected after the pack footer.</returns>
        </member>
        <member name="M:NGit.Transport.BaseReceivePack.SetExpectDataAfterPackFooter(System.Boolean)">
            <param name="e">true if there is additional data in InputStream after pack.</param>
        </member>
        <member name="M:NGit.Transport.BaseReceivePack.IsCheckReceivedObjects">
            <returns>
            true if this instance will verify received objects are formatted
            correctly. Validating objects requires more CPU time on this side
            of the connection.
            </returns>
        </member>
        <member name="M:NGit.Transport.BaseReceivePack.SetCheckReceivedObjects(System.Boolean)">
            <param name="check">
            true to enable checking received objects; false to assume all
            received objects are valid.
            </param>
        </member>
        <member name="M:NGit.Transport.BaseReceivePack.IsAllowCreates">
            <returns>true if the client can request refs to be created.</returns>
        </member>
        <member name="M:NGit.Transport.BaseReceivePack.SetAllowCreates(System.Boolean)">
            <param name="canCreate">true to permit create ref commands to be processed.</param>
        </member>
        <member name="M:NGit.Transport.BaseReceivePack.IsAllowDeletes">
            <returns>true if the client can request refs to be deleted.</returns>
        </member>
        <member name="M:NGit.Transport.BaseReceivePack.SetAllowDeletes(System.Boolean)">
            <param name="canDelete">true to permit delete ref commands to be processed.</param>
        </member>
        <member name="M:NGit.Transport.BaseReceivePack.IsAllowNonFastForwards">
            <returns>
            true if the client can request non-fast-forward updates of a ref,
            possibly making objects unreachable.
            </returns>
        </member>
        <member name="M:NGit.Transport.BaseReceivePack.SetAllowNonFastForwards(System.Boolean)">
            <param name="canRewind">
            true to permit the client to ask for non-fast-forward updates
            of an existing ref.
            </param>
        </member>
        <member name="M:NGit.Transport.BaseReceivePack.GetRefLogIdent">
            <returns>identity of the user making the changes in the reflog.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Transport.BaseReceivePack.SetRefLogIdent(NGit.PersonIdent)" -->
        <member name="M:NGit.Transport.BaseReceivePack.GetAdvertiseRefsHook">
            <returns>the hook used while advertising the refs to the client</returns>
        </member>
        <member name="M:NGit.Transport.BaseReceivePack.GetRefFilter">
            <returns>the filter used while advertising the refs to the client</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Transport.BaseReceivePack.SetAdvertiseRefsHook(NGit.Transport.AdvertiseRefsHook)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Transport.BaseReceivePack.SetRefFilter(NGit.Transport.RefFilter)" -->
        <member name="M:NGit.Transport.BaseReceivePack.GetTimeout">
            <returns>timeout (in seconds) before aborting an IO operation.</returns>
        </member>
        <member name="M:NGit.Transport.BaseReceivePack.SetTimeout(System.Int32)">
            <summary>Set the timeout before willing to abort an IO call.</summary>
            <remarks>Set the timeout before willing to abort an IO call.</remarks>
            <param name="seconds">
            number of seconds to wait (with no data transfer occurring)
            before aborting an IO read or write operation with the
            connected client.
            </param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Transport.BaseReceivePack.SetMaxObjectSizeLimit(System.Int64)" -->
        <member name="M:NGit.Transport.BaseReceivePack.IsSideBand">
            <summary>Check whether the client expects a side-band stream.</summary>
            <remarks>Check whether the client expects a side-band stream.</remarks>
            <returns>
            true if the client has advertised a side-band capability, false
            otherwise.
            </returns>
            <exception cref="T:NGit.Transport.RequestNotYetReadException">
            if the client's request has not yet been read from the wire, so
            we do not know if they expect side-band. Note that the client
            may have already written the request, it just has not been
            read.
            </exception>
            <exception cref="T:NGit.Transport.RequestNotYetReadException"></exception>
        </member>
        <member name="M:NGit.Transport.BaseReceivePack.GetAllCommands">
            <returns>all of the command received by the current request.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Transport.BaseReceivePack.SendError(System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Transport.BaseReceivePack.SendMessage(System.String)" -->
        <member name="M:NGit.Transport.BaseReceivePack.GetMessageOutputStream">
            <returns>an underlying stream for sending messages to the client.</returns>
        </member>
        <member name="M:NGit.Transport.BaseReceivePack.HasCommands">
            <returns>true if any commands to be executed have been read.</returns>
        </member>
        <member name="M:NGit.Transport.BaseReceivePack.HasError">
            <returns>true if an error occurred that should be advertised.</returns>
        </member>
        <member name="M:NGit.Transport.BaseReceivePack.Init(Sharpen.InputStream,Sharpen.OutputStream,Sharpen.OutputStream)">
            <summary>Initialize the instance with the given streams.</summary>
            <remarks>Initialize the instance with the given streams.</remarks>
            <param name="input">
            raw input to read client commands and pack data from. Caller
            must ensure the input is buffered, otherwise read performance
            may suffer.
            </param>
            <param name="output">
            response back to the Git network client. Caller must ensure
            the output is buffered, otherwise write performance may
            suffer.
            </param>
            <param name="messages">
            secondary "notice" channel to send additional messages out
            through. When run over SSH this should be tied back to the
            standard error channel of the command execution. For most
            other network connections this should be null.
            </param>
        </member>
        <member name="M:NGit.Transport.BaseReceivePack.GetAdvertisedOrDefaultRefs">
            <returns>advertised refs, or the default if not explicitly advertised.</returns>
        </member>
        <member name="M:NGit.Transport.BaseReceivePack.ReceivePackAndCheckConnectivity">
            <summary>Receive a pack from the stream and check connectivity if necessary.</summary>
            <remarks>Receive a pack from the stream and check connectivity if necessary.</remarks>
            <exception cref="T:System.IO.IOException">an error occurred during unpacking or connectivity checking.
            	</exception>
        </member>
        <member name="M:NGit.Transport.BaseReceivePack.UnlockPack">
            <summary>Unlock the pack written by this object.</summary>
            <remarks>Unlock the pack written by this object.</remarks>
            <exception cref="T:System.IO.IOException">the pack could not be unlocked.</exception>
        </member>
        <member name="M:NGit.Transport.BaseReceivePack.SendAdvertisedRefs(NGit.Transport.RefAdvertiser)">
            <summary>Generate an advertisement of available refs and capabilities.</summary>
            <remarks>Generate an advertisement of available refs and capabilities.</remarks>
            <param name="adv">the advertisement formatter.</param>
            <exception cref="T:System.IO.IOException">the formatter failed to write an advertisement.
            	</exception>
            <exception cref="T:NGit.Transport.ServiceMayNotContinueException">the hook denied advertisement.</exception>
            <exception cref="T:NGit.Transport.ServiceMayNotContinueException"></exception>
        </member>
        <member name="M:NGit.Transport.BaseReceivePack.RecvCommands">
            <summary>Receive a list of commands from the input.</summary>
            <remarks>Receive a list of commands from the input.</remarks>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:NGit.Transport.BaseReceivePack.EnableCapabilities">
            <summary>Enable capabilities based on a previously read capabilities line.</summary>
            <remarks>Enable capabilities based on a previously read capabilities line.</remarks>
        </member>
        <member name="M:NGit.Transport.BaseReceivePack.NeedPack">
            <returns>true if a pack is expected based on the list of commands.</returns>
        </member>
        <member name="M:NGit.Transport.BaseReceivePack.ReceivePack">
            <summary>Receive a pack from the input and store it in the repository.</summary>
            <remarks>Receive a pack from the input and store it in the repository.</remarks>
            <exception cref="T:System.IO.IOException">an error occurred reading or indexing the pack.
            	</exception>
        </member>
        <member name="M:NGit.Transport.BaseReceivePack.CheckConnectivity">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Transport.BaseReceivePack.ValidateCommands">
            <summary>Validate the command list.</summary>
            <remarks>Validate the command list.</remarks>
        </member>
        <member name="M:NGit.Transport.BaseReceivePack.FilterCommands(NGit.Transport.ReceiveCommand.Result)">
            <summary>Filter the list of commands according to result.</summary>
            <remarks>Filter the list of commands according to result.</remarks>
            <param name="want">desired status to filter by.</param>
            <returns>
            a copy of the command list containing only those commands with the
            desired status.
            </returns>
        </member>
        <member name="M:NGit.Transport.BaseReceivePack.ExecuteCommands">
            <summary>Execute commands to update references.</summary>
            <remarks>Execute commands to update references.</remarks>
        </member>
        <member name="M:NGit.Transport.BaseReceivePack.SendStatusReport(System.Boolean,System.Exception,NGit.Transport.BaseReceivePack.Reporter)">
            <summary>Send a status report.</summary>
            <remarks>Send a status report.</remarks>
            <param name="forClient">
            true if this report is for a Git client, false if it is for an
            end-user.
            </param>
            <param name="unpackError">
            an error that occurred during unpacking, or
            <code>null</code>
            </param>
            <param name="out">the reporter for sending the status strings.</param>
            <exception cref="T:System.IO.IOException">an error occurred writing the status report.
            	</exception>
        </member>
        <member name="M:NGit.Transport.BaseReceivePack.Close">
            <summary>Close and flush (if necessary) the underlying streams.</summary>
            <remarks>Close and flush (if necessary) the underlying streams.</remarks>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:NGit.Transport.BaseReceivePack.Release">
            <summary>Release any resources used by this object.</summary>
            <remarks>Release any resources used by this object.</remarks>
            <exception cref="T:System.IO.IOException">the pack could not be unlocked.</exception>
        </member>
        <member name="T:NGit.Transport.BaseReceivePack.FirstLine">
            <summary>Data in the first line of a request, the line itself plus capabilities.</summary>
            <remarks>Data in the first line of a request, the line itself plus capabilities.</remarks>
        </member>
        <member name="M:NGit.Transport.BaseReceivePack.FirstLine.#ctor(System.String)">
            <summary>Parse the first line of a receive-pack request.</summary>
            <remarks>Parse the first line of a receive-pack request.</remarks>
            <param name="line">line from the client.</param>
        </member>
        <member name="M:NGit.Transport.BaseReceivePack.FirstLine.GetLine">
            <returns>non-capabilities part of the line.</returns>
        </member>
        <member name="M:NGit.Transport.BaseReceivePack.FirstLine.GetCapabilities">
            <returns>capabilities parsed from the line.</returns>
        </member>
        <member name="T:NGit.Transport.BaseReceivePack.ReceiveConfig">
            <summary>Configuration for receive operations.</summary>
            <remarks>Configuration for receive operations.</remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Transport.BaseReceivePack.MessageOutputWrapper" -->
        <member name="T:NGit.Transport.BaseReceivePack.Reporter">
            <summary>Interface for reporting status messages.</summary>
            <remarks>Interface for reporting status messages.</remarks>
        </member>
        <member name="M:NGit.Transport.BaseReceivePack.Reporter.SendString(System.String)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="T:NGit.Api.ApplyResult">
            <summary>
            Encapsulates the result of a
            <see cref="T:NGit.Api.ApplyCommand">ApplyCommand</see>
            </summary>
            <since>2.0</since>
        </member>
        <member name="M:NGit.Api.ApplyResult.AddUpdatedFile(Sharpen.FilePath)">
            <param name="f">an updated file</param>
            <returns>this instance</returns>
        </member>
        <member name="M:NGit.Api.ApplyResult.GetUpdatedFiles">
            <returns>updated files</returns>
        </member>
        <member name="T:NGit.Submodule.SubmoduleWalk">
            <summary>Walker that visits all submodule entries found in a tree</summary>
        </member>
        <member name="M:NGit.Submodule.SubmoduleWalk.ForIndex(NGit.Repository)">
            <summary>
            Create a generator to walk over the submodule entries currently in the
            index
            The
            <code>.gitmodules</code>
            file is read from the index.
            </summary>
            <param name="repository"></param>
            <returns>generator over submodule index entries</returns>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:NGit.Submodule.SubmoduleWalk.ForPath(NGit.Repository,NGit.AnyObjectId,System.String)">
            <summary>
            Create a generator and advance it to the submodule entry at the given
            path
            </summary>
            <param name="repository"></param>
            <param name="treeId">
            the root of a tree containing both a submodule at the given path
            and .gitmodules at the root.
            </param>
            <param name="path"></param>
            <returns>generator at given path, null if no submodule at given path</returns>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:NGit.Submodule.SubmoduleWalk.ForPath(NGit.Repository,NGit.Treewalk.AbstractTreeIterator,System.String)">
            <summary>
            Create a generator and advance it to the submodule entry at the given
            path
            </summary>
            <param name="repository"></param>
            <param name="iterator">
            the root of a tree containing both a submodule at the given path
            and .gitmodules at the root.
            </param>
            <param name="path"></param>
            <returns>generator at given path, null if no submodule at given path</returns>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:NGit.Submodule.SubmoduleWalk.GetSubmoduleDirectory(NGit.Repository,System.String)">
            <summary>Get submodule directory</summary>
            <param name="parent"></param>
            <param name="path"></param>
            <returns>directory</returns>
        </member>
        <member name="M:NGit.Submodule.SubmoduleWalk.GetSubmoduleRepository(NGit.Repository,System.String)">
            <summary>Get submodule repository</summary>
            <param name="parent"></param>
            <param name="path"></param>
            <returns>repository or null if repository doesn't exist</returns>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:NGit.Submodule.SubmoduleWalk.GetSubmoduleRepository(Sharpen.FilePath,System.String)">
            <summary>Get submodule repository at path</summary>
            <param name="parent"></param>
            <param name="path"></param>
            <returns>repository or null if repository doesn't exist</returns>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Submodule.SubmoduleWalk.GetSubmoduleRemoteUrl(NGit.Repository,System.String)" -->
        <member name="M:NGit.Submodule.SubmoduleWalk.#ctor(NGit.Repository)">
            <summary>Create submodule generator</summary>
            <param name="repository"></param>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:NGit.Submodule.SubmoduleWalk.SetModulesConfig(NGit.Config)">
            <summary>Set the config used by this walk.</summary>
            <remarks>
            Set the config used by this walk.
            This method need only be called if constructing a walk manually instead of
            with one of the static factory methods above.
            </remarks>
            <param name="config">.gitmodules config object</param>
            <returns>this generator</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Submodule.SubmoduleWalk.SetRootTree(NGit.Treewalk.AbstractTreeIterator)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Submodule.SubmoduleWalk.SetRootTree(NGit.AnyObjectId)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Submodule.SubmoduleWalk.LoadModulesConfig" -->
        <member name="M:NGit.Submodule.SubmoduleWalk.LazyLoadModulesConfig">
            <exception cref="T:System.IO.IOException"></exception>
            <exception cref="T:NGit.Errors.ConfigInvalidException"></exception>
        </member>
        <member name="M:NGit.Submodule.SubmoduleWalk.SetFilter(NGit.Treewalk.Filter.TreeFilter)">
            <summary>Set tree filter</summary>
            <param name="filter"></param>
            <returns>this generator</returns>
        </member>
        <member name="M:NGit.Submodule.SubmoduleWalk.SetTree(NGit.Treewalk.AbstractTreeIterator)">
            <summary>Set the tree iterator used for finding submodule entries</summary>
            <param name="iterator"></param>
            <returns>this generator</returns>
            <exception cref="T:NGit.Errors.CorruptObjectException">NGit.Errors.CorruptObjectException
            	</exception>
        </member>
        <member name="M:NGit.Submodule.SubmoduleWalk.SetTree(NGit.AnyObjectId)">
            <summary>Set the tree used for finding submodule entries</summary>
            <param name="treeId"></param>
            <returns>this generator</returns>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
            <exception cref="T:NGit.Errors.IncorrectObjectTypeException">NGit.Errors.IncorrectObjectTypeException
            	</exception>
            <exception cref="T:NGit.Errors.MissingObjectException">NGit.Errors.MissingObjectException
            	</exception>
        </member>
        <member name="M:NGit.Submodule.SubmoduleWalk.Reset">
            <summary>Reset generator and start new submodule walk</summary>
            <returns>this generator</returns>
        </member>
        <member name="M:NGit.Submodule.SubmoduleWalk.GetDirectory">
            <summary>Get directory that will be the root of the submodule's local repository</summary>
            <returns>submodule repository directory</returns>
        </member>
        <member name="M:NGit.Submodule.SubmoduleWalk.Next">
            <summary>Advance to next submodule in the index tree.</summary>
            <remarks>
            Advance to next submodule in the index tree.
            The object id and path of the next entry can be obtained by calling
            <see cref="M:NGit.Submodule.SubmoduleWalk.GetObjectId">GetObjectId()</see>
            and
            <see cref="M:NGit.Submodule.SubmoduleWalk.GetPath">GetPath()</see>
            .
            </remarks>
            <returns>true if entry found, false otherwise</returns>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:NGit.Submodule.SubmoduleWalk.GetPath">
            <summary>Get path of current submodule entry</summary>
            <returns>path</returns>
        </member>
        <member name="M:NGit.Submodule.SubmoduleWalk.GetObjectId">
            <summary>Get object id of current submodule entry</summary>
            <returns>object id</returns>
        </member>
        <member name="M:NGit.Submodule.SubmoduleWalk.GetModulesPath">
            <summary>Get the configured path for current entry.</summary>
            <remarks>
            Get the configured path for current entry. This will be the value from
            the .gitmodules file in the current repository's working tree.
            </remarks>
            <returns>configured path</returns>
            <exception cref="T:NGit.Errors.ConfigInvalidException">NGit.Errors.ConfigInvalidException
            	</exception>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:NGit.Submodule.SubmoduleWalk.GetConfigUrl">
            <summary>Get the configured remote URL for current entry.</summary>
            <remarks>
            Get the configured remote URL for current entry. This will be the value
            from the repository's config.
            </remarks>
            <returns>configured URL</returns>
            <exception cref="T:NGit.Errors.ConfigInvalidException">NGit.Errors.ConfigInvalidException
            	</exception>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:NGit.Submodule.SubmoduleWalk.GetModulesUrl">
            <summary>Get the configured remote URL for current entry.</summary>
            <remarks>
            Get the configured remote URL for current entry. This will be the value
            from the .gitmodules file in the current repository's working tree.
            </remarks>
            <returns>configured URL</returns>
            <exception cref="T:NGit.Errors.ConfigInvalidException">NGit.Errors.ConfigInvalidException
            	</exception>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:NGit.Submodule.SubmoduleWalk.GetConfigUpdate">
            <summary>Get the configured update field for current entry.</summary>
            <remarks>
            Get the configured update field for current entry. This will be the value
            from the repository's config.
            </remarks>
            <returns>update value</returns>
            <exception cref="T:NGit.Errors.ConfigInvalidException">NGit.Errors.ConfigInvalidException
            	</exception>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:NGit.Submodule.SubmoduleWalk.GetModulesUpdate">
            <summary>Get the configured update field for current entry.</summary>
            <remarks>
            Get the configured update field for current entry. This will be the value
            from the .gitmodules file in the current repository's working tree.
            </remarks>
            <returns>update value</returns>
            <exception cref="T:NGit.Errors.ConfigInvalidException">NGit.Errors.ConfigInvalidException
            	</exception>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:NGit.Submodule.SubmoduleWalk.GetRepository">
            <summary>Get repository for current submodule entry</summary>
            <returns>repository or null if non-existent</returns>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:NGit.Submodule.SubmoduleWalk.GetHead">
            <summary>Get commit id that HEAD points to in the current submodule's repository</summary>
            <returns>object id of HEAD reference</returns>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:NGit.Submodule.SubmoduleWalk.GetHeadRef">
            <summary>Get ref that HEAD points to in the current submodule's repository</summary>
            <returns>ref name, null on failures</returns>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Submodule.SubmoduleWalk.GetRemoteUrl" -->
        <member name="M:NGit.Submodule.SubmoduleWalk.Release">
            <summary>Release any resources used by this walker's reader.</summary>
            <remarks>Release any resources used by this walker's reader.</remarks>
        </member>
        <member name="T:NGit.Submodule.SubmoduleStatusType">
            <summary>Enumeration of different statuses that a submodule can be in</summary>
        </member>
        <member name="T:NGit.Storage.File.CheckoutEntry">
            <summary>Parsed information about a checkout.</summary>
            <remarks>Parsed information about a checkout.</remarks>
        </member>
        <member name="M:NGit.Storage.File.CheckoutEntry.GetFromBranch">
            <returns>the name of the branch before checkout</returns>
        </member>
        <member name="M:NGit.Storage.File.CheckoutEntry.GetToBranch">
            <returns>the name of the branch after checkout</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Blame.BlameResult" -->
        <member name="M:NGit.Blame.BlameResult.Create(NGit.Blame.BlameGenerator)">
            <summary>Construct a new BlameResult for a generator.</summary>
            <remarks>Construct a new BlameResult for a generator.</remarks>
            <param name="gen">the generator the result will consume records from.</param>
            <returns>
            the new result object. null if the generator cannot find the path
            it starts from.
            </returns>
            <exception cref="T:System.IO.IOException">the repository cannot be read.</exception>
        </member>
        <member name="F:NGit.Blame.BlameResult.sourceLines">
            <summary>Warning: these are actually 1-based.</summary>
            <remarks>Warning: these are actually 1-based.</remarks>
        </member>
        <member name="M:NGit.Blame.BlameResult.GetResultPath">
            <returns>path of the file this result annotates.</returns>
        </member>
        <member name="M:NGit.Blame.BlameResult.GetResultContents">
            <returns>contents of the result file, available for display.</returns>
        </member>
        <member name="M:NGit.Blame.BlameResult.DiscardResultContents">
            <summary>
            Throw away the
            <see cref="M:NGit.Blame.BlameResult.GetResultContents">GetResultContents()</see>
            .
            </summary>
        </member>
        <member name="M:NGit.Blame.BlameResult.HasSourceData(System.Int32)">
            <summary>Check if the given result line has been annotated yet.</summary>
            <remarks>Check if the given result line has been annotated yet.</remarks>
            <param name="idx">line to read data of, 0 based.</param>
            <returns>true if the data has been annotated, false otherwise.</returns>
        </member>
        <member name="M:NGit.Blame.BlameResult.HasSourceData(System.Int32,System.Int32)">
            <summary>Check if the given result line has been annotated yet.</summary>
            <remarks>Check if the given result line has been annotated yet.</remarks>
            <param name="start">first index to examine.</param>
            <param name="end">last index to examine.</param>
            <returns>true if the data has been annotated, false otherwise.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Blame.BlameResult.GetSourceCommit(System.Int32)" -->
        <member name="M:NGit.Blame.BlameResult.GetSourceAuthor(System.Int32)">
            <summary>Get the author that provided the specified line of the result.</summary>
            <remarks>Get the author that provided the specified line of the result.</remarks>
            <param name="idx">line to read data of, 0 based.</param>
            <returns>
            author that provided line
            <code>idx</code>
            . May be null.
            </returns>
        </member>
        <member name="M:NGit.Blame.BlameResult.GetSourceCommitter(System.Int32)">
            <summary>Get the committer that provided the specified line of the result.</summary>
            <remarks>Get the committer that provided the specified line of the result.</remarks>
            <param name="idx">line to read data of, 0 based.</param>
            <returns>
            committer that provided line
            <code>idx</code>
            . May be null.
            </returns>
        </member>
        <member name="M:NGit.Blame.BlameResult.GetSourcePath(System.Int32)">
            <summary>Get the file path that provided the specified line of the result.</summary>
            <remarks>Get the file path that provided the specified line of the result.</remarks>
            <param name="idx">line to read data of, 0 based.</param>
            <returns>
            source file path that provided line
            <code>idx</code>
            .
            </returns>
        </member>
        <member name="M:NGit.Blame.BlameResult.GetSourceLine(System.Int32)">
            <summary>Get the corresponding line number in the source file.</summary>
            <remarks>Get the corresponding line number in the source file.</remarks>
            <param name="idx">line to read data of, 0 based.</param>
            <returns>matching line number in the source file.</returns>
        </member>
        <member name="M:NGit.Blame.BlameResult.ComputeAll">
            <summary>Compute all pending information.</summary>
            <remarks>Compute all pending information.</remarks>
            <exception cref="T:System.IO.IOException">the repository cannot be read.</exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Blame.BlameResult.ComputeNext" -->
        <member name="M:NGit.Blame.BlameResult.LastLength">
            <returns>
            length of the last segment found by
            <see cref="M:NGit.Blame.BlameResult.ComputeNext">ComputeNext()</see>
            .
            </returns>
        </member>
        <member name="M:NGit.Blame.BlameResult.ComputeRange(System.Int32,System.Int32)">
            <summary>Compute until the entire range has been populated.</summary>
            <remarks>Compute until the entire range has been populated.</remarks>
            <param name="start">first index to examine.</param>
            <param name="end">last index to examine.</param>
            <exception cref="T:System.IO.IOException">the repository cannot be read.</exception>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Util.BlockList`1" -->
        <member name="M:NGit.Util.BlockList`1.#ctor">
            <summary>Initialize an empty list.</summary>
            <remarks>Initialize an empty list.</remarks>
        </member>
        <member name="M:NGit.Util.BlockList`1.#ctor(System.Int32)">
            <summary>Initialize an empty list with an expected capacity.</summary>
            <remarks>Initialize an empty list with an expected capacity.</remarks>
            <param name="capacity">number of elements expected to be in the list.</param>
        </member>
        <member name="M:NGit.Util.BlockList`1.AddAll(NGit.Util.BlockList{`0})">
            <summary>Quickly append all elements of another BlockList.</summary>
            <remarks>Quickly append all elements of another BlockList.</remarks>
            <param name="src">the list to copy elements from.</param>
        </member>
        <member name="M:NGit.Util.BlockList`1.AddAll(`0[],System.Int32,System.Int32)">
            <summary>Quickly append all elements from an array.</summary>
            <remarks>Quickly append all elements from an array.</remarks>
            <param name="src">the source array.</param>
            <param name="srcIdx">first index to copy.</param>
            <param name="srcCnt">number of elements to copy.</param>
        </member>
        <member name="T:NGit.Notes.NoteParser">
            <summary>Custom tree parser to select note bucket type and load it.</summary>
            <remarks>Custom tree parser to select note bucket type and load it.</remarks>
        </member>
        <member name="T:NGit.Treewalk.CanonicalTreeParser">
            <summary>Parses raw Git trees from the canonical semi-text/semi-binary format.</summary>
            <remarks>Parses raw Git trees from the canonical semi-text/semi-binary format.</remarks>
        </member>
        <member name="F:NGit.Treewalk.CanonicalTreeParser.prevPtr">
            <summary>
            First offset within
            <see cref="F:NGit.Treewalk.CanonicalTreeParser.raw">raw</see>
            of the prior entry.
            </summary>
        </member>
        <member name="F:NGit.Treewalk.CanonicalTreeParser.currPtr">
            <summary>
            First offset within
            <see cref="F:NGit.Treewalk.CanonicalTreeParser.raw">raw</see>
            of the current entry's data.
            </summary>
        </member>
        <member name="F:NGit.Treewalk.CanonicalTreeParser.nextPtr">
            <summary>Offset one past the current entry (first byte of next entry).</summary>
            <remarks>Offset one past the current entry (first byte of next entry).</remarks>
        </member>
        <member name="M:NGit.Treewalk.CanonicalTreeParser.#ctor">
            <summary>Create a new parser.</summary>
            <remarks>Create a new parser.</remarks>
        </member>
        <member name="M:NGit.Treewalk.CanonicalTreeParser.#ctor(System.Byte[],NGit.ObjectReader,NGit.AnyObjectId)">
            <summary>Create a new parser for a tree appearing in a subset of a repository.</summary>
            <remarks>Create a new parser for a tree appearing in a subset of a repository.</remarks>
            <param name="prefix">
            position of this iterator in the repository tree. The value
            may be null or the empty array to indicate the prefix is the
            root of the repository. A trailing slash ('/') is
            automatically appended if the prefix does not end in '/'.
            </param>
            <param name="reader">reader to load the tree data from.</param>
            <param name="treeId">
            identity of the tree being parsed; used only in exception
            messages if data corruption is found.
            </param>
            <exception cref="T:NGit.Errors.MissingObjectException">the object supplied is not available from the repository.
            	</exception>
            <exception cref="T:NGit.Errors.IncorrectObjectTypeException">
            the object supplied as an argument is not actually a tree and
            cannot be parsed as though it were a tree.
            </exception>
            <exception cref="T:System.IO.IOException">a loose object or pack file could not be read.
            	</exception>
        </member>
        <member name="M:NGit.Treewalk.CanonicalTreeParser.GetParent">
            <returns>the parent of this tree parser</returns>
            <internal></internal>
        </member>
        <member name="M:NGit.Treewalk.CanonicalTreeParser.Reset(System.Byte[])">
            <summary>Reset this parser to walk through the given tree data.</summary>
            <remarks>Reset this parser to walk through the given tree data.</remarks>
            <param name="treeData">the raw tree content.</param>
        </member>
        <member name="M:NGit.Treewalk.CanonicalTreeParser.ResetRoot(NGit.ObjectReader,NGit.AnyObjectId)">
            <summary>Reset this parser to walk through the given tree.</summary>
            <remarks>Reset this parser to walk through the given tree.</remarks>
            <param name="reader">reader to use during repository access.</param>
            <param name="id">
            identity of the tree being parsed; used only in exception
            messages if data corruption is found.
            </param>
            <returns>the root level parser.</returns>
            <exception cref="T:NGit.Errors.MissingObjectException">the object supplied is not available from the repository.
            	</exception>
            <exception cref="T:NGit.Errors.IncorrectObjectTypeException">
            the object supplied as an argument is not actually a tree and
            cannot be parsed as though it were a tree.
            </exception>
            <exception cref="T:System.IO.IOException">a loose object or pack file could not be read.
            	</exception>
        </member>
        <member name="M:NGit.Treewalk.CanonicalTreeParser.Next">
            <returns>this iterator, or its parent, if the tree is at eof.</returns>
        </member>
        <member name="M:NGit.Treewalk.CanonicalTreeParser.Reset(NGit.ObjectReader,NGit.AnyObjectId)">
            <summary>Reset this parser to walk through the given tree.</summary>
            <remarks>Reset this parser to walk through the given tree.</remarks>
            <param name="reader">reader to use during repository access.</param>
            <param name="id">
            identity of the tree being parsed; used only in exception
            messages if data corruption is found.
            </param>
            <exception cref="T:NGit.Errors.MissingObjectException">the object supplied is not available from the repository.
            	</exception>
            <exception cref="T:NGit.Errors.IncorrectObjectTypeException">
            the object supplied as an argument is not actually a tree and
            cannot be parsed as though it were a tree.
            </exception>
            <exception cref="T:System.IO.IOException">a loose object or pack file could not be read.
            	</exception>
        </member>
        <member name="M:NGit.Treewalk.CanonicalTreeParser.CreateSubtreeIterator(NGit.ObjectReader,NGit.MutableObjectId)">
            <exception cref="T:NGit.Errors.IncorrectObjectTypeException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Treewalk.CanonicalTreeParser.CreateSubtreeIterator0(NGit.ObjectReader,NGit.AnyObjectId)" -->
        <member name="M:NGit.Treewalk.CanonicalTreeParser.CreateSubtreeIterator(NGit.ObjectReader)">
            <exception cref="T:NGit.Errors.IncorrectObjectTypeException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Notes.NoteParser.Parse(NGit.AbbreviatedObjectId,NGit.ObjectId,NGit.ObjectReader)">
            <summary>
            Parse a tree object into a
            <see cref="T:NGit.Notes.NoteBucket">NoteBucket</see>
            instance.
            The type of note tree is automatically detected by examining the items
            within the tree, and allocating the proper storage type based on the
            first note-like entry encountered. Since the method parses by guessing
            the type on the first element, malformed note trees can be read as the
            wrong type of tree.
            This method is not recursive, it parses the one tree given to it and
            returns the bucket. If there are subtrees for note storage, they are
            setup as lazy pointers that will be resolved at a later time.
            </summary>
            <param name="prefix">
            common hex digits that all notes within this tree share. The
            root tree has
            <code>prefix.length() == 0</code>
            , the first-level
            subtrees should be
            <code>prefix.length()==2</code>
            , etc.
            </param>
            <param name="treeId">the tree to read from the repository.</param>
            <param name="reader">reader to access the tree object.</param>
            <returns>bucket to holding the notes of the specified tree.</returns>
            <exception cref="T:System.IO.IOException">
            <code>treeId</code>
            cannot be accessed.
            </exception>
        </member>
        <member name="M:NGit.Notes.NoteParser.#ctor(NGit.AbbreviatedObjectId,NGit.ObjectReader,NGit.ObjectId)">
            <exception cref="T:NGit.Errors.IncorrectObjectTypeException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="T:NGit.Transport.UsernamePasswordCredentialsProvider">
            <summary>
            Simple
            <see cref="T:NGit.Transport.CredentialsProvider">CredentialsProvider</see>
            that always uses the same information.
            </summary>
        </member>
        <member name="T:NGit.Transport.CredentialsProvider">
            <summary>Provide credentials for use in connecting to Git repositories.</summary>
            <remarks>
            Provide credentials for use in connecting to Git repositories.
            Implementors are strongly encouraged to support at least the minimal
            <see cref="!:Username">Username</see>
            and
            <see cref="!:Password">Password</see>
            items.
            More sophisticated implementors may implement additional types, such as
            <see cref="!:StringType">StringType</see>
            .
            CredentialItems are usually presented in bulk, allowing implementors to
            combine them into a single UI widget and streamline the authentication
            process for an end-user.
            </remarks>
            <seealso cref="T:NGit.Transport.UsernamePasswordCredentialsProvider">UsernamePasswordCredentialsProvider
            	</seealso>
        </member>
        <member name="M:NGit.Transport.CredentialsProvider.GetDefault">
            <returns>the default credentials provider, or null.</returns>
        </member>
        <member name="M:NGit.Transport.CredentialsProvider.SetDefault(NGit.Transport.CredentialsProvider)">
            <summary>Set the default credentials provider.</summary>
            <remarks>Set the default credentials provider.</remarks>
            <param name="p">the new default provider, may be null to select no default.</param>
        </member>
        <member name="M:NGit.Transport.CredentialsProvider.IsInteractive">
            <summary>Check if the provider is interactive with the end-user.</summary>
            <remarks>
            Check if the provider is interactive with the end-user.
            An interactive provider may try to open a dialog box, or prompt for input
            on the terminal, and will wait for a user response. A non-interactive
            provider will either populate CredentialItems, or fail.
            </remarks>
            <returns>
            
            <code>true</code>
            if the provider is interactive with the end-user.
            </returns>
        </member>
        <member name="M:NGit.Transport.CredentialsProvider.Supports(NGit.Transport.CredentialItem[])">
            <summary>
            Check if the provider can supply the necessary
            <see cref="T:NGit.Transport.CredentialItem">CredentialItem</see>
            s.
            </summary>
            <param name="items">the items the application requires to complete authentication.
            	</param>
            <returns>
            
            <code>true</code>
            if this
            <see cref="T:NGit.Transport.CredentialsProvider">CredentialsProvider</see>
            supports all of
            the items supplied.
            </returns>
        </member>
        <member name="M:NGit.Transport.CredentialsProvider.Get(NGit.Transport.URIish,NGit.Transport.CredentialItem[])">
            <summary>Ask for the credential items to be populated.</summary>
            <remarks>Ask for the credential items to be populated.</remarks>
            <param name="uri">the URI of the remote resource that needs authentication.</param>
            <param name="items">the items the application requires to complete authentication.
            	</param>
            <returns>
            
            <code>true</code>
            if the request was successful and values were
            supplied;
            <code>false</code>
            if the user canceled the request and did
            not supply all requested values.
            </returns>
            <exception cref="T:NGit.Errors.UnsupportedCredentialItem">if one of the items supplied is not supported.
            	</exception>
        </member>
        <member name="M:NGit.Transport.CredentialsProvider.Get(NGit.Transport.URIish,System.Collections.Generic.IList{NGit.Transport.CredentialItem})">
            <summary>Ask for the credential items to be populated.</summary>
            <remarks>Ask for the credential items to be populated.</remarks>
            <param name="uri">the URI of the remote resource that needs authentication.</param>
            <param name="items">the items the application requires to complete authentication.
            	</param>
            <returns>
            
            <code>true</code>
            if the request was successful and values were
            supplied;
            <code>false</code>
            if the user canceled the request and did
            not supply all requested values.
            </returns>
            <exception cref="T:NGit.Errors.UnsupportedCredentialItem">if one of the items supplied is not supported.
            	</exception>
        </member>
        <member name="M:NGit.Transport.CredentialsProvider.Reset(NGit.Transport.URIish)">
            <summary>Reset the credentials provider for the given URI</summary>
            <param name="uri"></param>
        </member>
        <member name="M:NGit.Transport.UsernamePasswordCredentialsProvider.#ctor(System.String,System.String)">
            <summary>Initialize the provider with a single username and password.</summary>
            <remarks>Initialize the provider with a single username and password.</remarks>
            <param name="username"></param>
            <param name="password"></param>
        </member>
        <member name="M:NGit.Transport.UsernamePasswordCredentialsProvider.#ctor(System.String,System.Char[])">
            <summary>Initialize the provider with a single username and password.</summary>
            <remarks>Initialize the provider with a single username and password.</remarks>
            <param name="username"></param>
            <param name="password"></param>
        </member>
        <member name="M:NGit.Transport.UsernamePasswordCredentialsProvider.Get(NGit.Transport.URIish,NGit.Transport.CredentialItem[])">
            <exception cref="T:NGit.Errors.UnsupportedCredentialItem"></exception>
        </member>
        <member name="M:NGit.Transport.UsernamePasswordCredentialsProvider.Clear">
            <summary>Destroy the saved username and password..</summary>
            <remarks>Destroy the saved username and password..</remarks>
        </member>
        <member name="T:NGit.Api.Errors.MultipleParentsNotAllowedException">
            <summary>The commit to be cherry-pick'ed did not have exactly one parent</summary>
        </member>
        <member name="M:NGit.Api.Errors.MultipleParentsNotAllowedException.#ctor(System.String,System.Exception)">
            <param name="message"></param>
            <param name="cause"></param>
        </member>
        <member name="M:NGit.Api.Errors.MultipleParentsNotAllowedException.#ctor(System.String)">
            <param name="message"></param>
        </member>
        <member name="T:NGit.Diff.LowLevelDiffAlgorithm">
            <summary>Compares two sequences primarily based upon hash codes.</summary>
            <remarks>Compares two sequences primarily based upon hash codes.</remarks>
        </member>
        <member name="T:NGit.Diff.DiffAlgorithm">
            <summary>
            Compares two
            <see cref="T:NGit.Diff.Sequence">Sequence</see>
            s to create an
            <see cref="T:NGit.Diff.EditList">EditList</see>
            of changes.
            An algorithm's
            <code>diff</code>
            method must be callable from concurrent threads
            without data collisions. This permits some algorithms to use a singleton
            pattern, with concurrent invocations using the same singleton. Other
            algorithms may support parameterization, in which case the caller can create
            a unique instance per thread.
            </summary>
        </member>
        <member name="M:NGit.Diff.DiffAlgorithm.GetAlgorithm(NGit.Diff.DiffAlgorithm.SupportedAlgorithm)">
            <param name="alg">
            the diff algorithm for which an implementation should be
            returned
            </param>
            <returns>an implementation of the specified diff algorithm</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Diff.DiffAlgorithm.Diff``1(NGit.Diff.SequenceComparator{``0},``0,``0)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Diff.DiffAlgorithm.DiffNonCommon``1(NGit.Diff.SequenceComparator{``0},``0,``0)" -->
        <member name="T:NGit.Diff.DiffAlgorithm.SupportedAlgorithm">
            <summary>Supported diff algorithm</summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Diff.LowLevelDiffAlgorithm.DiffNonCommon``1(NGit.Diff.EditList,NGit.Diff.HashedSequenceComparator{``0},NGit.Diff.HashedSequence{``0},NGit.Diff.HashedSequence{``0},NGit.Diff.Edit)" -->
        <member name="T:NGit.Util.HttpSupport">
            <summary>Extra utilities to support usage of HTTP.</summary>
            <remarks>Extra utilities to support usage of HTTP.</remarks>
        </member>
        <member name="F:NGit.Util.HttpSupport.METHOD_GET">
            <summary>
            The
            <code>GET</code>
            HTTP method.
            </summary>
        </member>
        <member name="F:NGit.Util.HttpSupport.METHOD_POST">
            <summary>
            The
            <code>POST</code>
            HTTP method.
            </summary>
        </member>
        <member name="F:NGit.Util.HttpSupport.HDR_CACHE_CONTROL">
            <summary>
            The
            <code>Cache-Control</code>
            header.
            </summary>
        </member>
        <member name="F:NGit.Util.HttpSupport.HDR_PRAGMA">
            <summary>
            The
            <code>Pragma</code>
            header.
            </summary>
        </member>
        <member name="F:NGit.Util.HttpSupport.HDR_USER_AGENT">
            <summary>
            The
            <code>User-Agent</code>
            header.
            </summary>
        </member>
        <member name="F:NGit.Util.HttpSupport.HDR_DATE">
            <summary>
            The
            <code>Date</code>
            header.
            </summary>
        </member>
        <member name="F:NGit.Util.HttpSupport.HDR_EXPIRES">
            <summary>
            The
            <code>Expires</code>
            header.
            </summary>
        </member>
        <member name="F:NGit.Util.HttpSupport.HDR_ETAG">
            <summary>
            The
            <code>ETag</code>
            header.
            </summary>
        </member>
        <member name="F:NGit.Util.HttpSupport.HDR_IF_NONE_MATCH">
            <summary>
            The
            <code>If-None-Match</code>
            header.
            </summary>
        </member>
        <member name="F:NGit.Util.HttpSupport.HDR_LAST_MODIFIED">
            <summary>
            The
            <code>Last-Modified</code>
            header.
            </summary>
        </member>
        <member name="F:NGit.Util.HttpSupport.HDR_IF_MODIFIED_SINCE">
            <summary>
            The
            <code>If-Modified-Since</code>
            header.
            </summary>
        </member>
        <member name="F:NGit.Util.HttpSupport.HDR_ACCEPT">
            <summary>
            The
            <code>Accept</code>
            header.
            </summary>
        </member>
        <member name="F:NGit.Util.HttpSupport.HDR_CONTENT_TYPE">
            <summary>
            The
            <code>Content-Type</code>
            header.
            </summary>
        </member>
        <member name="F:NGit.Util.HttpSupport.HDR_CONTENT_LENGTH">
            <summary>
            The
            <code>Content-Length</code>
            header.
            </summary>
        </member>
        <member name="F:NGit.Util.HttpSupport.HDR_CONTENT_ENCODING">
            <summary>
            The
            <code>Content-Encoding</code>
            header.
            </summary>
        </member>
        <member name="F:NGit.Util.HttpSupport.HDR_CONTENT_RANGE">
            <summary>
            The
            <code>Content-Range</code>
            header.
            </summary>
        </member>
        <member name="F:NGit.Util.HttpSupport.HDR_ACCEPT_RANGES">
            <summary>
            The
            <code>Accept-Ranges</code>
            header.
            </summary>
        </member>
        <member name="F:NGit.Util.HttpSupport.HDR_IF_RANGE">
            <summary>
            The
            <code>If-Range</code>
            header.
            </summary>
        </member>
        <member name="F:NGit.Util.HttpSupport.HDR_RANGE">
            <summary>
            The
            <code>Range</code>
            header.
            </summary>
        </member>
        <member name="F:NGit.Util.HttpSupport.HDR_ACCEPT_ENCODING">
            <summary>
            The
            <code>Accept-Encoding</code>
            header.
            </summary>
        </member>
        <member name="F:NGit.Util.HttpSupport.ENCODING_GZIP">
            <summary>
            The
            <code>gzip</code>
            encoding value for
            <see cref="F:NGit.Util.HttpSupport.HDR_ACCEPT_ENCODING">HDR_ACCEPT_ENCODING</see>
            .
            </summary>
        </member>
        <member name="F:NGit.Util.HttpSupport.TEXT_PLAIN">
            <summary>
            The standard
            <code>text/plain</code>
            MIME type.
            </summary>
        </member>
        <member name="F:NGit.Util.HttpSupport.HDR_AUTHORIZATION">
            <summary>
            The
            <code>Authorization</code>
            header.
            </summary>
        </member>
        <member name="F:NGit.Util.HttpSupport.HDR_WWW_AUTHENTICATE">
            <summary>
            The
            <code>WWW-Authenticate</code>
            header.
            </summary>
        </member>
        <member name="M:NGit.Util.HttpSupport.Encode(System.Text.StringBuilder,System.String)">
            <summary>URL encode a value string into an output buffer.</summary>
            <remarks>URL encode a value string into an output buffer.</remarks>
            <param name="urlstr">the output buffer.</param>
            <param name="key">value which must be encoded to protected special characters.</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Util.HttpSupport.Response(Sharpen.HttpURLConnection)" -->
        <member name="M:NGit.Util.HttpSupport.ProxyFor(Sharpen.ProxySelector,System.Uri)">
            <summary>Determine the proxy server (if any) needed to obtain a URL.</summary>
            <remarks>Determine the proxy server (if any) needed to obtain a URL.</remarks>
            <param name="proxySelector">proxy support for the caller.</param>
            <param name="u">location of the server caller wants to talk to.</param>
            <returns>proxy to communicate with the supplied URL.</returns>
            <exception cref="T:Sharpen.ConnectException">
            the proxy could not be computed as the supplied URL could not
            be read. This failure should never occur.
            </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Transport.ReceiveCommand" -->
        <member name="M:NGit.Transport.ReceiveCommand.Filter(System.Collections.Generic.IList{NGit.Transport.ReceiveCommand},NGit.Transport.ReceiveCommand.Result)">
            <summary>Filter a list of commands according to result.</summary>
            <remarks>Filter a list of commands according to result.</remarks>
            <param name="commands">commands to filter.</param>
            <param name="want">desired status to filter by.</param>
            <returns>
            a copy of the command list containing only those commands with
            the desired status.
            </returns>
            <since>2.0</since>
        </member>
        <member name="M:NGit.Transport.ReceiveCommand.#ctor(NGit.ObjectId,NGit.ObjectId,System.String)">
            <summary>
            Create a new command for
            <see cref="T:NGit.Transport.BaseReceivePack">BaseReceivePack</see>
            .
            </summary>
            <param name="oldId">
            the old object id; must not be null. Use
            <see cref="P:NGit.ObjectId.ZeroId">NGit.ObjectId.ZeroId()</see>
            to indicate a ref creation.
            </param>
            <param name="newId">
            the new object id; must not be null. Use
            <see cref="P:NGit.ObjectId.ZeroId">NGit.ObjectId.ZeroId()</see>
            to indicate a ref deletion.
            </param>
            <param name="name">name of the ref being affected.</param>
        </member>
        <member name="M:NGit.Transport.ReceiveCommand.#ctor(NGit.ObjectId,NGit.ObjectId,System.String,NGit.Transport.ReceiveCommand.Type)">
            <summary>
            Create a new command for
            <see cref="T:NGit.Transport.BaseReceivePack">BaseReceivePack</see>
            .
            </summary>
            <param name="oldId">
            the old object id; must not be null. Use
            <see cref="P:NGit.ObjectId.ZeroId">NGit.ObjectId.ZeroId()</see>
            to indicate a ref creation.
            </param>
            <param name="newId">
            the new object id; must not be null. Use
            <see cref="P:NGit.ObjectId.ZeroId">NGit.ObjectId.ZeroId()</see>
            to indicate a ref deletion.
            </param>
            <param name="name">name of the ref being affected.</param>
            <param name="type">type of the command.</param>
            <since>2.0</since>
        </member>
        <member name="M:NGit.Transport.ReceiveCommand.GetOldId">
            <returns>the old value the client thinks the ref has.</returns>
        </member>
        <member name="M:NGit.Transport.ReceiveCommand.GetNewId">
            <returns>the requested new value for this ref.</returns>
        </member>
        <member name="M:NGit.Transport.ReceiveCommand.GetRefName">
            <returns>the name of the ref being updated.</returns>
        </member>
        <member name="M:NGit.Transport.ReceiveCommand.GetType">
            <returns>
            the type of this command; see
            <see cref="T:NGit.Transport.ReceiveCommand.Type">Type</see>
            .
            </returns>
        </member>
        <member name="M:NGit.Transport.ReceiveCommand.GetRef">
            <returns>the ref, if this was advertised by the connection.</returns>
        </member>
        <member name="M:NGit.Transport.ReceiveCommand.GetResult">
            <returns>the current status code of this command.</returns>
        </member>
        <member name="M:NGit.Transport.ReceiveCommand.GetMessage">
            <returns>the message associated with a failure status.</returns>
        </member>
        <member name="M:NGit.Transport.ReceiveCommand.SetResult(NGit.Transport.ReceiveCommand.Result)">
            <summary>Set the status of this command.</summary>
            <remarks>Set the status of this command.</remarks>
            <param name="s">the new status code for this command.</param>
        </member>
        <member name="M:NGit.Transport.ReceiveCommand.SetResult(NGit.Transport.ReceiveCommand.Result,System.String)">
            <summary>Set the status of this command.</summary>
            <remarks>Set the status of this command.</remarks>
            <param name="s">new status code for this command.</param>
            <param name="m">optional message explaining the new status.</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Transport.ReceiveCommand.UpdateType(NGit.Revwalk.RevWalk)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Transport.ReceiveCommand.Execute(NGit.Transport.BaseReceivePack)" -->
        <member name="M:NGit.Transport.ReceiveCommand.SetResult(NGit.RefUpdate.Result)">
            <summary>Set the result of this command.</summary>
            <remarks>Set the result of this command.</remarks>
            <param name="r">the new result code for this command.</param>
        </member>
        <member name="T:NGit.Transport.ReceiveCommand.Type">
            <summary>Type of operation requested.</summary>
            <remarks>Type of operation requested.</remarks>
        </member>
        <member name="T:NGit.Transport.ReceiveCommand.Result">
            <summary>Result of the update command.</summary>
            <remarks>Result of the update command.</remarks>
        </member>
        <member name="T:NGit.Transport.BaseFetchConnection">
            <summary>Base helper class for fetch connection implementations.</summary>
            <remarks>
            Base helper class for fetch connection implementations. Provides some common
            typical structures and methods used during fetch connection.
            <p>
            Implementors of fetch over pack-based protocols should consider using
            <see cref="T:NGit.Transport.BasePackFetchConnection">BasePackFetchConnection</see>
            instead.
            </p>
            </remarks>
        </member>
        <member name="M:NGit.Transport.BaseFetchConnection.Fetch(NGit.ProgressMonitor,System.Collections.Generic.ICollection{NGit.Ref},System.Collections.Generic.ICollection{NGit.ObjectId})">
            <exception cref="T:NGit.Errors.TransportException"></exception>
        </member>
        <member name="M:NGit.Transport.BaseFetchConnection.DidFetchIncludeTags">
            <summary>
            Default implementation of
            <see cref="M:NGit.Transport.FetchConnection.DidFetchIncludeTags">FetchConnection.DidFetchIncludeTags()
            	</see>
            -
            returning false.
            </summary>
        </member>
        <member name="M:NGit.Transport.BaseFetchConnection.DoFetch(NGit.ProgressMonitor,System.Collections.Generic.ICollection{NGit.Ref},System.Collections.Generic.ICollection{NGit.ObjectId})">
            <summary>
            Implementation of
            <see cref="!:Fetch(NGit.ProgressMonitor, System.Collections.Generic.ICollection&lt;E&gt;, System.Collections.Generic.ICollection&lt;E&gt;)&#xA;            	">Fetch(NGit.ProgressMonitor, System.Collections.Generic.ICollection&lt;E&gt;, System.Collections.Generic.ICollection&lt;E&gt;)
            	</see>
            without checking for multiple fetch.
            </summary>
            <param name="monitor">
            as in
            <see cref="!:Fetch(NGit.ProgressMonitor, System.Collections.Generic.ICollection&lt;E&gt;, System.Collections.Generic.ICollection&lt;E&gt;)&#xA;            	">Fetch(NGit.ProgressMonitor, System.Collections.Generic.ICollection&lt;E&gt;, System.Collections.Generic.ICollection&lt;E&gt;)
            	</see>
            </param>
            <param name="want">
            as in
            <see cref="!:Fetch(NGit.ProgressMonitor, System.Collections.Generic.ICollection&lt;E&gt;, System.Collections.Generic.ICollection&lt;E&gt;)&#xA;            	">Fetch(NGit.ProgressMonitor, System.Collections.Generic.ICollection&lt;E&gt;, System.Collections.Generic.ICollection&lt;E&gt;)
            	</see>
            </param>
            <param name="have">
            as in
            <see cref="!:Fetch(NGit.ProgressMonitor, System.Collections.Generic.ICollection&lt;E&gt;, System.Collections.Generic.ICollection&lt;E&gt;)&#xA;            	">Fetch(NGit.ProgressMonitor, System.Collections.Generic.ICollection&lt;E&gt;, System.Collections.Generic.ICollection&lt;E&gt;)
            	</see>
            </param>
            <exception cref="T:NGit.Errors.TransportException">
            as in
            <see cref="!:Fetch(NGit.ProgressMonitor, System.Collections.Generic.ICollection&lt;E&gt;, System.Collections.Generic.ICollection&lt;E&gt;)&#xA;            	">Fetch(NGit.ProgressMonitor, System.Collections.Generic.ICollection&lt;E&gt;, System.Collections.Generic.ICollection&lt;E&gt;)
            	</see>
            , but
            implementation doesn't have to care about multiple
            <see cref="!:Fetch(NGit.ProgressMonitor, System.Collections.Generic.ICollection&lt;E&gt;, System.Collections.Generic.ICollection&lt;E&gt;)&#xA;            	">Fetch(NGit.ProgressMonitor, System.Collections.Generic.ICollection&lt;E&gt;, System.Collections.Generic.ICollection&lt;E&gt;)
            	</see>
            calls, as it
            is checked in this class.
            </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Transport.RemoteConfig" -->
        <member name="F:NGit.Transport.RemoteConfig.DEFAULT_UPLOAD_PACK">
            <summary>
            Default value for
            <see cref="P:NGit.Transport.RemoteConfig.UploadPack">UploadPack()</see>
            if not specified.
            </summary>
        </member>
        <member name="F:NGit.Transport.RemoteConfig.DEFAULT_RECEIVE_PACK">
            <summary>
            Default value for
            <see cref="P:NGit.Transport.RemoteConfig.ReceivePack">ReceivePack()</see>
            if not specified.
            </summary>
        </member>
        <member name="M:NGit.Transport.RemoteConfig.GetAllRemoteConfigs(NGit.Config)">
            <summary>
            Parse all remote blocks in an existing configuration file, looking for
            remotes configuration.
            </summary>
            <remarks>
            Parse all remote blocks in an existing configuration file, looking for
            remotes configuration.
            </remarks>
            <param name="rc">
            the existing configuration to get the remote settings from.
            The configuration must already be loaded into memory.
            </param>
            <returns>
            all remotes configurations existing in provided repository
            configuration. Returned configurations are ordered
            lexicographically by names.
            </returns>
            <exception cref="T:Sharpen.URISyntaxException">one of the URIs within the remote's configuration is invalid.
            	</exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Transport.RemoteConfig.#ctor(NGit.Config,System.String)" -->
        <member name="M:NGit.Transport.RemoteConfig.Update(NGit.Config)">
            <summary>Update this remote's definition within the configuration.</summary>
            <remarks>Update this remote's definition within the configuration.</remarks>
            <param name="rc">the configuration file to store ourselves into.</param>
        </member>
        <member name="M:NGit.Transport.RemoteConfig.AddURI(NGit.Transport.URIish)">
            <summary>Add a new URI to the end of the list of URIs.</summary>
            <remarks>Add a new URI to the end of the list of URIs.</remarks>
            <param name="toAdd">the new URI to add to this remote.</param>
            <returns>true if the URI was added; false if it already exists.</returns>
        </member>
        <member name="M:NGit.Transport.RemoteConfig.RemoveURI(NGit.Transport.URIish)">
            <summary>Remove a URI from the list of URIs.</summary>
            <remarks>Remove a URI from the list of URIs.</remarks>
            <param name="toRemove">the URI to remove from this remote.</param>
            <returns>true if the URI was added; false if it already exists.</returns>
        </member>
        <member name="M:NGit.Transport.RemoteConfig.AddPushURI(NGit.Transport.URIish)">
            <summary>Add a new push-only URI to the end of the list of URIs.</summary>
            <remarks>Add a new push-only URI to the end of the list of URIs.</remarks>
            <param name="toAdd">the new URI to add to this remote.</param>
            <returns>true if the URI was added; false if it already exists.</returns>
        </member>
        <member name="M:NGit.Transport.RemoteConfig.RemovePushURI(NGit.Transport.URIish)">
            <summary>Remove a push-only URI from the list of URIs.</summary>
            <remarks>Remove a push-only URI from the list of URIs.</remarks>
            <param name="toRemove">the URI to remove from this remote.</param>
            <returns>true if the URI was added; false if it already exists.</returns>
        </member>
        <member name="M:NGit.Transport.RemoteConfig.AddFetchRefSpec(NGit.Transport.RefSpec)">
            <summary>Add a new fetch RefSpec to this remote.</summary>
            <remarks>Add a new fetch RefSpec to this remote.</remarks>
            <param name="s">the new specification to add.</param>
            <returns>true if the specification was added; false if it already exists.</returns>
        </member>
        <member name="M:NGit.Transport.RemoteConfig.RemoveFetchRefSpec(NGit.Transport.RefSpec)">
            <summary>Remove a fetch RefSpec from this remote.</summary>
            <remarks>Remove a fetch RefSpec from this remote.</remarks>
            <param name="s">the specification to remove.</param>
            <returns>true if the specification existed and was removed.</returns>
        </member>
        <member name="M:NGit.Transport.RemoteConfig.AddPushRefSpec(NGit.Transport.RefSpec)">
            <summary>Add a new push RefSpec to this remote.</summary>
            <remarks>Add a new push RefSpec to this remote.</remarks>
            <param name="s">the new specification to add.</param>
            <returns>true if the specification was added; false if it already exists.</returns>
        </member>
        <member name="M:NGit.Transport.RemoteConfig.RemovePushRefSpec(NGit.Transport.RefSpec)">
            <summary>Remove a push RefSpec from this remote.</summary>
            <remarks>Remove a push RefSpec from this remote.</remarks>
            <param name="s">the specification to remove.</param>
            <returns>true if the specification existed and was removed.</returns>
        </member>
        <member name="P:NGit.Transport.RemoteConfig.Name">
            <summary>Get the local name this remote configuration is recognized as.</summary>
            <remarks>Get the local name this remote configuration is recognized as.</remarks>
            <returns>name assigned by the user to this configuration block.</returns>
            <summary>Set the local name this remote configuration is recognized as.</summary>
            <remarks>Set the local name this remote configuration is recognized as.</remarks>
            <value>the new name of this remote.</value>
        </member>
        <member name="P:NGit.Transport.RemoteConfig.URIs">
            <summary>Get all configured URIs under this remote.</summary>
            <remarks>Get all configured URIs under this remote.</remarks>
            <returns>the set of URIs known to this remote.</returns>
        </member>
        <member name="P:NGit.Transport.RemoteConfig.PushURIs">
            <summary>Get all configured push-only URIs under this remote.</summary>
            <remarks>Get all configured push-only URIs under this remote.</remarks>
            <returns>the set of URIs known to this remote.</returns>
        </member>
        <member name="P:NGit.Transport.RemoteConfig.FetchRefSpecs">
            <summary>Remembered specifications for fetching from a repository.</summary>
            <remarks>Remembered specifications for fetching from a repository.</remarks>
            <returns>set of specs used by default when fetching.</returns>
            <summary>Override existing fetch specifications with new ones.</summary>
            <remarks>Override existing fetch specifications with new ones.</remarks>
            <value>
            list of fetch specifications to set. List is copied, it can be
            modified after this call.
            </value>
        </member>
        <member name="P:NGit.Transport.RemoteConfig.PushRefSpecs">
            <summary>Override existing push specifications with new ones.</summary>
            <remarks>Override existing push specifications with new ones.</remarks>
            <value>
            list of push specifications to set. List is copied, it can be
            modified after this call.
            </value>
            <summary>Remembered specifications for pushing to a repository.</summary>
            <remarks>Remembered specifications for pushing to a repository.</remarks>
            <returns>set of specs used by default when pushing.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "P:NGit.Transport.RemoteConfig.UploadPack" -->
        <!-- Badly formed XML comment ignored for member "P:NGit.Transport.RemoteConfig.ReceivePack" -->
        <member name="P:NGit.Transport.RemoteConfig.TagOpt">
            <summary>Get the description of how annotated tags should be treated during fetch.
            	</summary>
            <remarks>Get the description of how annotated tags should be treated during fetch.
            	</remarks>
            <returns>option indicating the behavior of annotated tags in fetch.</returns>
            <summary>Set the description of how annotated tags should be treated on fetch.</summary>
            <remarks>Set the description of how annotated tags should be treated on fetch.</remarks>
            <value>method to use when handling annotated tags.</value>
        </member>
        <member name="P:NGit.Transport.RemoteConfig.IsMirror">
            <returns>
            true if pushing to the remote automatically deletes remote refs
            which don't exist on the source side.
            </returns>
            <summary>Set the mirror flag to automatically delete remote refs.</summary>
            <remarks>Set the mirror flag to automatically delete remote refs.</remarks>
            <value>true to automatically delete remote refs during push.</value>
        </member>
        <member name="P:NGit.Transport.RemoteConfig.Timeout">
            <returns>timeout (in seconds) before aborting an IO operation.</returns>
            <summary>Set the timeout before willing to abort an IO call.</summary>
            <remarks>Set the timeout before willing to abort an IO call.</remarks>
            <value>
            number of seconds to wait (with no data transfer occurring)
            before aborting an IO read or write operation with this
            remote.  A timeout of 0 will block indefinitely.
            </value>
        </member>
        <member name="T:NGit.Api.MergeCommandResult">
            <summary>
            Encapsulates the result of a
            <see cref="T:NGit.Api.MergeCommand">MergeCommand</see>
            .
            </summary>
        </member>
        <member name="M:NGit.Api.MergeCommandResult.#ctor(NGit.ObjectId,NGit.ObjectId,NGit.ObjectId[],NGit.Api.MergeStatus,NGit.Merge.MergeStrategy,System.Collections.Generic.IDictionary{System.String,NGit.Merge.MergeResult{NGit.Diff.Sequence}})">
            <param name="newHead">the object the head points at after the merge</param>
            <param name="base">
            the common base which was used to produce a content-merge. May
            be <code>null</code> if the merge-result was produced without
            computing a common base
            </param>
            <param name="mergedCommits">all the commits which have been merged together</param>
            <param name="mergeStatus">the status the merge resulted in</param>
            <param name="mergeStrategy">
            the used
            <see cref="T:NGit.Merge.MergeStrategy">NGit.Merge.MergeStrategy</see>
            </param>
            <param name="lowLevelResults">
            merge results as returned by
            <see cref="M:NGit.Merge.ResolveMerger.GetMergeResults">NGit.Merge.ResolveMerger.GetMergeResults()
            	</see>
            </param>
            <since>2.0</since>
        </member>
        <member name="M:NGit.Api.MergeCommandResult.#ctor(NGit.ObjectId,NGit.ObjectId,NGit.ObjectId[],NGit.Api.MergeStatus,NGit.Merge.MergeStrategy,System.Collections.Generic.IDictionary{System.String,NGit.Merge.MergeResult{NGit.Diff.Sequence}},System.String)">
            <param name="newHead">the object the head points at after the merge</param>
            <param name="base">
            the common base which was used to produce a content-merge. May
            be <code>null</code> if the merge-result was produced without
            computing a common base
            </param>
            <param name="mergedCommits">all the commits which have been merged together</param>
            <param name="mergeStatus">the status the merge resulted in</param>
            <param name="mergeStrategy">
            the used
            <see cref="T:NGit.Merge.MergeStrategy">NGit.Merge.MergeStrategy</see>
            </param>
            <param name="lowLevelResults">
            merge results as returned by
            <see cref="M:NGit.Merge.ResolveMerger.GetMergeResults">NGit.Merge.ResolveMerger.GetMergeResults()
            	</see>
            </param>
            <param name="description">a user friendly description of the merge result</param>
        </member>
        <member name="M:NGit.Api.MergeCommandResult.#ctor(NGit.ObjectId,NGit.ObjectId,NGit.ObjectId[],NGit.Api.MergeStatus,NGit.Merge.MergeStrategy,System.Collections.Generic.IDictionary{System.String,NGit.Merge.MergeResult{NGit.Diff.Sequence}},System.Collections.Generic.IDictionary{System.String,NGit.Merge.ResolveMerger.MergeFailureReason},System.String)">
            <param name="newHead">the object the head points at after the merge</param>
            <param name="base">
            the common base which was used to produce a content-merge. May
            be <code>null</code> if the merge-result was produced without
            computing a common base
            </param>
            <param name="mergedCommits">all the commits which have been merged together</param>
            <param name="mergeStatus">the status the merge resulted in</param>
            <param name="mergeStrategy">
            the used
            <see cref="T:NGit.Merge.MergeStrategy">NGit.Merge.MergeStrategy</see>
            </param>
            <param name="lowLevelResults">
            merge results as returned by
            <see cref="M:NGit.Merge.ResolveMerger.GetMergeResults">NGit.Merge.ResolveMerger.GetMergeResults()
            	</see>
            </param>
            <param name="failingPaths">
            list of paths causing this merge to fail as returned by
            <see cref="M:NGit.Merge.ResolveMerger.GetFailingPaths">NGit.Merge.ResolveMerger.GetFailingPaths()
            	</see>
            </param>
            <param name="description">a user friendly description of the merge result</param>
        </member>
        <member name="M:NGit.Api.MergeCommandResult.GetNewHead">
            <returns>the object the head points at after the merge</returns>
        </member>
        <member name="M:NGit.Api.MergeCommandResult.GetMergeStatus">
            <returns>the status the merge resulted in</returns>
        </member>
        <member name="M:NGit.Api.MergeCommandResult.GetMergedCommits">
            <returns>all the commits which have been merged together</returns>
        </member>
        <member name="M:NGit.Api.MergeCommandResult.GetBase">
            <returns>
            base the common base which was used to produce a content-merge.
            May be <code>null</code> if the merge-result was produced without
            computing a common base
            </returns>
        </member>
        <member name="M:NGit.Api.MergeCommandResult.SetConflicts(System.Collections.Generic.IDictionary{System.String,System.Int32[][]})">
            <param name="conflicts">the conflicts to set</param>
        </member>
        <member name="M:NGit.Api.MergeCommandResult.AddConflict(System.String,System.Int32[][])">
            <param name="path"></param>
            <param name="conflictingRanges">the conflicts to set</param>
        </member>
        <member name="M:NGit.Api.MergeCommandResult.AddConflict``1(System.String,NGit.Merge.MergeResult{``0})">
            <param name="path"></param>
            <param name="lowLevelResult"></param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Api.MergeCommandResult.GetConflicts" -->
        <member name="M:NGit.Api.MergeCommandResult.GetFailingPaths">
            <summary>
            Returns a list of paths causing this merge to fail as returned by
            <see cref="M:NGit.Merge.ResolveMerger.GetFailingPaths">NGit.Merge.ResolveMerger.GetFailingPaths()
            	</see>
            </summary>
            <returns>
            the list of paths causing this merge to fail or <code>null</code>
            if no failure occurred
            </returns>
        </member>
        <member name="M:NGit.Api.MergeStatus.IsSuccessful">
            <returns>whether the status indicates a successful result</returns>
        </member>
        <member name="T:NGit.Errors.RepositoryNotFoundException">
            <summary>Indicates a local repository does not exist.</summary>
            <remarks>Indicates a local repository does not exist.</remarks>
        </member>
        <member name="M:NGit.Errors.RepositoryNotFoundException.#ctor(Sharpen.FilePath)">
            <summary>Constructs an exception indicating a local repository does not exist.</summary>
            <remarks>Constructs an exception indicating a local repository does not exist.</remarks>
            <param name="location">description of the repository not found, usually file path.
            	</param>
        </member>
        <member name="M:NGit.Errors.RepositoryNotFoundException.#ctor(Sharpen.FilePath,System.Exception)">
            <summary>Constructs an exception indicating a local repository does not exist.</summary>
            <remarks>Constructs an exception indicating a local repository does not exist.</remarks>
            <param name="location">description of the repository not found, usually file path.
            	</param>
            <param name="why">why the repository does not exist.</param>
        </member>
        <member name="M:NGit.Errors.RepositoryNotFoundException.#ctor(System.String)">
            <summary>Constructs an exception indicating a local repository does not exist.</summary>
            <remarks>Constructs an exception indicating a local repository does not exist.</remarks>
            <param name="location">description of the repository not found, usually file path.
            	</param>
        </member>
        <member name="M:NGit.Errors.RepositoryNotFoundException.#ctor(System.String,System.Exception)">
            <summary>Constructs an exception indicating a local repository does not exist.</summary>
            <remarks>Constructs an exception indicating a local repository does not exist.</remarks>
            <param name="location">description of the repository not found, usually file path.
            	</param>
            <param name="why">why the repository does not exist.</param>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Util.IntList" -->
        <member name="M:NGit.Util.IntList.#ctor">
            <summary>Create an empty list with a default capacity.</summary>
            <remarks>Create an empty list with a default capacity.</remarks>
        </member>
        <member name="M:NGit.Util.IntList.#ctor(System.Int32)">
            <summary>Create an empty list with the specified capacity.</summary>
            <remarks>Create an empty list with the specified capacity.</remarks>
            <param name="capacity">number of entries the list can initially hold.</param>
        </member>
        <member name="M:NGit.Util.IntList.Size">
            <returns>number of entries in this list</returns>
        </member>
        <member name="M:NGit.Util.IntList.Get(System.Int32)">
            <param name="i">
            index to read, must be in the range [0,
            <see cref="M:NGit.Util.IntList.Size">Size()</see>
            ).
            </param>
            <returns>the number at the specified index</returns>
            <exception cref="T:System.IndexOutOfRangeException">the index outside the valid range
            	</exception>
        </member>
        <member name="M:NGit.Util.IntList.Clear">
            <summary>Empty this list</summary>
        </member>
        <member name="M:NGit.Util.IntList.Add(System.Int32)">
            <summary>Add an entry to the end of the list.</summary>
            <remarks>Add an entry to the end of the list.</remarks>
            <param name="n">the number to add.</param>
        </member>
        <member name="M:NGit.Util.IntList.Set(System.Int32,System.Int32)">
            <summary>Assign an entry in the list.</summary>
            <remarks>Assign an entry in the list.</remarks>
            <param name="index">
            index to set, must be in the range [0,
            <see cref="M:NGit.Util.IntList.Size">Size()</see>
            ).
            </param>
            <param name="n">value to store at the position.</param>
        </member>
        <member name="M:NGit.Util.IntList.FillTo(System.Int32,System.Int32)">
            <summary>Pad the list with entries.</summary>
            <remarks>Pad the list with entries.</remarks>
            <param name="toIndex">
            index position to stop filling at. 0 inserts no filler. 1
            ensures the list has a size of 1, adding <code>val</code> if
            the list is currently empty.
            </param>
            <param name="val">value to insert into padded positions.</param>
        </member>
        <member name="T:NGit.Storage.Pack.PackOutputStream">
            <summary>
            Custom output stream to support
            <see cref="T:NGit.Storage.Pack.PackWriter">PackWriter</see>
            .
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Storage.Pack.PackOutputStream.#ctor(NGit.ProgressMonitor,Sharpen.OutputStream,NGit.Storage.Pack.PackWriter)" -->
        <member name="M:NGit.Storage.Pack.PackOutputStream.Write(System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.Pack.PackOutputStream.Write(System.Byte[],System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.Pack.PackOutputStream.Flush">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.Pack.PackOutputStream.WriteFileHeader(System.Int32,System.Int64)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.Pack.PackOutputStream.WriteObject(NGit.Storage.Pack.ObjectToPack)">
            <summary>Write one object.</summary>
            <remarks>
            Write one object.
            If the object was already written, this method does nothing and returns
            quickly. This case occurs whenever an object was written out of order in
            order to ensure the delta base occurred before the object that needs it.
            </remarks>
            <param name="otp">the object to write.</param>
            <exception cref="T:System.IO.IOException">
            the object cannot be read from the object reader, or the
            output stream is no longer accepting output. Caller must
            examine the type of exception and possibly its message to
            distinguish between these cases.
            </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Storage.Pack.PackOutputStream.WriteHeader(NGit.Storage.Pack.ObjectToPack,System.Int64)" -->
        <member name="M:NGit.Storage.Pack.PackOutputStream.GetCopyBuffer">
            <returns>a temporary buffer writers can use to copy data with.</returns>
        </member>
        <member name="M:NGit.Storage.Pack.PackOutputStream.Length">
            <returns>total number of bytes written since stream start.</returns>
        </member>
        <member name="M:NGit.Storage.Pack.PackOutputStream.GetCRC32">
            <returns>obtain the current CRC32 register.</returns>
        </member>
        <member name="M:NGit.Storage.Pack.PackOutputStream.ResetCRC32">
            <summary>Reinitialize the CRC32 register for a new region.</summary>
            <remarks>Reinitialize the CRC32 register for a new region.</remarks>
        </member>
        <member name="M:NGit.Storage.Pack.PackOutputStream.GetDigest">
            <returns>obtain the current SHA-1 digest.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Storage.Pack.DeltaStream" -->
        <member name="F:NGit.Storage.Pack.DeltaStream.baseStream">
            <summary>Stream to read from the base object.</summary>
            <remarks>Stream to read from the base object.</remarks>
        </member>
        <member name="F:NGit.Storage.Pack.DeltaStream.baseOffset">
            <summary>
            Current position within
            <see cref="F:NGit.Storage.Pack.DeltaStream.baseStream">baseStream</see>
            .
            </summary>
        </member>
        <member name="F:NGit.Storage.Pack.DeltaStream.copyOffset">
            <summary>
            If
            <code>curcmd == CMD_COPY</code>
            , position the base has to be at.
            </summary>
        </member>
        <member name="F:NGit.Storage.Pack.DeltaStream.copySize">
            <summary>Total number of bytes in this current command.</summary>
            <remarks>Total number of bytes in this current command.</remarks>
        </member>
        <member name="M:NGit.Storage.Pack.DeltaStream.#ctor(Sharpen.InputStream)">
            <summary>Construct a delta application stream, reading instructions.</summary>
            <remarks>Construct a delta application stream, reading instructions.</remarks>
            <param name="deltaStream">the stream to read delta instructions from.</param>
            <exception cref="T:System.IO.IOException">
            the delta instruction stream cannot be read, or is
            inconsistent with the the base object information.
            </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Storage.Pack.DeltaStream.OpenBase" -->
        <member name="M:NGit.Storage.Pack.DeltaStream.GetBaseSize">
            <returns>length of the base object, in bytes.</returns>
            <exception cref="T:System.IO.IOException">the length of the base cannot be determined.
            	</exception>
        </member>
        <member name="M:NGit.Storage.Pack.DeltaStream.GetSize">
            <returns>total size of this stream, in bytes.</returns>
        </member>
        <member name="M:NGit.Storage.Pack.DeltaStream.Read">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.Pack.DeltaStream.Close">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.Pack.DeltaStream.Skip(System.Int64)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.Pack.DeltaStream.Read(System.Byte[],System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.Pack.DeltaStream.Fill(System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.Pack.DeltaStream.Next">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.Pack.DeltaStream.SeekBase">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="T:NGit.Storage.File.UnpackedObjectCache">
            <summary>Remembers objects that are currently unpacked.</summary>
            <remarks>Remembers objects that are currently unpacked.</remarks>
        </member>
        <member name="T:NGit.Revwalk.Filter.CommitTimeRevFilter">
            <summary>Selects commits based upon the commit time field.</summary>
            <remarks>Selects commits based upon the commit time field.</remarks>
        </member>
        <member name="M:NGit.Revwalk.Filter.CommitTimeRevFilter.Before(System.DateTime)">
            <summary>Create a new filter to select commits before a given date/time.</summary>
            <remarks>Create a new filter to select commits before a given date/time.</remarks>
            <param name="ts">the point in time to cut on.</param>
            <returns>a new filter to select commits on or before <code>ts</code>.</returns>
        </member>
        <member name="M:NGit.Revwalk.Filter.CommitTimeRevFilter.Before(System.Int64)">
            <summary>Create a new filter to select commits before a given date/time.</summary>
            <remarks>Create a new filter to select commits before a given date/time.</remarks>
            <param name="ts">the point in time to cut on, in milliseconds</param>
            <returns>a new filter to select commits on or before <code>ts</code>.</returns>
        </member>
        <member name="M:NGit.Revwalk.Filter.CommitTimeRevFilter.After(System.DateTime)">
            <summary>Create a new filter to select commits after a given date/time.</summary>
            <remarks>Create a new filter to select commits after a given date/time.</remarks>
            <param name="ts">the point in time to cut on.</param>
            <returns>a new filter to select commits on or after <code>ts</code>.</returns>
        </member>
        <member name="M:NGit.Revwalk.Filter.CommitTimeRevFilter.After(System.Int64)">
            <summary>Create a new filter to select commits after a given date/time.</summary>
            <remarks>Create a new filter to select commits after a given date/time.</remarks>
            <param name="ts">the point in time to cut on, in milliseconds.</param>
            <returns>a new filter to select commits on or after <code>ts</code>.</returns>
        </member>
        <member name="M:NGit.Revwalk.Filter.CommitTimeRevFilter.Between(System.DateTime,System.DateTime)">
            <summary>
            Create a new filter to select commits after or equal a given date/time <code>since</code>
            and before or equal a given date/time <code>until</code>.
            </summary>
            <remarks>
            Create a new filter to select commits after or equal a given date/time <code>since</code>
            and before or equal a given date/time <code>until</code>.
            </remarks>
            <param name="since">the point in time to cut on.</param>
            <param name="until">the point in time to cut off.</param>
            <returns>a new filter to select commits between the given date/times.</returns>
        </member>
        <member name="M:NGit.Revwalk.Filter.CommitTimeRevFilter.Between(System.Int64,System.Int64)">
            <summary>
            Create a new filter to select commits after or equal a given date/time <code>since</code>
            and before or equal a given date/time <code>until</code>.
            </summary>
            <remarks>
            Create a new filter to select commits after or equal a given date/time <code>since</code>
            and before or equal a given date/time <code>until</code>.
            </remarks>
            <param name="since">the point in time to cut on, in milliseconds.</param>
            <param name="until">the point in time to cut off, in millisconds.</param>
            <returns>a new filter to select commits between the given date/times.</returns>
        </member>
        <member name="M:NGit.Revwalk.Filter.CommitTimeRevFilterBefore.Include(NGit.Revwalk.RevWalk,NGit.Revwalk.RevCommit)">
            <exception cref="T:NGit.Errors.StopWalkException"></exception>
            <exception cref="T:NGit.Errors.MissingObjectException"></exception>
            <exception cref="T:NGit.Errors.IncorrectObjectTypeException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Revwalk.Filter.CommitTimeRevFilterAfter.Include(NGit.Revwalk.RevWalk,NGit.Revwalk.RevCommit)">
            <exception cref="T:NGit.Errors.StopWalkException"></exception>
            <exception cref="T:NGit.Errors.MissingObjectException"></exception>
            <exception cref="T:NGit.Errors.IncorrectObjectTypeException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Revwalk.Filter.CommitTimeRevFilterBetween.Include(NGit.Revwalk.RevWalk,NGit.Revwalk.RevCommit)">
            <exception cref="T:NGit.Errors.StopWalkException"></exception>
            <exception cref="T:NGit.Errors.MissingObjectException"></exception>
            <exception cref="T:NGit.Errors.IncorrectObjectTypeException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="T:NGit.Revwalk.FIFORevQueue">
            <summary>A queue of commits in FIFO order.</summary>
            <remarks>A queue of commits in FIFO order.</remarks>
        </member>
        <member name="M:NGit.Revwalk.FIFORevQueue.#ctor">
            <summary>Create an empty FIFO queue.</summary>
            <remarks>Create an empty FIFO queue.</remarks>
        </member>
        <member name="M:NGit.Revwalk.FIFORevQueue.#ctor(NGit.Revwalk.Generator)">
            <exception cref="T:NGit.Errors.MissingObjectException"></exception>
            <exception cref="T:NGit.Errors.IncorrectObjectTypeException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Revwalk.FIFORevQueue.Unpop(NGit.Revwalk.RevCommit)">
            <summary>Insert the commit pointer at the front of the queue.</summary>
            <remarks>Insert the commit pointer at the front of the queue.</remarks>
            <param name="c">the commit to insert into the queue.</param>
        </member>
        <member name="T:NGit.Errors.SymlinksNotSupportedException">
            <summary>
            An exception thrown when a symlink entry is found and cannot be
            handled.
            </summary>
            <remarks>
            An exception thrown when a symlink entry is found and cannot be
            handled.
            </remarks>
        </member>
        <member name="M:NGit.Errors.SymlinksNotSupportedException.#ctor(System.String)">
            <summary>Construct a SymlinksNotSupportedException for the specified link</summary>
            <param name="s">name of link in tree or workdir</param>
        </member>
        <member name="T:NGit.Errors.ObjectWritingException">
            <summary>Cannot store an object in the object database.</summary>
            <remarks>
            Cannot store an object in the object database. This is a serious
            error that users need to be made aware of.
            </remarks>
        </member>
        <member name="M:NGit.Errors.ObjectWritingException.#ctor(System.String)">
            <summary>Constructs an ObjectWritingException with the specified detail message.</summary>
            <remarks>Constructs an ObjectWritingException with the specified detail message.</remarks>
            <param name="s">message</param>
        </member>
        <member name="M:NGit.Errors.ObjectWritingException.#ctor(System.String,System.Exception)">
            <summary>Constructs an ObjectWritingException with the specified detail message.</summary>
            <remarks>Constructs an ObjectWritingException with the specified detail message.</remarks>
            <param name="s">message</param>
            <param name="cause">root cause exception</param>
        </member>
        <member name="T:NGit.Errors.InvalidPatternException">
            <summary>Thrown when a pattern passed in an argument was wrong.</summary>
            <remarks>Thrown when a pattern passed in an argument was wrong.</remarks>
        </member>
        <member name="M:NGit.Errors.InvalidPatternException.#ctor(System.String,System.String)">
            <param name="message">explains what was wrong with the pattern.</param>
            <param name="pattern">the invalid pattern.</param>
        </member>
        <member name="M:NGit.Errors.InvalidPatternException.GetPattern">
            <returns>the invalid pattern.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "F:NGit.Diff.SimilarityRenameDetector.BITS_PER_INDEX" -->
        <!-- Badly formed XML comment ignored for member "F:NGit.Diff.SimilarityRenameDetector.srcs" -->
        <!-- Badly formed XML comment ignored for member "F:NGit.Diff.SimilarityRenameDetector.dsts" -->
        <!-- Badly formed XML comment ignored for member "F:NGit.Diff.SimilarityRenameDetector.matrix" -->
        <member name="F:NGit.Diff.SimilarityRenameDetector.renameScore">
            <summary>Score a pair must exceed to be considered a rename.</summary>
            <remarks>Score a pair must exceed to be considered a rename.</remarks>
        </member>
        <member name="F:NGit.Diff.SimilarityRenameDetector.tableOverflow">
            <summary>
            Set if any
            <see cref="!:TableFullException">TableFullException</see>
            occurs.
            </summary>
        </member>
        <member name="M:NGit.Diff.SimilarityRenameDetector.Compute(NGit.ProgressMonitor)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Diff.SimilarityRenameDetector.BuildMatrix(NGit.ProgressMonitor)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Diff.SimilarityRenameDetector.Hash(NGit.Diff.DiffEntry.Side,NGit.Diff.DiffEntry)">
            <exception cref="T:System.IO.IOException"></exception>
            <exception cref="T:NGit.Diff.SimilarityIndex.TableFullException"></exception>
        </member>
        <member name="M:NGit.Diff.SimilarityRenameDetector.Size(NGit.Diff.DiffEntry.Side,NGit.Diff.DiffEntry)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Diff.SimilarityIndex" -->
        <!-- Badly formed XML comment ignored for member "F:NGit.Diff.SimilarityIndex.KEY_SHIFT" -->
        <member name="F:NGit.Diff.SimilarityIndex.MAX_COUNT">
            <summary>Maximum value of the count field, also mask to extract the count.</summary>
            <remarks>Maximum value of the count field, also mask to extract the count.</remarks>
        </member>
        <member name="F:NGit.Diff.SimilarityIndex.TABLE_FULL_OUT_OF_MEMORY">
            <summary>
            A special
            <see cref="T:NGit.Diff.SimilarityIndex.TableFullException">TableFullException</see>
            used in place of OutOfMemoryError.
            </summary>
        </member>
        <member name="F:NGit.Diff.SimilarityIndex.fileSize">
            <summary>Total size of the file we hashed into the structure.</summary>
            <remarks>Total size of the file we hashed into the structure.</remarks>
        </member>
        <member name="F:NGit.Diff.SimilarityIndex.idSize">
            <summary>
            Number of non-zero entries in
            <see cref="F:NGit.Diff.SimilarityIndex.idHash">idHash</see>
            .
            </summary>
        </member>
        <member name="F:NGit.Diff.SimilarityIndex.idGrowAt">
            <summary>
            <see cref="F:NGit.Diff.SimilarityIndex.idSize">idSize</see>
            that triggers
            <see cref="F:NGit.Diff.SimilarityIndex.idHash">idHash</see>
            to double in size.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:NGit.Diff.SimilarityIndex.idHash" -->
        <member name="F:NGit.Diff.SimilarityIndex.idHashBits">
            <summary>
            <code>idHash.length == 1 &lt;&lt; idHashBits</code>
            .
            </summary>
        </member>
        <member name="M:NGit.Diff.SimilarityIndex.Hash(NGit.ObjectLoader)">
            <exception cref="T:NGit.Errors.MissingObjectException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
            <exception cref="T:NGit.Diff.SimilarityIndex.TableFullException"></exception>
        </member>
        <member name="M:NGit.Diff.SimilarityIndex.Hash(System.Byte[],System.Int32,System.Int32)">
            <exception cref="T:NGit.Diff.SimilarityIndex.TableFullException"></exception>
        </member>
        <member name="M:NGit.Diff.SimilarityIndex.Hash(Sharpen.InputStream,System.Int64)">
            <exception cref="T:System.IO.IOException"></exception>
            <exception cref="T:NGit.Diff.SimilarityIndex.TableFullException"></exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Diff.SimilarityIndex.Sort" -->
        <member name="M:NGit.Diff.SimilarityIndex.Add(System.Int32,System.Int32)">
            <exception cref="T:NGit.Diff.SimilarityIndex.TableFullException"></exception>
        </member>
        <member name="M:NGit.Diff.SimilarityIndex.Pair(System.Int32,System.Int64)">
            <exception cref="T:NGit.Diff.SimilarityIndex.TableFullException"></exception>
        </member>
        <member name="M:NGit.Diff.SimilarityIndex.Grow">
            <exception cref="T:NGit.Diff.SimilarityIndex.TableFullException"></exception>
        </member>
        <member name="T:NGit.Api.Errors.InvalidMergeHeadsException">
            <summary>
            Exception thrown when a merge command was called without specifying the
            proper amount/type of merge heads.
            </summary>
            <remarks>
            Exception thrown when a merge command was called without specifying the
            proper amount/type of merge heads. E.g. a non-octopus merge strategy was
            confronted with more than one head to be merged into HEAD. Another
            case would be if a merge was called without including any head.
            </remarks>
        </member>
        <member name="M:NGit.Api.Errors.InvalidMergeHeadsException.#ctor(System.String)">
            <param name="msg"></param>
        </member>
        <member name="T:NGit.Api.Errors.CheckoutConflictException">
            <summary>
            Exception thrown when a command can't succeed because of unresolved
            conflicts.
            </summary>
            <remarks>
            Exception thrown when a command can't succeed because of unresolved
            conflicts.
            </remarks>
        </member>
        <member name="M:NGit.Api.Errors.CheckoutConflictException.#ctor(System.Collections.Generic.IList{System.String},NGit.Errors.CheckoutConflictException)">
            <summary>Translate internal exception to API exception</summary>
            <param name="conflictingPaths">list of conflicting paths</param>
            <param name="e">
            a
            <see cref="T:NGit.Errors.CheckoutConflictException">NGit.Errors.CheckoutConflictException
            	</see>
            exception
            </param>
        </member>
        <member name="M:NGit.Api.Errors.CheckoutConflictException.GetConflictingPaths">
            <returns>all the paths where unresolved conflicts have been detected</returns>
        </member>
        <member name="M:NGit.Api.Errors.CheckoutConflictException.AddConflictingPath(System.String)">
            <summary>Adds a new conflicting path</summary>
            <param name="conflictingPath"></param>
            <returns>
            
            <code>this</code>
            </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.RefComparator" -->
        <member name="F:NGit.RefComparator.INSTANCE">
            <summary>Singleton instance of RefComparator</summary>
        </member>
        <member name="M:NGit.RefComparator.Sort(System.Collections.Generic.ICollection{NGit.Ref})">
            <summary>Sorts the collection of refs, returning a new collection.</summary>
            <remarks>Sorts the collection of refs, returning a new collection.</remarks>
            <param name="refs">collection to be sorted</param>
            <returns>sorted collection of refs</returns>
        </member>
        <member name="M:NGit.RefComparator.CompareTo(NGit.Ref,System.String)">
            <summary>Compare a reference to a name.</summary>
            <remarks>Compare a reference to a name.</remarks>
            <param name="o1">the reference instance.</param>
            <param name="o2">the name to compare to.</param>
            <returns>standard Comparator result of &lt; 0, 0, &gt; 0.</returns>
        </member>
        <member name="M:NGit.RefComparator.CompareTo(NGit.Ref,NGit.Ref)">
            <summary>Compare two references by name.</summary>
            <remarks>Compare two references by name.</remarks>
            <param name="o1">the reference instance.</param>
            <param name="o2">the other reference instance.</param>
            <returns>standard Comparator result of &lt; 0, 0, &gt; 0.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.AbbreviatedObjectId" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.AbbreviatedObjectId.IsId(System.String)" -->
        <member name="M:NGit.AbbreviatedObjectId.FromString(System.Byte[],System.Int32,System.Int32)">
            <summary>Convert an AbbreviatedObjectId from hex characters (US-ASCII).</summary>
            <remarks>Convert an AbbreviatedObjectId from hex characters (US-ASCII).</remarks>
            <param name="buf">the US-ASCII buffer to read from.</param>
            <param name="offset">position to read the first character from.</param>
            <param name="end">
            one past the last position to read (<code>end-offset</code> is
            the length of the string).
            </param>
            <returns>the converted object id.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.AbbreviatedObjectId.FromObjectId(NGit.AnyObjectId)" -->
        <member name="M:NGit.AbbreviatedObjectId.FromString(System.String)">
            <summary>Convert an AbbreviatedObjectId from hex characters.</summary>
            <remarks>Convert an AbbreviatedObjectId from hex characters.</remarks>
            <param name="str">the string to read from. Must be &lt;= 40 characters.</param>
            <returns>the converted object id.</returns>
        </member>
        <member name="F:NGit.AbbreviatedObjectId.nibbles">
            <summary>Number of half-bytes used by this id.</summary>
            <remarks>Number of half-bytes used by this id.</remarks>
        </member>
        <member name="M:NGit.AbbreviatedObjectId.ToObjectId">
            <returns>
            a complete ObjectId; null if
            <see cref="P:NGit.AbbreviatedObjectId.IsComplete">IsComplete()</see>
            is false
            </returns>
        </member>
        <member name="M:NGit.AbbreviatedObjectId.PrefixCompare(NGit.AnyObjectId)">
            <summary>Compares this abbreviation to a full object id.</summary>
            <remarks>Compares this abbreviation to a full object id.</remarks>
            <param name="other">the other object id.</param>
            <returns>
            &lt;0 if this abbreviation names an object that is less than
            <code>other</code>; 0 if this abbreviation exactly matches the
            first
            <see cref="P:NGit.AbbreviatedObjectId.Length">Length()</see>
            digits of <code>other.name()</code>;
            &gt;0 if this abbreviation names an object that is after
            <code>other</code>.
            </returns>
        </member>
        <member name="M:NGit.AbbreviatedObjectId.PrefixCompare(System.Byte[],System.Int32)">
            <summary>Compare this abbreviation to a network-byte-order ObjectId.</summary>
            <remarks>Compare this abbreviation to a network-byte-order ObjectId.</remarks>
            <param name="bs">array containing the other ObjectId in network byte order.</param>
            <param name="p">
            position within
            <code>bs</code>
            to start the compare at. At least
            20 bytes, starting at this position are required.
            </param>
            <returns>
            &lt;0 if this abbreviation names an object that is less than
            <code>other</code>; 0 if this abbreviation exactly matches the
            first
            <see cref="P:NGit.AbbreviatedObjectId.Length">Length()</see>
            digits of <code>other.name()</code>;
            &gt;0 if this abbreviation names an object that is after
            <code>other</code>.
            </returns>
        </member>
        <member name="M:NGit.AbbreviatedObjectId.PrefixCompare(System.Int32[],System.Int32)">
            <summary>Compare this abbreviation to a network-byte-order ObjectId.</summary>
            <remarks>Compare this abbreviation to a network-byte-order ObjectId.</remarks>
            <param name="bs">array containing the other ObjectId in network byte order.</param>
            <param name="p">
            position within
            <code>bs</code>
            to start the compare at. At least 5
            ints, starting at this position are required.
            </param>
            <returns>
            &lt;0 if this abbreviation names an object that is less than
            <code>other</code>; 0 if this abbreviation exactly matches the
            first
            <see cref="P:NGit.AbbreviatedObjectId.Length">Length()</see>
            digits of <code>other.name()</code>;
            &gt;0 if this abbreviation names an object that is after
            <code>other</code>.
            </returns>
        </member>
        <member name="P:NGit.AbbreviatedObjectId.Length">
            <returns>number of hex digits appearing in this id</returns>
        </member>
        <member name="P:NGit.AbbreviatedObjectId.IsComplete">
            <returns>true if this ObjectId is actually a complete id.</returns>
        </member>
        <member name="P:NGit.AbbreviatedObjectId.FirstByte">
            <returns>value for a fan-out style map, only valid of length &gt;= 2.</returns>
        </member>
        <member name="P:NGit.AbbreviatedObjectId.Name">
            <returns>string form of the abbreviation, in lower case hexadecimal.</returns>
        </member>
        <member name="T:NGit.Transport.RequestNotYetReadException">
            <summary>Indicates that a client request has not yet been read from the wire.</summary>
            <remarks>Indicates that a client request has not yet been read from the wire.</remarks>
            <since>2.0</since>
        </member>
        <member name="M:NGit.Transport.RequestNotYetReadException.#ctor">
            <summary>Initialize with no message.</summary>
            <remarks>Initialize with no message.</remarks>
        </member>
        <member name="M:NGit.Transport.RequestNotYetReadException.#ctor(System.String)">
            <param name="msg">
            a message explaining the state. This message should not
            be shown to an end-user.
            </param>
        </member>
        <member name="T:NGit.Transport.AdvertiseRefsHook">
            <summary>Hook to allow callers to take over advertising refs to the client.</summary>
            <remarks>Hook to allow callers to take over advertising refs to the client.</remarks>
            <since>2.0</since>
        </member>
        <!-- Badly formed XML comment ignored for member "F:NGit.Transport.AdvertiseRefsHook.DEFAULT" -->
        <member name="M:NGit.Transport.AdvertiseRefsHook.AdvertiseRefs(NGit.Transport.UploadPack)">
            <summary>Advertise refs for upload-pack.</summary>
            <remarks>Advertise refs for upload-pack.</remarks>
            <param name="uploadPack">
            instance on which to call
            <see cref="!:UploadPack.SetAdvertisedRefs(System.Collections.Generic.IDictionary&lt;K, V&gt;)&#xA;            	">UploadPack.SetAdvertisedRefs(System.Collections.Generic.IDictionary&lt;K, V&gt;)
            	</see>
            if necessary.
            </param>
            <exception cref="T:NGit.Transport.ServiceMayNotContinueException">abort; the message will be sent to the user.
            	</exception>
            <exception cref="T:NGit.Transport.ServiceMayNotContinueException"></exception>
        </member>
        <member name="M:NGit.Transport.AdvertiseRefsHook.AdvertiseRefs(NGit.Transport.BaseReceivePack)">
            <summary>Advertise refs for receive-pack.</summary>
            <remarks>Advertise refs for receive-pack.</remarks>
            <param name="receivePack">
            instance on which to call
            <see cref="!:BaseReceivePack.SetAdvertisedRefs(System.Collections.Generic.IDictionary&lt;K, V&gt;, System.Collections.Generic.ICollection&lt;E&gt;)&#xA;            	">BaseReceivePack.SetAdvertisedRefs(System.Collections.Generic.IDictionary&lt;K, V&gt;, System.Collections.Generic.ICollection&lt;E&gt;)
            	</see>
            if necessary.
            </param>
            <exception cref="T:NGit.Transport.ServiceMayNotContinueException">abort; the message will be sent to the user.
            	</exception>
            <exception cref="T:NGit.Transport.ServiceMayNotContinueException"></exception>
        </member>
        <member name="T:NGit.Revwalk.RenameCallback">
            <summary>
            An instance of this class can be used in conjunction with a
            <see cref="T:NGit.Revwalk.FollowFilter">FollowFilter</see>
            . Whenever a rename has been detected during a revision
            walk, it will be reported here.
            </summary>
            <seealso cref="M:NGit.Revwalk.FollowFilter.SetRenameCallback(NGit.Revwalk.RenameCallback)">FollowFilter.SetRenameCallback(RenameCallback)
            	</seealso>
        </member>
        <member name="M:NGit.Revwalk.RenameCallback.Renamed(NGit.Diff.DiffEntry)">
            <summary>
            Called whenever a diff was found that is actually a rename or copy of a
            file.
            </summary>
            <remarks>
            Called whenever a diff was found that is actually a rename or copy of a
            file.
            </remarks>
            <param name="entry">the entry representing the rename/copy</param>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Api.StashListCommand" -->
        <member name="M:NGit.Api.StashListCommand.#ctor(NGit.Repository)">
            <summary>Create a new stash list command</summary>
            <param name="repo"></param>
        </member>
        <member name="M:NGit.Api.StashListCommand.Call">
            <exception cref="T:NGit.Api.Errors.GitAPIException"></exception>
            <exception cref="T:NGit.Api.Errors.InvalidRefNameException"></exception>
        </member>
        <member name="T:NGit.Diff.PatchIdDiffFormatter">
            <summary>A DiffFormatter used to calculate the patch-id of the diff.</summary>
            <remarks>A DiffFormatter used to calculate the patch-id of the diff.</remarks>
        </member>
        <member name="T:NGit.Diff.DiffFormatter">
            <summary>Format a Git style patch script.</summary>
            <remarks>Format a Git style patch script.</remarks>
        </member>
        <member name="F:NGit.Diff.DiffFormatter.EMPTY">
            <summary>Magic return content indicating it is empty or no content present.</summary>
            <remarks>Magic return content indicating it is empty or no content present.</remarks>
        </member>
        <member name="F:NGit.Diff.DiffFormatter.BINARY">
            <summary>Magic return indicating the content is binary.</summary>
            <remarks>Magic return indicating the content is binary.</remarks>
        </member>
        <member name="M:NGit.Diff.DiffFormatter.#ctor(Sharpen.OutputStream)">
            <summary>Create a new formatter with a default level of context.</summary>
            <remarks>Create a new formatter with a default level of context.</remarks>
            <param name="out">
            the stream the formatter will write line data to. This stream
            should have buffering arranged by the caller, as many small
            writes are performed to it.
            </param>
        </member>
        <member name="M:NGit.Diff.DiffFormatter.GetOutputStream">
            <returns>the stream we are outputting data to.</returns>
        </member>
        <member name="M:NGit.Diff.DiffFormatter.SetRepository(NGit.Repository)">
            <summary>Set the repository the formatter can load object contents from.</summary>
            <remarks>
            Set the repository the formatter can load object contents from.
            Once a repository has been set, the formatter must be released to ensure
            the internal ObjectReader is able to release its resources.
            </remarks>
            <param name="repository">source repository holding referenced objects.</param>
        </member>
        <member name="M:NGit.Diff.DiffFormatter.SetContext(System.Int32)">
            <summary>Change the number of lines of context to display.</summary>
            <remarks>Change the number of lines of context to display.</remarks>
            <param name="lineCount">
            number of lines of context to see before the first
            modification and after the last modification within a hunk of
            the modified file.
            </param>
        </member>
        <member name="M:NGit.Diff.DiffFormatter.SetAbbreviationLength(System.Int32)">
            <summary>Change the number of digits to show in an ObjectId.</summary>
            <remarks>Change the number of digits to show in an ObjectId.</remarks>
            <param name="count">number of digits to show in an ObjectId.</param>
        </member>
        <member name="M:NGit.Diff.DiffFormatter.SetDiffAlgorithm(NGit.Diff.DiffAlgorithm)">
            <summary>Set the algorithm that constructs difference output.</summary>
            <remarks>Set the algorithm that constructs difference output.</remarks>
            <param name="alg">the algorithm to produce text file differences.</param>
            <seealso cref="T:NGit.Diff.HistogramDiff">HistogramDiff</seealso>
        </member>
        <member name="M:NGit.Diff.DiffFormatter.SetDiffComparator(NGit.Diff.RawTextComparator)">
            <summary>Set the line equivalence function for text file differences.</summary>
            <remarks>Set the line equivalence function for text file differences.</remarks>
            <param name="cmp">
            The equivalence function used to determine if two lines of
            text are identical. The function can be changed to ignore
            various types of whitespace.
            </param>
            <seealso cref="F:NGit.Diff.RawTextComparator.DEFAULT">RawTextComparator.DEFAULT</seealso>
            <seealso cref="F:NGit.Diff.RawTextComparator.WS_IGNORE_ALL">RawTextComparator.WS_IGNORE_ALL</seealso>
            <seealso cref="F:NGit.Diff.RawTextComparator.WS_IGNORE_CHANGE">RawTextComparator.WS_IGNORE_CHANGE
            	</seealso>
            <seealso cref="F:NGit.Diff.RawTextComparator.WS_IGNORE_LEADING">RawTextComparator.WS_IGNORE_LEADING
            	</seealso>
            <seealso cref="F:NGit.Diff.RawTextComparator.WS_IGNORE_TRAILING">RawTextComparator.WS_IGNORE_TRAILING
            	</seealso>
        </member>
        <member name="M:NGit.Diff.DiffFormatter.SetBinaryFileThreshold(System.Int32)">
            <summary>Set maximum file size for text files.</summary>
            <remarks>
            Set maximum file size for text files.
            Files larger than this size will be treated as though they are binary and
            not text. Default is
            <value>#DEFAULT_BINARY_FILE_THRESHOLD</value>
            .
            </remarks>
            <param name="threshold">
            the limit, in bytes. Files larger than this size will be
            assumed to be binary, even if they aren't.
            </param>
        </member>
        <member name="M:NGit.Diff.DiffFormatter.SetOldPrefix(System.String)">
            <summary>Set the prefix applied in front of old file paths.</summary>
            <remarks>Set the prefix applied in front of old file paths.</remarks>
            <param name="prefix">
            the prefix in front of old paths. Typically this is the
            standard string
            <code>"a/"</code>
            , but may be any prefix desired by
            the caller. Must not be null. Use the empty string to have no
            prefix at all.
            </param>
        </member>
        <member name="M:NGit.Diff.DiffFormatter.GetOldPrefix">
            <summary>Get the prefix applied in front of old file paths.</summary>
            <remarks>Get the prefix applied in front of old file paths.</remarks>
            <returns>the prefix</returns>
            <since>2.0</since>
        </member>
        <member name="M:NGit.Diff.DiffFormatter.SetNewPrefix(System.String)">
            <summary>Set the prefix applied in front of new file paths.</summary>
            <remarks>Set the prefix applied in front of new file paths.</remarks>
            <param name="prefix">
            the prefix in front of new paths. Typically this is the
            standard string
            <code>"b/"</code>
            , but may be any prefix desired by
            the caller. Must not be null. Use the empty string to have no
            prefix at all.
            </param>
        </member>
        <member name="M:NGit.Diff.DiffFormatter.GetNewPrefix">
            <summary>Get the prefix applied in front of new file paths.</summary>
            <remarks>Get the prefix applied in front of new file paths.</remarks>
            <returns>the prefix</returns>
            <since>2.0</since>
        </member>
        <member name="M:NGit.Diff.DiffFormatter.IsDetectRenames">
            <returns>true if rename detection is enabled.</returns>
        </member>
        <member name="M:NGit.Diff.DiffFormatter.SetDetectRenames(System.Boolean)">
            <summary>Enable or disable rename detection.</summary>
            <remarks>
            Enable or disable rename detection.
            Before enabling rename detection the repository must be set with
            <see cref="M:NGit.Diff.DiffFormatter.SetRepository(NGit.Repository)">SetRepository(NGit.Repository)</see>
            . Once enabled the detector can be
            configured away from its defaults by obtaining the instance directly from
            <see cref="M:NGit.Diff.DiffFormatter.GetRenameDetector">GetRenameDetector()</see>
            and invoking configuration.
            </remarks>
            <param name="on">if rename detection should be enabled.</param>
        </member>
        <member name="M:NGit.Diff.DiffFormatter.GetRenameDetector">
            <returns>the rename detector if rename detection is enabled.</returns>
        </member>
        <member name="M:NGit.Diff.DiffFormatter.SetProgressMonitor(NGit.ProgressMonitor)">
            <summary>Set the progress monitor for long running rename detection.</summary>
            <remarks>Set the progress monitor for long running rename detection.</remarks>
            <param name="pm">progress monitor to receive rename detection status through.</param>
        </member>
        <member name="M:NGit.Diff.DiffFormatter.SetPathFilter(NGit.Treewalk.Filter.TreeFilter)">
            <summary>Set the filter to produce only specific paths.</summary>
            <remarks>
            Set the filter to produce only specific paths.
            If the filter is an instance of
            <see cref="T:NGit.Revwalk.FollowFilter">NGit.Revwalk.FollowFilter</see>
            , the filter path
            will be updated during successive scan or format invocations. The updated
            path can be obtained from
            <see cref="M:NGit.Diff.DiffFormatter.GetPathFilter">GetPathFilter()</see>
            .
            </remarks>
            <param name="filter">the tree filter to apply.</param>
        </member>
        <member name="M:NGit.Diff.DiffFormatter.GetPathFilter">
            <returns>the current path filter.</returns>
        </member>
        <member name="M:NGit.Diff.DiffFormatter.Flush">
            <summary>Flush the underlying output stream of this formatter.</summary>
            <remarks>Flush the underlying output stream of this formatter.</remarks>
            <exception cref="T:System.IO.IOException">the stream's own flush method threw an exception.
            	</exception>
        </member>
        <member name="M:NGit.Diff.DiffFormatter.Release">
            <summary>Release the internal ObjectReader state.</summary>
            <remarks>Release the internal ObjectReader state.</remarks>
        </member>
        <member name="M:NGit.Diff.DiffFormatter.Scan(NGit.AnyObjectId,NGit.AnyObjectId)">
            <summary>Determine the differences between two trees.</summary>
            <remarks>
            Determine the differences between two trees.
            No output is created, instead only the file paths that are different are
            returned. Callers may choose to format these paths themselves, or convert
            them into
            <see cref="T:NGit.Patch.FileHeader">NGit.Patch.FileHeader</see>
            instances with a complete edit list by
            calling
            <see cref="M:NGit.Diff.DiffFormatter.ToFileHeader(NGit.Diff.DiffEntry)">ToFileHeader(DiffEntry)</see>
            .
            </remarks>
            <param name="a">the old (or previous) side.</param>
            <param name="b">the new (or updated) side.</param>
            <returns>the paths that are different.</returns>
            <exception cref="T:System.IO.IOException">trees cannot be read or file contents cannot be read.
            	</exception>
        </member>
        <member name="M:NGit.Diff.DiffFormatter.Scan(NGit.Revwalk.RevTree,NGit.Revwalk.RevTree)">
            <summary>Determine the differences between two trees.</summary>
            <remarks>
            Determine the differences between two trees.
            No output is created, instead only the file paths that are different are
            returned. Callers may choose to format these paths themselves, or convert
            them into
            <see cref="T:NGit.Patch.FileHeader">NGit.Patch.FileHeader</see>
            instances with a complete edit list by
            calling
            <see cref="M:NGit.Diff.DiffFormatter.ToFileHeader(NGit.Diff.DiffEntry)">ToFileHeader(DiffEntry)</see>
            .
            </remarks>
            <param name="a">the old (or previous) side.</param>
            <param name="b">the new (or updated) side.</param>
            <returns>the paths that are different.</returns>
            <exception cref="T:System.IO.IOException">trees cannot be read or file contents cannot be read.
            	</exception>
        </member>
        <member name="M:NGit.Diff.DiffFormatter.Scan(NGit.Treewalk.AbstractTreeIterator,NGit.Treewalk.AbstractTreeIterator)">
            <summary>Determine the differences between two trees.</summary>
            <remarks>
            Determine the differences between two trees.
            No output is created, instead only the file paths that are different are
            returned. Callers may choose to format these paths themselves, or convert
            them into
            <see cref="T:NGit.Patch.FileHeader">NGit.Patch.FileHeader</see>
            instances with a complete edit list by
            calling
            <see cref="M:NGit.Diff.DiffFormatter.ToFileHeader(NGit.Diff.DiffEntry)">ToFileHeader(DiffEntry)</see>
            .
            </remarks>
            <param name="a">the old (or previous) side.</param>
            <param name="b">the new (or updated) side.</param>
            <returns>the paths that are different.</returns>
            <exception cref="T:System.IO.IOException">trees cannot be read or file contents cannot be read.
            	</exception>
        </member>
        <member name="M:NGit.Diff.DiffFormatter.DetectRenames(System.Collections.Generic.IList{NGit.Diff.DiffEntry})">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Diff.DiffFormatter.Format(NGit.AnyObjectId,NGit.AnyObjectId)">
            <summary>Format the differences between two trees.</summary>
            <remarks>
            Format the differences between two trees.
            The patch is expressed as instructions to modify
            <code>a</code>
            to make it
            <code>b</code>
            .
            </remarks>
            <param name="a">the old (or previous) side.</param>
            <param name="b">the new (or updated) side.</param>
            <exception cref="T:System.IO.IOException">
            trees cannot be read, file contents cannot be read, or the
            patch cannot be output.
            </exception>
        </member>
        <member name="M:NGit.Diff.DiffFormatter.Format(NGit.Revwalk.RevTree,NGit.Revwalk.RevTree)">
            <summary>Format the differences between two trees.</summary>
            <remarks>
            Format the differences between two trees.
            The patch is expressed as instructions to modify
            <code>a</code>
            to make it
            <code>b</code>
            .
            </remarks>
            <param name="a">the old (or previous) side.</param>
            <param name="b">the new (or updated) side.</param>
            <exception cref="T:System.IO.IOException">
            trees cannot be read, file contents cannot be read, or the
            patch cannot be output.
            </exception>
        </member>
        <member name="M:NGit.Diff.DiffFormatter.Format(NGit.Treewalk.AbstractTreeIterator,NGit.Treewalk.AbstractTreeIterator)">
            <summary>Format the differences between two trees.</summary>
            <remarks>
            Format the differences between two trees.
            The patch is expressed as instructions to modify
            <code>a</code>
            to make it
            <code>b</code>
            .
            </remarks>
            <param name="a">the old (or previous) side.</param>
            <param name="b">the new (or updated) side.</param>
            <exception cref="T:System.IO.IOException">
            trees cannot be read, file contents cannot be read, or the
            patch cannot be output.
            </exception>
        </member>
        <member name="M:NGit.Diff.DiffFormatter.Format``1(System.Collections.Generic.IList{``0})">
            <summary>Format a patch script from a list of difference entries.</summary>
            <remarks>
            Format a patch script from a list of difference entries. Requires
            <see cref="M:NGit.Diff.DiffFormatter.Scan(NGit.Treewalk.AbstractTreeIterator,NGit.Treewalk.AbstractTreeIterator)">Scan(NGit.Treewalk.AbstractTreeIterator, NGit.Treewalk.AbstractTreeIterator)</see>
            to have been
            called first.
            </remarks>
            <param name="entries">entries describing the affected files.</param>
            <exception cref="T:System.IO.IOException">
            a file's content cannot be read, or the output stream cannot
            be written to.
            </exception>
        </member>
        <member name="M:NGit.Diff.DiffFormatter.Format(NGit.Diff.DiffEntry)">
            <summary>Format a patch script for one file entry.</summary>
            <remarks>Format a patch script for one file entry.</remarks>
            <param name="ent">the entry to be formatted.</param>
            <exception cref="T:System.IO.IOException">
            a file's content cannot be read, or the output stream cannot
            be written to.
            </exception>
        </member>
        <member name="M:NGit.Diff.DiffFormatter.WriteGitLinkDiffText(Sharpen.OutputStream,NGit.Diff.DiffEntry)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Diff.DiffFormatter.Format(NGit.Patch.FileHeader,NGit.Diff.RawText,NGit.Diff.RawText)" -->
        <member name="M:NGit.Diff.DiffFormatter.Format(NGit.Diff.EditList,NGit.Diff.RawText,NGit.Diff.RawText)">
            <summary>Formats a list of edits in unified diff format</summary>
            <param name="edits">some differences which have been calculated between A and B</param>
            <param name="a">the text A which was compared</param>
            <param name="b">the text B which was compared</param>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:NGit.Diff.DiffFormatter.WriteContextLine(NGit.Diff.RawText,System.Int32)">
            <summary>Output a line of context (unmodified line).</summary>
            <remarks>Output a line of context (unmodified line).</remarks>
            <param name="text">RawText for accessing raw data</param>
            <param name="line">the line number within text</param>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:NGit.Diff.DiffFormatter.WriteAddedLine(NGit.Diff.RawText,System.Int32)">
            <summary>Output an added line.</summary>
            <remarks>Output an added line.</remarks>
            <param name="text">RawText for accessing raw data</param>
            <param name="line">the line number within text</param>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:NGit.Diff.DiffFormatter.WriteRemovedLine(NGit.Diff.RawText,System.Int32)">
            <summary>Output a removed line</summary>
            <param name="text">RawText for accessing raw data</param>
            <param name="line">the line number within text</param>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:NGit.Diff.DiffFormatter.WriteHunkHeader(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>Output a hunk header</summary>
            <param name="aStartLine">within first source</param>
            <param name="aEndLine">within first source</param>
            <param name="bStartLine">within second source</param>
            <param name="bEndLine">within second source</param>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:NGit.Diff.DiffFormatter.WriteRange(System.Char,System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Diff.DiffFormatter.WriteLine(System.Char,NGit.Diff.RawText,System.Int32)">
            <summary>Write a standard patch script line.</summary>
            <remarks>Write a standard patch script line.</remarks>
            <param name="prefix">prefix before the line, typically '-', '+', ' '.</param>
            <param name="text">the text object to obtain the line from.</param>
            <param name="cur">line number to output.</param>
            <exception cref="T:System.IO.IOException">the stream threw an exception while writing to it.
            	</exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Diff.DiffFormatter.ToFileHeader(NGit.Diff.DiffEntry)" -->
        <member name="M:NGit.Diff.DiffFormatter.CreateFormatResult(NGit.Diff.DiffEntry)">
            <exception cref="T:System.IO.IOException"></exception>
            <exception cref="T:NGit.Errors.CorruptObjectException"></exception>
            <exception cref="T:NGit.Errors.MissingObjectException"></exception>
        </member>
        <member name="M:NGit.Diff.DiffFormatter.Open(NGit.Diff.DiffEntry.Side,NGit.Diff.DiffEntry)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Diff.DiffFormatter.FormatHeader(Sharpen.ByteArrayOutputStream,NGit.Diff.DiffEntry)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Diff.DiffFormatter.FormatIndexLine(Sharpen.OutputStream,NGit.Diff.DiffEntry)">
            <param name="o">the stream the formatter will write line data to</param>
            <param name="ent">the DiffEntry to create the FileHeader for</param>
            <exception cref="T:System.IO.IOException">writing to the supplied stream failed.</exception>
        </member>
        <member name="M:NGit.Diff.DiffFormatter.FormatOldNewPaths(Sharpen.ByteArrayOutputStream,NGit.Diff.DiffEntry)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Diff.PatchIdDiffFormatter.#ctor">
            <summary>Initialize a formatter to compute a patch id.</summary>
            <remarks>Initialize a formatter to compute a patch id.</remarks>
        </member>
        <member name="M:NGit.Diff.PatchIdDiffFormatter.GetCalulatedPatchId">
            <summary>Should be called after having called one of the format methods</summary>
            <returns>the patch id calculated for the provided diff.</returns>
        </member>
        <member name="M:NGit.Diff.PatchIdDiffFormatter.WriteHunkHeader(System.Int32,System.Int32,System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Diff.PatchIdDiffFormatter.FormatIndexLine(Sharpen.OutputStream,NGit.Diff.DiffEntry)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Transport.JschConfigSessionFactory" -->
        <!-- Badly formed XML comment ignored for member "T:NGit.Transport.SshSessionFactory" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Transport.SshSessionFactory.GetInstance" -->
        <member name="M:NGit.Transport.SshSessionFactory.SetInstance(NGit.Transport.SshSessionFactory)">
            <summary>Change the JVM-wide factory to a different implementation.</summary>
            <remarks>Change the JVM-wide factory to a different implementation.</remarks>
            <param name="newFactory">
            factory for future sessions to be created through. If null the
            default factory will be restored.s
            </param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Transport.SshSessionFactory.GetSession(NGit.Transport.URIish,NGit.Transport.CredentialsProvider,NGit.Util.FS,System.Int32)" -->
        <member name="M:NGit.Transport.SshSessionFactory.ReleaseSession(NGit.Transport.RemoteSession)">
            <summary>Close (or recycle) a session to a host.</summary>
            <remarks>Close (or recycle) a session to a host.</remarks>
            <param name="session">
            a session previously obtained from this factory's
            <see cref="M:NGit.Transport.SshSessionFactory.GetSession(NGit.Transport.URIish,NGit.Transport.CredentialsProvider,NGit.Util.FS,System.Int32)">GetSession(URIish, CredentialsProvider, NGit.Util.FS, int)
            	</see>
            method.
            </param>
        </member>
        <member name="M:NGit.Transport.JschConfigSessionFactory.GetSession(NGit.Transport.URIish,NGit.Transport.CredentialsProvider,NGit.Util.FS,System.Int32)">
            <exception cref="T:NGit.Errors.TransportException"></exception>
        </member>
        <member name="M:NGit.Transport.JschConfigSessionFactory.CreateSession(NGit.Transport.CredentialsProvider,NGit.Util.FS,System.String,System.String,System.String,System.Int32,NGit.Transport.OpenSshConfig.Host)">
            <exception cref="T:NSch.JSchException"></exception>
        </member>
        <member name="M:NGit.Transport.JschConfigSessionFactory.CreateSession(NGit.Transport.OpenSshConfig.Host,System.String,System.String,System.Int32,NGit.Util.FS)">
            <summary>Create a new remote session for the requested address.</summary>
            <remarks>Create a new remote session for the requested address.</remarks>
            <param name="hc">host configuration</param>
            <param name="user">login to authenticate as.</param>
            <param name="host">server name to connect to.</param>
            <param name="port">port number of the SSH daemon (typically 22).</param>
            <param name="fs">
            the file system abstraction which will be necessary to
            perform certain file system operations.
            </param>
            <returns>new session instance, but otherwise unconfigured.</returns>
            <exception cref="T:NSch.JSchException">the session could not be created.</exception>
        </member>
        <member name="M:NGit.Transport.JschConfigSessionFactory.Configure(NGit.Transport.OpenSshConfig.Host,NSch.Session)">
            <summary>
            Provide additional configuration for the session based on the host
            information.
            </summary>
            <remarks>
            Provide additional configuration for the session based on the host
            information. This method could be used to supply
            <see cref="T:NSch.UserInfo">NSch.UserInfo</see>
            .
            </remarks>
            <param name="hc">host configuration</param>
            <param name="session">session to configure</param>
        </member>
        <member name="M:NGit.Transport.JschConfigSessionFactory.GetJSch(NGit.Transport.OpenSshConfig.Host,NGit.Util.FS)">
            <summary>Obtain the JSch used to create new sessions.</summary>
            <remarks>Obtain the JSch used to create new sessions.</remarks>
            <param name="hc">host configuration</param>
            <param name="fs">
            the file system abstraction which will be necessary to
            perform certain file system operations.
            </param>
            <returns>the JSch instance to use.</returns>
            <exception cref="T:NSch.JSchException">the user configuration could not be created.
            	</exception>
        </member>
        <member name="M:NGit.Transport.JschConfigSessionFactory.CreateDefaultJSch(NGit.Util.FS)">
            <param name="fs">
            the file system abstraction which will be necessary to
            perform certain file system operations.
            </param>
            <returns>the new default JSch implementation.</returns>
            <exception cref="T:NSch.JSchException">known host keys cannot be loaded.</exception>
        </member>
        <member name="M:NGit.Transport.JschConfigSessionFactory.KnownHosts(NSch.JSch,NGit.Util.FS)">
            <exception cref="T:NSch.JSchException"></exception>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Api.ResetCommand" -->
        <member name="M:NGit.Api.ResetCommand.#ctor(NGit.Repository)">
            <param name="repo"></param>
        </member>
        <member name="M:NGit.Api.ResetCommand.Call">
            <summary>
            Executes the
            <code>Reset</code>
            command. Each instance of this class should
            only be used for one invocation of the command. Don't call this method
            twice on an instance.
            </summary>
            <returns>the Ref after reset</returns>
            <exception cref="T:NGit.Api.Errors.GitAPIException">NGit.Api.Errors.GitAPIException
            	</exception>
            <exception cref="T:NGit.Api.Errors.CheckoutConflictException"></exception>
        </member>
        <member name="M:NGit.Api.ResetCommand.SetRef(System.String)">
            <param name="ref">the ref to reset to</param>
            <returns>this instance</returns>
        </member>
        <member name="M:NGit.Api.ResetCommand.SetMode(NGit.Api.ResetCommand.ResetType)">
            <param name="mode">the mode of the reset command</param>
            <returns>this instance</returns>
        </member>
        <member name="M:NGit.Api.ResetCommand.AddPath(System.String)">
            <param name="file">the file to add</param>
            <returns>this instance</returns>
        </member>
        <member name="M:NGit.Api.ResetCommand.ResetIndex(NGit.Revwalk.RevCommit)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Api.ResetCommand.CheckoutIndex(NGit.Revwalk.RevCommit)">
            <exception cref="T:System.IO.IOException"></exception>
            <exception cref="T:NGit.Api.Errors.GitAPIException"></exception>
        </member>
        <member name="M:NGit.Api.ResetCommand.ResetMerge">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Api.ResetCommand.ResetCherryPick">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="T:NGit.Api.ResetCommand.ResetType">
            <summary>Kind of reset</summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Api.CheckoutCommand" -->
        <member name="M:NGit.Api.CheckoutCommand.#ctor(NGit.Repository)">
            <param name="repo"></param>
        </member>
        <member name="M:NGit.Api.CheckoutCommand.Call">
            <exception cref="T:NGit.Api.Errors.RefAlreadyExistsException">
            when trying to create (without force) a branch with a name
            that already exists
            </exception>
            <exception cref="T:NGit.Api.Errors.RefNotFoundException">if the start point or branch can not be found
            	</exception>
            <exception cref="T:NGit.Api.Errors.InvalidRefNameException">
            if the provided name is <code>null</code> or otherwise
            invalid
            </exception>
            <exception cref="T:NGit.Api.Errors.CheckoutConflictException">if the checkout results in a conflict
            	</exception>
            <returns>the newly created branch</returns>
            <exception cref="T:NGit.Api.Errors.GitAPIException"></exception>
        </member>
        <member name="M:NGit.Api.CheckoutCommand.AddPath(System.String)">
            <param name="path">Path to update in the working tree and index.</param>
            <returns>
            
            <code>this</code>
            </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Api.CheckoutCommand.SetAllPaths(System.Boolean)" -->
        <member name="M:NGit.Api.CheckoutCommand.CheckoutPaths">
            <summary>Checkout paths into index and working directory</summary>
            <returns>this instance</returns>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
            <exception cref="T:NGit.Api.Errors.RefNotFoundException">NGit.Api.Errors.RefNotFoundException
            	</exception>
        </member>
        <member name="M:NGit.Api.CheckoutCommand.GetStartPoint">
            <exception cref="T:NGit.Errors.AmbiguousObjectException"></exception>
            <exception cref="T:NGit.Api.Errors.RefNotFoundException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Api.CheckoutCommand.ProcessOptions">
            <exception cref="T:NGit.Api.Errors.InvalidRefNameException"></exception>
        </member>
        <member name="M:NGit.Api.CheckoutCommand.SetName(System.String)">
            <param name="name">the name of the new branch</param>
            <returns>this instance</returns>
        </member>
        <member name="M:NGit.Api.CheckoutCommand.SetCreateBranch(System.Boolean)">
            <param name="createBranch">
            if <code>true</code> a branch will be created as part of the
            checkout and set to the specified start point
            </param>
            <returns>this instance</returns>
        </member>
        <member name="M:NGit.Api.CheckoutCommand.SetForce(System.Boolean)">
            <param name="force">
            if <code>true</code> and the branch with the given name
            already exists, the start-point of an existing branch will be
            set to a new start-point; if false, the existing branch will
            not be changed
            </param>
            <returns>this instance</returns>
        </member>
        <member name="M:NGit.Api.CheckoutCommand.SetStartPoint(System.String)">
            <param name="startPoint">
            corresponds to the start-point option; if <code>null</code>,
            the current HEAD will be used
            </param>
            <returns>this instance</returns>
        </member>
        <member name="M:NGit.Api.CheckoutCommand.SetStartPoint(NGit.Revwalk.RevCommit)">
            <param name="startCommit">
            corresponds to the start-point option; if <code>null</code>,
            the current HEAD will be used
            </param>
            <returns>this instance</returns>
        </member>
        <member name="M:NGit.Api.CheckoutCommand.SetUpstreamMode(NGit.Api.CreateBranchCommand.SetupUpstreamMode)">
            <param name="mode">
            corresponds to the --track/--no-track options; may be
            <code>null</code>
            </param>
            <returns>this instance</returns>
        </member>
        <member name="M:NGit.Api.CheckoutCommand.GetResult">
            <returns>the result</returns>
        </member>
        <member name="F:NGit.Storage.File.WriteConfig.KEY">
            <summary>
            Key for
            <see cref="M:NGit.Config.Get``1(NGit.Config.SectionParser{``0})">NGit.Config.Get&lt;T&gt;(NGit.Config.SectionParser&lt;T&gt;)
            	</see>
            .
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Api.ListBranchCommand" -->
        <member name="M:NGit.Api.ListBranchCommand.#ctor(NGit.Repository)">
            <param name="repo"></param>
        </member>
        <member name="M:NGit.Api.ListBranchCommand.Call">
            <exception cref="T:NGit.Api.Errors.GitAPIException"></exception>
        </member>
        <member name="M:NGit.Api.ListBranchCommand.SetListMode(NGit.Api.ListBranchCommand.ListMode)">
            <param name="listMode">
            optional: corresponds to the -r/-a options; by default, only
            local branches will be listed
            </param>
            <returns>this instance</returns>
        </member>
        <member name="T:NGit.Api.ListBranchCommand.ListMode">
            <summary>
            The modes available for listing branches (corresponding to the -r and -a
            options)
            </summary>
        </member>
        <member name="T:NGit.Api.PullResult">
            <summary>
            Encapsulates the result of a
            <see cref="T:NGit.Api.PullCommand">PullCommand</see>
            </summary>
        </member>
        <member name="M:NGit.Api.PullResult.GetFetchResult">
            <returns>the fetch result, or <code>null</code></returns>
        </member>
        <member name="M:NGit.Api.PullResult.GetMergeResult">
            <returns>the merge result, or <code>null</code></returns>
        </member>
        <member name="M:NGit.Api.PullResult.GetRebaseResult">
            <returns>the rebase result, or <code>null</code></returns>
        </member>
        <member name="M:NGit.Api.PullResult.GetFetchedFrom">
            <returns>
            the name of the remote configuration from which fetch was tried,
            or <code>null</code>
            </returns>
        </member>
        <member name="M:NGit.Api.PullResult.IsSuccessful">
            <returns>whether the pull was successful</returns>
        </member>
        <member name="T:NGit.Errors.MissingBundlePrerequisiteException">
            <summary>Indicates a base/common object was required, but is not found.</summary>
            <remarks>Indicates a base/common object was required, but is not found.</remarks>
        </member>
        <member name="M:NGit.Errors.MissingBundlePrerequisiteException.#ctor(NGit.Transport.URIish,System.Collections.Generic.IDictionary{NGit.ObjectId,System.String})">
            <summary>Constructs a MissingBundlePrerequisiteException for a set of objects.</summary>
            <remarks>Constructs a MissingBundlePrerequisiteException for a set of objects.</remarks>
            <param name="uri">URI used for transport</param>
            <param name="missingCommits">
            the Map of the base/common object(s) we don't have. Keys are
            ids of the missing objects and values are short descriptions.
            </param>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Util.Base64" -->
        <member name="F:NGit.Util.Base64.EQUALS_SIGN">
            <summary>The equals sign (=) as a byte.</summary>
            <remarks>The equals sign (=) as a byte.</remarks>
        </member>
        <member name="F:NGit.Util.Base64.EQUALS_SIGN_DEC">
            <summary>Indicates equals sign in encoding.</summary>
            <remarks>Indicates equals sign in encoding.</remarks>
        </member>
        <member name="F:NGit.Util.Base64.WHITE_SPACE_DEC">
            <summary>Indicates white space in encoding.</summary>
            <remarks>Indicates white space in encoding.</remarks>
        </member>
        <member name="F:NGit.Util.Base64.INVALID_DEC">
            <summary>Indicates an invalid byte during decoding.</summary>
            <remarks>Indicates an invalid byte during decoding.</remarks>
        </member>
        <member name="F:NGit.Util.Base64.UTF_8">
            <summary>Preferred encoding.</summary>
            <remarks>Preferred encoding.</remarks>
        </member>
        <member name="F:NGit.Util.Base64.ENC">
            <summary>The 64 valid Base64 values.</summary>
            <remarks>The 64 valid Base64 values.</remarks>
        </member>
        <member name="F:NGit.Util.Base64.DEC">
            <summary>
            Translates a Base64 value to either its 6-bit reconstruction value or a
            negative number indicating some other meaning.
            </summary>
            <remarks>
            Translates a Base64 value to either its 6-bit reconstruction value or a
            negative number indicating some other meaning. The table is only 7 bits
            wide, as the 8th bit is discarded during decoding.
            </remarks>
        </member>
        <member name="M:NGit.Util.Base64.#ctor">
            <summary>Defeats instantiation.</summary>
            <remarks>Defeats instantiation.</remarks>
        </member>
        <member name="M:NGit.Util.Base64.Encode3to4(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
            <summary>
            Encodes up to three bytes of the array <var>source</var> and writes the
            resulting four Base64 bytes to <var>destination</var>.
            </summary>
            <remarks>
            Encodes up to three bytes of the array <var>source</var> and writes the
            resulting four Base64 bytes to <var>destination</var>. The source and
            destination arrays can be manipulated anywhere along their length by
            specifying <var>srcOffset</var> and <var>destOffset</var>. This method
            does not check to make sure your arrays are large enough to accommodate
            <var>srcOffset</var> + 3 for the <var>source</var> array or
            <var>destOffset</var> + 4 for the <var>destination</var> array. The
            actual number of significant bytes in your array is given by
            <var>numSigBytes</var>.
            </remarks>
            <param name="source">the array to convert</param>
            <param name="srcOffset">the index where conversion begins</param>
            <param name="numSigBytes">the number of significant bytes in your array</param>
            <param name="destination">the array to hold the conversion</param>
            <param name="destOffset">the index where output will be put</param>
        </member>
        <member name="M:NGit.Util.Base64.EncodeBytes(System.Byte[])">
            <summary>Encodes a byte array into Base64 notation.</summary>
            <remarks>Encodes a byte array into Base64 notation.</remarks>
            <param name="source">The data to convert</param>
            <returns>encoded base64 representation of source.</returns>
        </member>
        <member name="M:NGit.Util.Base64.EncodeBytes(System.Byte[],System.Int32,System.Int32)">
            <summary>Encodes a byte array into Base64 notation.</summary>
            <remarks>Encodes a byte array into Base64 notation.</remarks>
            <param name="source">The data to convert</param>
            <param name="off">Offset in array where conversion should begin</param>
            <param name="len">Length of data to convert</param>
            <returns>encoded base64 representation of source.</returns>
        </member>
        <member name="M:NGit.Util.Base64.Decode4to3(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Decodes four bytes from array <var>source</var> and writes the resulting
            bytes (up to three of them) to <var>destination</var>.
            </summary>
            <remarks>
            Decodes four bytes from array <var>source</var> and writes the resulting
            bytes (up to three of them) to <var>destination</var>. The source and
            destination arrays can be manipulated anywhere along their length by
            specifying <var>srcOffset</var> and <var>destOffset</var>. This method
            does not check to make sure your arrays are large enough to accommodate
            <var>srcOffset</var> + 4 for the <var>source</var> array or
            <var>destOffset</var> + 3 for the <var>destination</var> array. This
            method returns the actual number of bytes that were converted from the
            Base64 encoding.
            </remarks>
            <param name="source">the array to convert</param>
            <param name="srcOffset">the index where conversion begins</param>
            <param name="destination">the array to hold the conversion</param>
            <param name="destOffset">the index where output will be put</param>
            <returns>the number of decoded bytes converted</returns>
        </member>
        <member name="M:NGit.Util.Base64.DecodeBytes(System.Byte[],System.Int32,System.Int32)">
            <summary>Low-level decoding ASCII characters from a byte array.</summary>
            <remarks>Low-level decoding ASCII characters from a byte array.</remarks>
            <param name="source">The Base64 encoded data</param>
            <param name="off">The offset of where to begin decoding</param>
            <param name="len">The length of characters to decode</param>
            <returns>decoded data</returns>
            <exception cref="T:System.ArgumentException">the input is not a valid Base64 sequence.
            	</exception>
        </member>
        <member name="M:NGit.Util.Base64.DecodeBytes(System.String)">
            <summary>Decodes data from Base64 notation.</summary>
            <remarks>Decodes data from Base64 notation.</remarks>
            <param name="s">the string to decode</param>
            <returns>the decoded data</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Storage.File.RefDirectory" -->
        <!-- Badly formed XML comment ignored for member "T:NGit.RefDatabase" -->
        <!-- Badly formed XML comment ignored for member "F:NGit.RefDatabase.MAX_SYMBOLIC_REF_DEPTH" -->
        <!-- Badly formed XML comment ignored for member "F:NGit.RefDatabase.SEARCH_PATH" -->
        <member name="F:NGit.RefDatabase.ALL">
            <summary>
            Magic value for
            <see cref="M:NGit.RefDatabase.GetRefs(System.String)">GetRefs(string)</see>
            to return all references.
            </summary>
        </member>
        <member name="M:NGit.RefDatabase.Create">
            <summary>Initialize a new reference database at this location.</summary>
            <remarks>Initialize a new reference database at this location.</remarks>
            <exception cref="T:System.IO.IOException">the database could not be created.</exception>
        </member>
        <member name="M:NGit.RefDatabase.Close">
            <summary>Close any resources held by this database.</summary>
            <remarks>Close any resources held by this database.</remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.RefDatabase.IsNameConflicting(System.String)" -->
        <member name="M:NGit.RefDatabase.NewUpdate(System.String,System.Boolean)">
            <summary>Create a new update command to create, modify or delete a reference.</summary>
            <remarks>Create a new update command to create, modify or delete a reference.</remarks>
            <param name="name">the name of the reference.</param>
            <param name="detach">
            if
            <code>true</code>
            and
            <code>name</code>
            is currently a
            <see cref="T:NGit.SymbolicRef">SymbolicRef</see>
            , the update will replace it with an
            <see cref="T:NGit.ObjectIdRef">ObjectIdRef</see>
            . Otherwise, the update will recursively
            traverse
            <see cref="T:NGit.SymbolicRef">SymbolicRef</see>
            s and operate on the leaf
            <see cref="T:NGit.ObjectIdRef">ObjectIdRef</see>
            .
            </param>
            <returns>a new update for the requested name; never null.</returns>
            <exception cref="T:System.IO.IOException">the reference space cannot be accessed.</exception>
        </member>
        <member name="M:NGit.RefDatabase.NewRename(System.String,System.String)">
            <summary>Create a new update command to rename a reference.</summary>
            <remarks>Create a new update command to rename a reference.</remarks>
            <param name="fromName">name of reference to rename from</param>
            <param name="toName">name of reference to rename to</param>
            <returns>an update command that knows how to rename a branch to another.</returns>
            <exception cref="T:System.IO.IOException">the reference space cannot be accessed.</exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.RefDatabase.NewBatchUpdate" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.RefDatabase.GetRef(System.String)" -->
        <member name="M:NGit.RefDatabase.GetRefs(System.String)">
            <summary>Get a section of the reference namespace.</summary>
            <remarks>Get a section of the reference namespace.</remarks>
            <param name="prefix">
            prefix to search the namespace with; must end with
            <code>/</code>
            .
            If the empty string (
            <see cref="F:NGit.RefDatabase.ALL">ALL</see>
            ), obtain a complete snapshot
            of all references.
            </param>
            <returns>
            modifiable map that is a complete snapshot of the current
            reference namespace, with
            <code>prefix</code>
            removed from the start
            of each key. The map can be an unsorted map.
            </returns>
            <exception cref="T:System.IO.IOException">the reference space cannot be accessed.</exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.RefDatabase.GetAdditionalRefs" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.RefDatabase.Peel(NGit.Ref)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.RefDatabase.Refresh" -->
        <member name="F:NGit.Storage.File.RefDirectory.SYMREF">
            <summary>Magic string denoting the start of a symbolic reference file.</summary>
            <remarks>Magic string denoting the start of a symbolic reference file.</remarks>
        </member>
        <member name="F:NGit.Storage.File.RefDirectory.PACKED_REFS_HEADER">
            <summary>Magic string denoting the header of a packed-refs file.</summary>
            <remarks>Magic string denoting the header of a packed-refs file.</remarks>
        </member>
        <member name="F:NGit.Storage.File.RefDirectory.PACKED_REFS_PEELED">
            <summary>If in the header, denotes the file has peeled data.</summary>
            <remarks>If in the header, denotes the file has peeled data.</remarks>
        </member>
        <member name="F:NGit.Storage.File.RefDirectory.additionalRefsNames">
            <summary>The names of the additional refs supported by this class</summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:NGit.Storage.File.RefDirectory.looseRefs" -->
        <member name="F:NGit.Storage.File.RefDirectory.packedRefs">
            <summary>Immutable sorted list of packed references.</summary>
            <remarks>Immutable sorted list of packed references.</remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "F:NGit.Storage.File.RefDirectory.modCnt" -->
        <!-- Badly formed XML comment ignored for member "F:NGit.Storage.File.RefDirectory.lastNotifiedModCnt" -->
        <member name="M:NGit.Storage.File.RefDirectory.Create">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.RefDirectory.IsNameConflicting(System.String)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.RefDirectory.GetRef(System.String)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.RefDirectory.GetRefs(System.String)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.RefDirectory.GetAdditionalRefs">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.RefDirectory.Peel(NGit.Ref)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.RefDirectory.DoPeel(NGit.Ref)">
            <exception cref="T:NGit.Errors.MissingObjectException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.RefDirectory.NewUpdate(System.String,System.Boolean)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.RefDirectory.NewRename(System.String,System.String)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.RefDirectory.Delete(NGit.Storage.File.RefDirectoryUpdate)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.RefDirectory.Log(NGit.RefUpdate,System.String,System.Boolean)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.RefDirectory.Resolve(NGit.Ref,System.Int32,System.String,NGit.Util.RefList{NGit.Storage.File.RefDirectory.LooseRef},NGit.Util.RefList{NGit.Ref})">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.RefDirectory.GetPackedRefs">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.RefDirectory.ReadPackedRefs">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.RefDirectory.ParsePackedRefs(Sharpen.BufferedReader)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.RefDirectory.CommitPackedRefs(NGit.Storage.File.LockFile,NGit.Util.RefList{NGit.Ref},NGit.Storage.File.RefDirectory.PackedRefList)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.RefDirectory.ReadRef(System.String,NGit.Util.RefList{NGit.Ref})">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.RefDirectory.ScanRef(NGit.Storage.File.RefDirectory.LooseRef,System.String)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.RefDirectory.FireRefsChanged">
            <summary>If the parent should fire listeners, fires them.</summary>
            <remarks>If the parent should fire listeners, fires them.</remarks>
        </member>
        <member name="M:NGit.Storage.File.RefDirectory.NewTemporaryUpdate">
            <summary>Create a reference update to write a temporary reference.</summary>
            <remarks>Create a reference update to write a temporary reference.</remarks>
            <returns>an update for a new temporary reference.</returns>
            <exception cref="T:System.IO.IOException">a temporary name cannot be allocated.</exception>
        </member>
        <member name="M:NGit.Storage.File.RefDirectory.FileFor(System.String)">
            <summary>Locate the file on disk for a single reference name.</summary>
            <remarks>Locate the file on disk for a single reference name.</remarks>
            <param name="name">
            name of the ref, relative to the Git repository top level
            directory (so typically starts with refs/).
            </param>
            <returns>the loose file location.</returns>
        </member>
        <member name="M:NGit.Storage.File.RefDirectory.Delete(Sharpen.FilePath,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="T:NGit.RefWriter">
            <summary>
            Writes out refs to the
            <see cref="F:NGit.Constants.INFO_REFS">Constants.INFO_REFS</see>
            and
            <see cref="F:NGit.Constants.PACKED_REFS">Constants.PACKED_REFS</see>
            files.
            This class is abstract as the writing of the files must be handled by the
            caller. This is because it is used by transport classes as well.
            </summary>
        </member>
        <member name="M:NGit.RefWriter.#ctor(System.Collections.Generic.ICollection{NGit.Ref})">
            <param name="refs">
            the complete set of references. This should have been computed
            by applying updates to the advertised refs already discovered.
            </param>
        </member>
        <member name="M:NGit.RefWriter.#ctor(System.Collections.Generic.IDictionary{System.String,NGit.Ref})">
            <param name="refs">
            the complete set of references. This should have been computed
            by applying updates to the advertised refs already discovered.
            </param>
        </member>
        <member name="M:NGit.RefWriter.#ctor(NGit.Util.RefList{NGit.Ref})">
            <param name="refs">
            the complete set of references. This should have been computed
            by applying updates to the advertised refs already discovered.
            </param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.RefWriter.WriteInfoRefs" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.RefWriter.WritePackedRefs" -->
        <member name="M:NGit.RefWriter.WriteFile(System.String,System.Byte[])">
            <summary>
            Handles actual writing of ref files to the git repository, which may
            differ slightly depending on the destination and transport.
            </summary>
            <remarks>
            Handles actual writing of ref files to the git repository, which may
            differ slightly depending on the destination and transport.
            </remarks>
            <param name="file">path to ref file.</param>
            <param name="content">byte content of file to be written.</param>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:NGit.Storage.File.RefDirectory._RefWriter_712.WriteFile(System.String,System.Byte[])">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Util.RefList`1" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Util.RefList`1.EmptyList``1" -->
        <member name="M:NGit.Util.RefList`1.#ctor(NGit.Util.RefList{`0})">
            <summary>Initialize this list to use the same backing array as another list.</summary>
            <remarks>Initialize this list to use the same backing array as another list.</remarks>
            <param name="src">the source list.</param>
        </member>
        <member name="M:NGit.Util.RefList`1.AsList">
            <returns>
            this cast as an immutable, standard
            <see cref="!:System.Collections.IList&lt;E&gt;">System.Collections.IList&lt;E&gt;</see>
            .
            </returns>
        </member>
        <member name="M:NGit.Util.RefList`1.Size">
            <returns>number of items in this list.</returns>
        </member>
        <member name="M:NGit.Util.RefList`1.IsEmpty">
            <returns>true if the size of this list is 0.</returns>
        </member>
        <member name="M:NGit.Util.RefList`1.Find(System.String)">
            <summary>Locate an entry by name.</summary>
            <remarks>Locate an entry by name.</remarks>
            <param name="name">the name of the reference to find.</param>
            <returns>
            the index the reference is at. If the entry is not present
            returns a negative value. The insertion position for the given
            name can be computed from
            <code>-(index + 1)</code>
            .
            </returns>
        </member>
        <member name="M:NGit.Util.RefList`1.Contains(System.String)">
            <summary>Determine if a reference is present.</summary>
            <remarks>Determine if a reference is present.</remarks>
            <param name="name">name of the reference to find.</param>
            <returns>true if the reference is present; false if it is not.</returns>
        </member>
        <member name="M:NGit.Util.RefList`1.Get(System.String)">
            <summary>Get a reference object by name.</summary>
            <remarks>Get a reference object by name.</remarks>
            <param name="name">the name of the reference.</param>
            <returns>the reference object; null if it does not exist in this list.</returns>
        </member>
        <member name="M:NGit.Util.RefList`1.Get(System.Int32)">
            <summary>Get the reference at a particular index.</summary>
            <remarks>Get the reference at a particular index.</remarks>
            <param name="idx">
            the index to obtain. Must be
            <code>0 &lt;= idx &lt; size()</code>
            .
            </param>
            <returns>the reference value, never null.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Util.RefList`1.Copy(System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Util.RefList`1.Set(System.Int32,`0)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Util.RefList`1.Add(System.Int32,`0)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Util.RefList`1.Remove(System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Util.RefList`1.Put(`0)" -->
        <member name="T:NGit.ObjectIdRef.PeeledTag">
            <summary>An annotated tag whose peeled object has been cached.</summary>
            <remarks>An annotated tag whose peeled object has been cached.</remarks>
        </member>
        <member name="T:NGit.ObjectIdRef">
            <summary>
            A
            <see cref="T:NGit.Ref">Ref</see>
            that points directly at an
            <see cref="T:NGit.ObjectId">ObjectId</see>
            .
            </summary>
        </member>
        <member name="M:NGit.ObjectIdRef.#ctor(NGit.RefStorage,System.String,NGit.ObjectId)">
            <summary>Create a new ref pairing.</summary>
            <remarks>Create a new ref pairing.</remarks>
            <param name="st">method used to store this ref.</param>
            <param name="name">name of this ref.</param>
            <param name="id">
            current value of the ref. May be null to indicate a ref that
            does not exist yet.
            </param>
        </member>
        <member name="T:NGit.ObjectIdRef.Unpeeled">
            <summary>Any reference whose peeled value is not yet known.</summary>
            <remarks>Any reference whose peeled value is not yet known.</remarks>
        </member>
        <member name="M:NGit.ObjectIdRef.Unpeeled.#ctor(NGit.RefStorage,System.String,NGit.ObjectId)">
            <summary>Create a new ref pairing.</summary>
            <remarks>Create a new ref pairing.</remarks>
            <param name="st">method used to store this ref.</param>
            <param name="name">name of this ref.</param>
            <param name="id">
            current value of the ref. May be null to indicate a ref
            that does not exist yet.
            </param>
        </member>
        <member name="T:NGit.ObjectIdRef.PeeledTag">
            <summary>An annotated tag whose peeled object has been cached.</summary>
            <remarks>An annotated tag whose peeled object has been cached.</remarks>
        </member>
        <member name="M:NGit.ObjectIdRef.PeeledTag.#ctor(NGit.RefStorage,System.String,NGit.ObjectId,NGit.ObjectId)">
            <summary>Create a new ref pairing.</summary>
            <remarks>Create a new ref pairing.</remarks>
            <param name="st">method used to store this ref.</param>
            <param name="name">name of this ref.</param>
            <param name="id">current value of the ref.</param>
            <param name="p">
            the first non-tag object that tag
            <code>id</code>
            points to.
            </param>
        </member>
        <member name="T:NGit.ObjectIdRef.PeeledNonTag">
            <summary>A reference to a non-tag object coming from a cached source.</summary>
            <remarks>A reference to a non-tag object coming from a cached source.</remarks>
        </member>
        <member name="M:NGit.ObjectIdRef.PeeledNonTag.#ctor(NGit.RefStorage,System.String,NGit.ObjectId)">
            <summary>Create a new ref pairing.</summary>
            <remarks>Create a new ref pairing.</remarks>
            <param name="st">method used to store this ref.</param>
            <param name="name">name of this ref.</param>
            <param name="id">
            current value of the ref. May be null to indicate a ref
            that does not exist yet.
            </param>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.SymbolicRef" -->
        <member name="M:NGit.SymbolicRef.#ctor(System.String,NGit.Ref)">
            <summary>Create a new ref pairing.</summary>
            <remarks>Create a new ref pairing.</remarks>
            <param name="refName">name of this ref.</param>
            <param name="target">the ref we reference and derive our value from.</param>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.ObjectDatabase" -->
        <member name="M:NGit.ObjectDatabase.#ctor">
            <summary>Initialize a new database instance for access.</summary>
            <remarks>Initialize a new database instance for access.</remarks>
        </member>
        <member name="M:NGit.ObjectDatabase.Exists">
            <summary>Does this database exist yet?</summary>
            <returns>
            true if this database is already created; false if the caller
            should invoke
            <see cref="M:NGit.ObjectDatabase.Create">Create()</see>
            to create this database location.
            </returns>
        </member>
        <member name="M:NGit.ObjectDatabase.Create">
            <summary>Initialize a new object database at this location.</summary>
            <remarks>Initialize a new object database at this location.</remarks>
            <exception cref="T:System.IO.IOException">the database could not be created.</exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.ObjectDatabase.NewInserter" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.ObjectDatabase.NewReader" -->
        <member name="M:NGit.ObjectDatabase.Close">
            <summary>Close any resources held by this database.</summary>
            <remarks>Close any resources held by this database.</remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.ObjectDatabase.Has(NGit.AnyObjectId)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.ObjectDatabase.Open(NGit.AnyObjectId)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.ObjectDatabase.Open(NGit.AnyObjectId,System.Int32)" -->
        <member name="M:NGit.ObjectDatabase.NewCachedDatabase">
            <summary>Create a new cached database instance over this database.</summary>
            <remarks>
            Create a new cached database instance over this database. This instance might
            optimize queries by caching some information about database. So some modifications
            done after instance creation might fail to be noticed.
            </remarks>
            <returns>new cached database instance</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Storage.File.FileObjectDatabase.Has(NGit.AnyObjectId)" -->
        <member name="M:NGit.Storage.File.FileObjectDatabase.FileFor(NGit.AnyObjectId)">
            <summary>Compute the location of a loose object file.</summary>
            <remarks>Compute the location of a loose object file.</remarks>
            <param name="objectId">identity of the loose object to map to the directory.</param>
            <returns>location of the object, if it were to exist as a loose object.</returns>
        </member>
        <member name="M:NGit.Storage.File.FileObjectDatabase.Resolve(System.Collections.Generic.ICollection{NGit.ObjectId},NGit.AbbreviatedObjectId)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Storage.File.FileObjectDatabase.OpenObject(NGit.Storage.File.WindowCursor,NGit.AnyObjectId)" -->
        <member name="M:NGit.Storage.File.FileObjectDatabase.OpenObjectImpl1(NGit.Storage.File.WindowCursor,NGit.AnyObjectId)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.FileObjectDatabase.OpenObjectImpl2(NGit.Storage.File.WindowCursor,System.String,NGit.AnyObjectId)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.FileObjectDatabase.GetObjectSize(NGit.Storage.File.WindowCursor,NGit.AnyObjectId)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.FileObjectDatabase.GetObjectSizeImpl1(NGit.Storage.File.WindowCursor,NGit.AnyObjectId)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.FileObjectDatabase.GetObjectSizeImpl2(NGit.Storage.File.WindowCursor,System.String,NGit.AnyObjectId)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.FileObjectDatabase.SelectObjectRepresentation(NGit.Storage.Pack.PackWriter,NGit.Storage.Pack.ObjectToPack,NGit.Storage.File.WindowCursor)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.FileObjectDatabase.GetCachedPacks">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.FileObjectDatabase.OpenObject1(NGit.Storage.File.WindowCursor,NGit.AnyObjectId)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.FileObjectDatabase.OpenObject2(NGit.Storage.File.WindowCursor,System.String,NGit.AnyObjectId)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.FileObjectDatabase.GetObjectSize1(NGit.Storage.File.WindowCursor,NGit.AnyObjectId)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.FileObjectDatabase.GetObjectSize2(NGit.Storage.File.WindowCursor,System.String,NGit.AnyObjectId)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.FileObjectDatabase.InsertUnpackedObject(Sharpen.FilePath,NGit.ObjectId,System.Boolean)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.FileObjectDatabase.OpenPack(Sharpen.FilePath,Sharpen.FilePath)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.FileObjectDatabase.AlternateHandle.GetCachedPacks">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Revwalk.RewriteGenerator" -->
        <member name="F:NGit.Revwalk.RewriteGenerator.DUPLICATE">
            <summary>
            For
            <see cref="M:NGit.Revwalk.RewriteGenerator.Cleanup(NGit.Revwalk.RevCommit[])">Cleanup(RevCommit[])</see>
            to remove duplicate parents.
            </summary>
        </member>
        <member name="M:NGit.Revwalk.RewriteGenerator.Next">
            <exception cref="T:NGit.Errors.MissingObjectException"></exception>
            <exception cref="T:NGit.Errors.IncorrectObjectTypeException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Revwalk.RevCommitList`1" -->
        <!-- Badly formed XML comment ignored for member "T:NGit.Revwalk.RevObjectList`1" -->
        <!-- Badly formed XML comment ignored for member "F:NGit.Revwalk.RevObjectList`1.contents" -->
        <member name="F:NGit.Revwalk.RevObjectList`1.size">
            <summary>Current number of elements in the list.</summary>
            <remarks>Current number of elements in the list.</remarks>
        </member>
        <member name="M:NGit.Revwalk.RevObjectList`1.#ctor">
            <summary>Create an empty object list.</summary>
            <remarks>Create an empty object list.</remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Revwalk.RevCommitList`1.ApplyFlag(NGit.Revwalk.Filter.RevFilter,NGit.Revwalk.RevFlag)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Revwalk.RevCommitList`1.ApplyFlag(NGit.Revwalk.Filter.RevFilter,NGit.Revwalk.RevFlag,System.Int32,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Revwalk.RevCommitList`1.ClearFlag(NGit.Revwalk.RevFlag)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Revwalk.RevCommitList`1.ClearFlag(NGit.Revwalk.RevFlag,System.Int32,System.Int32)" -->
        <member name="M:NGit.Revwalk.RevCommitList`1.IndexOf(NGit.Revwalk.RevFlag,System.Int32)">
            <summary>Find the next commit that has the given flag set.</summary>
            <remarks>Find the next commit that has the given flag set.</remarks>
            <param name="flag">the flag to test commits against.</param>
            <param name="begin">
            first commit index to test at. Applications may wish to begin
            at 0, to test the first commit in the list.
            </param>
            <returns>
            index of the first commit at or after index <code>begin</code>
            that has the specified flag set on it; -1 if no match is found.
            </returns>
        </member>
        <member name="M:NGit.Revwalk.RevCommitList`1.LastIndexOf(NGit.Revwalk.RevFlag,System.Int32)">
            <summary>Find the next commit that has the given flag set.</summary>
            <remarks>Find the next commit that has the given flag set.</remarks>
            <param name="flag">the flag to test commits against.</param>
            <param name="begin">
            first commit index to test at. Applications may wish to begin
            at <code>size()-1</code>, to test the last commit in the
            list.
            </param>
            <returns>
            index of the first commit at or before index <code>begin</code>
            that has the specified flag set on it; -1 if no match is found.
            </returns>
        </member>
        <member name="M:NGit.Revwalk.RevCommitList`1.Source(NGit.Revwalk.RevWalk)">
            <summary>Set the revision walker this list populates itself from.</summary>
            <remarks>Set the revision walker this list populates itself from.</remarks>
            <param name="w">the walker to populate from.</param>
            <seealso cref="M:NGit.Revwalk.RevCommitList`1.FillTo(System.Int32)">RevCommitList&lt;E&gt;.FillTo(int)</seealso>
        </member>
        <member name="M:NGit.Revwalk.RevCommitList`1.IsPending">
            <summary>Is this list still pending more items?</summary>
            <returns>
            true if
            <see cref="M:NGit.Revwalk.RevCommitList`1.FillTo(System.Int32)">RevCommitList&lt;E&gt;.FillTo(int)</see>
            might be able to extend the list
            size when called.
            </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Revwalk.RevCommitList`1.FillTo(System.Int32)" -->
        <member name="M:NGit.Revwalk.RevCommitList`1.FillTo(NGit.Revwalk.RevCommit,System.Int32)">
            <summary>Ensures all commits until the given commit are loaded.</summary>
            <remarks>
            Ensures all commits until the given commit are loaded. The revision
            walker specified by
            <see cref="M:NGit.Revwalk.RevCommitList`1.Source(NGit.Revwalk.RevWalk)">RevCommitList&lt;E&gt;.Source(RevWalk)
            	</see>
            is pumped until the
            specified commit is loaded. Callers can test the final size of the list
            by
            <see cref="P:NGit.Revwalk.RevObjectList`1.Count">RevObjectList&lt;E&gt;.Count()</see>
            to determine if the high water mark specified was met.
            <p/>
            </remarks>
            <param name="commitToLoad">
            commit the caller wants this list to contain when the fill
            operation is complete.
            </param>
            <param name="highMark">
            maximum number of commits the caller wants this list to
            contain when the fill operation is complete. If highMark is 0
            the walk is pumped until the specified commit or the end of
            the walk is reached.
            </param>
            <exception cref="T:System.IO.IOException">
            see
            <see cref="M:NGit.Revwalk.RevWalk.Next">RevWalk.Next()</see>
            </exception>
            <exception cref="T:NGit.Errors.IncorrectObjectTypeException">
            see
            <see cref="M:NGit.Revwalk.RevWalk.Next">RevWalk.Next()</see>
            </exception>
            <exception cref="T:NGit.Errors.MissingObjectException">
            see
            <see cref="M:NGit.Revwalk.RevWalk.Next">RevWalk.Next()</see>
            </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Revwalk.RevCommitList`1.Enter(System.Int32,`0)" -->
        <member name="T:NGit.Merge.StrategyResolve">
            <summary>A three-way merge strategy performing a content-merge if necessary</summary>
        </member>
        <member name="T:NGit.Merge.ThreeWayMergeStrategy">
            <summary>A merge strategy to merge 2 trees, using a common base ancestor tree.</summary>
            <remarks>A merge strategy to merge 2 trees, using a common base ancestor tree.</remarks>
        </member>
        <member name="T:NGit.Errors.UnmergedPathException">
            <summary>Indicates one or more paths in a DirCache have non-zero stages present.</summary>
            <remarks>Indicates one or more paths in a DirCache have non-zero stages present.</remarks>
        </member>
        <member name="M:NGit.Errors.UnmergedPathException.#ctor(NGit.Dircache.DirCacheEntry)">
            <summary>Create a new unmerged path exception.</summary>
            <remarks>Create a new unmerged path exception.</remarks>
            <param name="dce">the first non-zero stage of the unmerged path.</param>
        </member>
        <member name="M:NGit.Errors.UnmergedPathException.GetDirCacheEntry">
            <returns>the first non-zero stage of the unmerged path</returns>
        </member>
        <member name="T:NGit.Errors.CheckoutConflictException">
            <summary>Exception thrown if a conflict occurs during a merge checkout.</summary>
            <remarks>Exception thrown if a conflict occurs during a merge checkout.</remarks>
        </member>
        <member name="M:NGit.Errors.CheckoutConflictException.#ctor(System.String)">
            <summary>Construct a CheckoutConflictException for the specified file</summary>
            <param name="file"></param>
        </member>
        <member name="M:NGit.Errors.CheckoutConflictException.#ctor(System.String[])">
            <summary>Construct a CheckoutConflictException for the specified set of files</summary>
            <param name="files"></param>
        </member>
        <member name="T:NGit.Diff.DiffConfig">
            <summary>Keeps track of diff related configuration options.</summary>
            <remarks>Keeps track of diff related configuration options.</remarks>
        </member>
        <member name="F:NGit.Diff.DiffConfig.KEY">
            <summary>
            Key for
            <see cref="M:NGit.Config.Get``1(NGit.Config.SectionParser{``0})">NGit.Config.Get&lt;T&gt;(NGit.Config.SectionParser&lt;T&gt;)
            	</see>
            .
            </summary>
        </member>
        <member name="M:NGit.Diff.DiffConfig.IsNoPrefix">
            <returns>true if the prefix "a/" and "b/" should be suppressed.</returns>
        </member>
        <member name="M:NGit.Diff.DiffConfig.IsRenameDetectionEnabled">
            <returns>true if rename detection is enabled by default.</returns>
        </member>
        <member name="M:NGit.Diff.DiffConfig.GetRenameDetectionType">
            <returns>type of rename detection to perform.</returns>
        </member>
        <member name="M:NGit.Diff.DiffConfig.GetRenameLimit">
            <returns>limit on number of paths to perform inexact rename detection.</returns>
        </member>
        <member name="T:NGit.Diff.DiffConfig.RenameDetectionType">
            <summary>
            Permissible values for
            <code>diff.renames</code>
            .
            </summary>
        </member>
        <member name="T:NGit.Api.Errors.WrongRepositoryStateException">
            <summary>
            Exception thrown when the state of the repository doesn't allow the execution
            of a certain command.
            </summary>
            <remarks>
            Exception thrown when the state of the repository doesn't allow the execution
            of a certain command. E.g. when a CommitCommand should be executed on a
            repository with unresolved conflicts this exception will be thrown.
            </remarks>
        </member>
        <member name="M:NGit.Api.Errors.WrongRepositoryStateException.#ctor(System.String,System.Exception)">
            <param name="message"></param>
            <param name="cause"></param>
        </member>
        <member name="M:NGit.Api.Errors.WrongRepositoryStateException.#ctor(System.String)">
            <param name="message"></param>
        </member>
        <member name="T:NGit.Api.Errors.InvalidTagNameException">
            <summary>
            Exception thrown when a tag command was called with an invalid tag name (or
            null), such as bad~tag.
            </summary>
            <remarks>
            Exception thrown when a tag command was called with an invalid tag name (or
            null), such as bad~tag.
            </remarks>
        </member>
        <member name="M:NGit.Api.Errors.InvalidTagNameException.#ctor(System.String)">
            <param name="msg"></param>
        </member>
        <member name="T:NGit.ObjectStream">
            <summary>
            Stream of data coming from an object loaded by
            <see cref="T:NGit.ObjectLoader">ObjectLoader</see>
            .
            </summary>
        </member>
        <member name="M:NGit.ObjectStream.GetType">
            <returns>
            Git object type, see
            <see cref="T:NGit.Constants">Constants</see>
            .
            </returns>
        </member>
        <member name="M:NGit.ObjectStream.GetSize">
            <returns>total size of object in bytes</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.ObjectStream.SmallStream" -->
        <member name="M:NGit.ObjectStream.SmallStream.#ctor(NGit.ObjectLoader)">
            <summary>Create the stream from an existing loader's cached bytes.</summary>
            <remarks>Create the stream from an existing loader's cached bytes.</remarks>
            <param name="loader">the loader.</param>
        </member>
        <member name="M:NGit.ObjectStream.SmallStream.#ctor(System.Int32,System.Byte[])">
            <summary>Create the stream from an existing byte array and type.</summary>
            <remarks>Create the stream from an existing byte array and type.</remarks>
            <param name="type">the type constant for the object.</param>
            <param name="data">the fully inflated content of the object.</param>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.ObjectStream.Filter" -->
        <member name="M:NGit.ObjectStream.Filter.#ctor(System.Int32,System.Int64,Sharpen.InputStream)">
            <summary>Create a filter stream for an object.</summary>
            <remarks>Create a filter stream for an object.</remarks>
            <param name="type">the type of the object.</param>
            <param name="size">total size of the object, in bytes.</param>
            <param name="in">
            stream the object's raw data is available from. This
            stream should be buffered with some reasonable amount of
            buffering.
            </param>
        </member>
        <member name="M:NGit.ObjectStream.Filter.Available">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.ObjectStream.Filter.Skip(System.Int64)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.ObjectStream.Filter.Read">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.ObjectStream.Filter.Read(System.Byte[],System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.ObjectStream.Filter.Reset">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.ObjectStream.Filter.Close">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Transport.PreUploadHookChain" -->
        <!-- Badly formed XML comment ignored for member "T:NGit.Transport.PreUploadHook" -->
        <member name="F:NGit.Transport.PreUploadHook.NULL">
            <summary>A simple no-op hook.</summary>
            <remarks>A simple no-op hook.</remarks>
        </member>
        <member name="M:NGit.Transport.PreUploadHook.OnBeginNegotiateRound``1(NGit.Transport.UploadPack,System.Collections.Generic.ICollection{``0},System.Int32)">
            <summary>Invoked before negotiation round is started.</summary>
            <remarks>Invoked before negotiation round is started.</remarks>
            <param name="up">the upload pack instance handling the connection.</param>
            <param name="wants">the list of wanted objects.</param>
            <param name="cntOffered">number of objects the client has offered.</param>
            <exception cref="T:NGit.Transport.ServiceMayNotContinueException">abort; the message will be sent to the user.
            	</exception>
            <exception cref="T:NGit.Transport.ServiceMayNotContinueException"></exception>
        </member>
        <member name="M:NGit.Transport.PreUploadHook.OnEndNegotiateRound``1(NGit.Transport.UploadPack,System.Collections.Generic.ICollection{``0},System.Int32,System.Int32,System.Boolean)">
            <summary>Invoked after a negotiation round is completed.</summary>
            <remarks>Invoked after a negotiation round is completed.</remarks>
            <param name="up">the upload pack instance handling the connection.</param>
            <param name="wants">the list of wanted objects.</param>
            <param name="cntCommon">
            number of objects this round found to be common. In a smart
            HTTP transaction this includes the objects that were
            previously found to be common.
            </param>
            <param name="cntNotFound">
            number of objects in this round the local repository does not
            have, but that were offered as potential common bases.
            </param>
            <param name="ready">
            true if a pack is ready to be sent (the commit graph was
            successfully cut).
            </param>
            <exception cref="T:NGit.Transport.ServiceMayNotContinueException">abort; the message will be sent to the user.
            	</exception>
            <exception cref="T:NGit.Transport.ServiceMayNotContinueException"></exception>
        </member>
        <member name="M:NGit.Transport.PreUploadHook.OnSendPack``2(NGit.Transport.UploadPack,System.Collections.Generic.ICollection{``0},System.Collections.Generic.ICollection{``1})">
            <summary>Invoked just before a pack will be sent to the client.</summary>
            <remarks>Invoked just before a pack will be sent to the client.</remarks>
            <param name="up">the upload pack instance handling the connection.</param>
            <param name="wants">
            the list of wanted objects. These may be RevObject or
            RevCommit if the processed parsed them. Implementors should
            not rely on the values being parsed.
            </param>
            <param name="haves">
            the list of common objects. Empty on an initial clone request.
            These may be RevObject or RevCommit if the processed parsed
            them. Implementors should not rely on the values being parsed.
            </param>
            <exception cref="T:NGit.Transport.ServiceMayNotContinueException">abort; the message will be sent to the user.
            	</exception>
            <exception cref="T:NGit.Transport.ServiceMayNotContinueException"></exception>
        </member>
        <member name="M:NGit.Transport.PreUploadHook._PreUploadHook_60.OnBeginNegotiateRound``1(NGit.Transport.UploadPack,System.Collections.Generic.ICollection{``0},System.Int32)">
            <exception cref="T:NGit.Transport.ServiceMayNotContinueException"></exception>
        </member>
        <member name="M:NGit.Transport.PreUploadHook._PreUploadHook_60.OnEndNegotiateRound``1(NGit.Transport.UploadPack,System.Collections.Generic.ICollection{``0},System.Int32,System.Int32,System.Boolean)">
            <exception cref="T:NGit.Transport.ServiceMayNotContinueException"></exception>
        </member>
        <member name="M:NGit.Transport.PreUploadHook._PreUploadHook_60.OnSendPack``2(NGit.Transport.UploadPack,System.Collections.Generic.ICollection{``0},System.Collections.Generic.ICollection{``1})">
            <exception cref="T:NGit.Transport.ServiceMayNotContinueException"></exception>
        </member>
        <member name="M:NGit.Transport.PreUploadHookChain.NewChain``1(System.Collections.Generic.IList{``0})">
            <summary>Create a new hook chaining the given hooks together.</summary>
            <remarks>Create a new hook chaining the given hooks together.</remarks>
            <param name="hooks">hooks to execute, in order.</param>
            <returns>a new hook chain of the given hooks.</returns>
        </member>
        <member name="M:NGit.Transport.PreUploadHookChain.OnBeginNegotiateRound``1(NGit.Transport.UploadPack,System.Collections.Generic.ICollection{``0},System.Int32)">
            <exception cref="T:NGit.Transport.ServiceMayNotContinueException"></exception>
        </member>
        <member name="M:NGit.Transport.PreUploadHookChain.OnEndNegotiateRound``1(NGit.Transport.UploadPack,System.Collections.Generic.ICollection{``0},System.Int32,System.Int32,System.Boolean)">
            <exception cref="T:NGit.Transport.ServiceMayNotContinueException"></exception>
        </member>
        <member name="M:NGit.Transport.PreUploadHookChain.OnSendPack``2(NGit.Transport.UploadPack,System.Collections.Generic.ICollection{``0},System.Collections.Generic.ICollection{``1})">
            <exception cref="T:NGit.Transport.ServiceMayNotContinueException"></exception>
        </member>
        <member name="T:NGit.Util.IO.SafeBufferedOutputStream">
            <summary>
            A BufferedOutputStream that throws an error if the final flush fails on
            close.
            </summary>
            <remarks>
            A BufferedOutputStream that throws an error if the final flush fails on
            close.
            <p>
            Java's BufferedOutputStream swallows errors that occur when the output stream
            tries to write the final bytes to the output during close. This may result in
            corrupted files without notice.
            </p>
            </remarks>
        </member>
        <member name="M:NGit.Util.IO.SafeBufferedOutputStream.#ctor(Sharpen.OutputStream)">
            <seealso cref="M:Sharpen.BufferedOutputStream.#ctor(Sharpen.OutputStream)">Sharpen.BufferedOutputStream.BufferedOutputStream(Sharpen.OutputStream)</seealso>
            <param name="out">underlying output stream</param>
        </member>
        <member name="M:NGit.Util.IO.SafeBufferedOutputStream.#ctor(Sharpen.OutputStream,System.Int32)">
            <seealso cref="M:Sharpen.BufferedOutputStream.#ctor(Sharpen.OutputStream,System.Int32)">Sharpen.BufferedOutputStream.BufferedOutputStream(Sharpen.OutputStream, int)</seealso>
            <param name="out">underlying output stream</param>
            <param name="size">buffer size</param>
        </member>
        <member name="M:NGit.Util.IO.SafeBufferedOutputStream.Close">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Api.SubmoduleUpdateCommand" -->
        <member name="M:NGit.Api.SubmoduleUpdateCommand.#ctor(NGit.Repository)">
            <param name="repo"></param>
        </member>
        <member name="M:NGit.Api.SubmoduleUpdateCommand.SetProgressMonitor(NGit.ProgressMonitor)">
            <summary>The progress monitor associated with the clone operation.</summary>
            <remarks>
            The progress monitor associated with the clone operation. By default,
            this is set to <code>NullProgressMonitor</code>
            </remarks>
            <seealso cref="T:NGit.NullProgressMonitor">NGit.NullProgressMonitor</seealso>
            <param name="monitor"></param>
            <returns>this command</returns>
        </member>
        <member name="M:NGit.Api.SubmoduleUpdateCommand.AddPath(System.String)">
            <summary>Add repository-relative submodule path to initialize</summary>
            <param name="path"></param>
            <returns>this command</returns>
        </member>
        <member name="M:NGit.Api.SubmoduleUpdateCommand.Call">
            <summary>Execute the SubmoduleUpdateCommand command.</summary>
            <remarks>Execute the SubmoduleUpdateCommand command.</remarks>
            <returns>a collection of updated submodule paths</returns>
            <exception cref="T:NGit.Api.Errors.ConcurrentRefUpdateException">NGit.Api.Errors.ConcurrentRefUpdateException
            	</exception>
            <exception cref="T:NGit.Api.Errors.CheckoutConflictException">NGit.Api.Errors.CheckoutConflictException
            	</exception>
            <exception cref="T:NGit.Api.Errors.InvalidMergeHeadsException">NGit.Api.Errors.InvalidMergeHeadsException
            	</exception>
            <exception cref="T:NGit.Api.Errors.InvalidConfigurationException">NGit.Api.Errors.InvalidConfigurationException
            	</exception>
            <exception cref="T:NGit.Api.Errors.NoHeadException">NGit.Api.Errors.NoHeadException
            	</exception>
            <exception cref="T:NGit.Api.Errors.NoMessageException">NGit.Api.Errors.NoMessageException
            	</exception>
            <exception cref="T:NGit.Api.Errors.RefNotFoundException">NGit.Api.Errors.RefNotFoundException
            	</exception>
            <exception cref="T:NGit.Api.Errors.WrongRepositoryStateException">NGit.Api.Errors.WrongRepositoryStateException
            	</exception>
            <exception cref="T:NGit.Api.Errors.GitAPIException">NGit.Api.Errors.GitAPIException
            	</exception>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Api.CleanCommand" -->
        <member name="M:NGit.Api.CleanCommand.#ctor(NGit.Repository)">
            <param name="repo"></param>
        </member>
        <member name="M:NGit.Api.CleanCommand.Call">
            <summary>
            Executes the
            <code>clean</code>
            command with all the options and parameters
            collected by the setter methods of this class. Each instance of this
            class should only be used for one invocation of the command (means: one
            call to
            <see cref="M:NGit.Api.CleanCommand.Call">Call()</see>
            )
            </summary>
            <returns>a set of strings representing each file cleaned.</returns>
            <exception cref="T:NGit.Api.Errors.GitAPIException">NGit.Api.Errors.GitAPIException
            	</exception>
            <exception cref="T:NGit.Errors.NoWorkTreeException">NGit.Errors.NoWorkTreeException
            	</exception>
        </member>
        <member name="M:NGit.Api.CleanCommand.SetPaths(System.Collections.Generic.ICollection{System.String})">
            <summary>If paths are set, only these paths are affected by the cleaning.</summary>
            <remarks>If paths are set, only these paths are affected by the cleaning.</remarks>
            <param name="paths">the paths to set</param>
            <returns>
            
            <code>this</code>
            </returns>
        </member>
        <member name="M:NGit.Api.CleanCommand.SetDryRun(System.Boolean)">
            <summary>If dryRun is set, the paths in question will not actually be deleted.</summary>
            <remarks>If dryRun is set, the paths in question will not actually be deleted.</remarks>
            <param name="dryRun">whether to do a dry run or not</param>
            <returns>
            
            <code>this</code>
            </returns>
        </member>
        <member name="T:NGit.Transport.UploadPackMayNotContinueException">
            <summary>Indicates UploadPack may not continue execution.</summary>
            <remarks>Indicates UploadPack may not continue execution.</remarks>
        </member>
        <member name="T:NGit.Transport.ServiceMayNotContinueException">
            <summary>Indicates a transport service may not continue execution.</summary>
            <remarks>Indicates a transport service may not continue execution.</remarks>
            <since>2.0</since>
        </member>
        <member name="M:NGit.Transport.ServiceMayNotContinueException.#ctor">
            <summary>Initialize with no message.</summary>
            <remarks>Initialize with no message.</remarks>
        </member>
        <member name="M:NGit.Transport.ServiceMayNotContinueException.#ctor(System.String)">
            <param name="msg">
            a message explaining why it cannot continue. This message may
            be shown to an end-user.
            </param>
        </member>
        <member name="M:NGit.Transport.ServiceMayNotContinueException.IsOutput">
            <returns>true if the message was already output to the client.</returns>
        </member>
        <member name="M:NGit.Transport.ServiceMayNotContinueException.SetOutput">
            <summary>Mark this message has being sent to the client.</summary>
            <remarks>Mark this message has being sent to the client.</remarks>
        </member>
        <member name="M:NGit.Transport.UploadPackMayNotContinueException.#ctor">
            <summary>Initialize with no message.</summary>
            <remarks>Initialize with no message.</remarks>
        </member>
        <member name="M:NGit.Transport.UploadPackMayNotContinueException.#ctor(System.String)">
            <param name="msg">
            a message explaining why it cannot continue. This message may
            be shown to an end-user.
            </param>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Transport.Resolver.FileResolver`1" -->
        <!-- Badly formed XML comment ignored for member "T:NGit.Transport.Resolver.RepositoryResolver`1" -->
        <member name="F:NGit.Transport.Resolver.RepositoryResolver`1.NONE">
            <summary>Resolver configured to open nothing.</summary>
            <remarks>Resolver configured to open nothing.</remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Transport.Resolver.RepositoryResolver`1.Open(`0,System.String)" -->
        <member name="M:NGit.Transport.Resolver.RepositoryResolver`1._RepositoryResolver_58.Open(`0,System.String)">
            <exception cref="T:NGit.Errors.RepositoryNotFoundException"></exception>
        </member>
        <member name="M:NGit.Transport.Resolver.FileResolver`1.#ctor">
            <summary>Initialize an empty file based resolver.</summary>
            <remarks>Initialize an empty file based resolver.</remarks>
        </member>
        <member name="M:NGit.Transport.Resolver.FileResolver`1.#ctor(Sharpen.FilePath,System.Boolean)">
            <summary>Create a new resolver for the given path.</summary>
            <remarks>Create a new resolver for the given path.</remarks>
            <param name="basePath">the base path all repositories are rooted under.</param>
            <param name="exportAll">
            if true, exports all repositories, ignoring the check for the
            <code>git-daemon-export-ok</code>
            files.
            </param>
        </member>
        <member name="M:NGit.Transport.Resolver.FileResolver`1.Open(`0,System.String)">
            <exception cref="T:NGit.Errors.RepositoryNotFoundException"></exception>
            <exception cref="T:NGit.Transport.Resolver.ServiceNotEnabledException"></exception>
        </member>
        <member name="M:NGit.Transport.Resolver.FileResolver`1.IsExportAll">
            <returns>
            false if <code>git-daemon-export-ok</code> is required to export
            a repository; true if <code>git-daemon-export-ok</code> is
            ignored.
            </returns>
            <seealso cref="M:NGit.Transport.Resolver.FileResolver`1.SetExportAll(System.Boolean)">FileResolver&lt;C&gt;.SetExportAll(bool)
            	</seealso>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Transport.Resolver.FileResolver`1.SetExportAll(System.Boolean)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Transport.Resolver.FileResolver`1.ExportRepository(System.String,NGit.Repository)" -->
        <member name="M:NGit.Transport.Resolver.FileResolver`1.ExportDirectory(Sharpen.FilePath)">
            <summary>Recursively export all Git repositories within a directory.</summary>
            <remarks>Recursively export all Git repositories within a directory.</remarks>
            <param name="dir">
            the directory to export. This directory must not itself be a
            git repository, but any directory below it which has a file
            named <code>git-daemon-export-ok</code> will be published.
            </param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Transport.Resolver.FileResolver`1.IsExportOk(`0,System.String,NGit.Repository)" -->
        <!-- Badly formed XML comment ignored for member "T:NGit.Api.CloneCommand" -->
        <member name="M:NGit.Api.CloneCommand.#ctor">
            <summary>Create clone command with no repository set</summary>
        </member>
        <member name="M:NGit.Api.CloneCommand.Call">
            <summary>
            Executes the
            <code>Clone</code>
            command.
            </summary>
            <returns>
            the newly created
            <code>Git</code>
            object with associated repository
            </returns>
            <exception cref="T:NGit.Api.Errors.InvalidRemoteException">NGit.Api.Errors.InvalidRemoteException
            	</exception>
            <exception cref="T:NGit.Api.Errors.TransportException">NGit.Api.Errors.TransportException
            	</exception>
            <exception cref="T:NGit.Api.Errors.GitAPIException">NGit.Api.Errors.GitAPIException
            	</exception>
        </member>
        <member name="M:NGit.Api.CloneCommand.Init(NGit.Transport.URIish)">
            <exception cref="T:NGit.Api.Errors.GitAPIException"></exception>
        </member>
        <member name="M:NGit.Api.CloneCommand.Fetch(NGit.Repository,NGit.Transport.URIish)">
            <exception cref="T:Sharpen.URISyntaxException"></exception>
            <exception cref="T:NGit.Api.Errors.TransportException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
            <exception cref="T:NGit.Api.Errors.GitAPIException"></exception>
        </member>
        <member name="M:NGit.Api.CloneCommand.Checkout(NGit.Repository,NGit.Transport.FetchResult)">
            <exception cref="T:NGit.Errors.MissingObjectException"></exception>
            <exception cref="T:NGit.Errors.IncorrectObjectTypeException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
            <exception cref="T:NGit.Api.Errors.GitAPIException"></exception>
        </member>
        <member name="M:NGit.Api.CloneCommand.CloneSubmodules(NGit.Repository)">
            <exception cref="T:System.IO.IOException"></exception>
            <exception cref="T:NGit.Api.Errors.GitAPIException"></exception>
        </member>
        <member name="M:NGit.Api.CloneCommand.AddMergeConfig(NGit.Repository,NGit.Ref)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Api.CloneCommand.ParseCommit(NGit.Repository,NGit.Ref)">
            <exception cref="T:NGit.Errors.MissingObjectException"></exception>
            <exception cref="T:NGit.Errors.IncorrectObjectTypeException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Api.CloneCommand.SetURI(System.String)">
            <param name="uri">the uri to clone from</param>
            <returns>this instance</returns>
        </member>
        <member name="M:NGit.Api.CloneCommand.SetDirectory(Sharpen.FilePath)">
            <summary>The optional directory associated with the clone operation.</summary>
            <remarks>
            The optional directory associated with the clone operation. If the
            directory isn't set, a name associated with the source uri will be used.
            </remarks>
            <seealso cref="M:NGit.Transport.URIish.GetHumanishName">NGit.Transport.URIish.GetHumanishName()
            	</seealso>
            <param name="directory">the directory to clone to</param>
            <returns>this instance</returns>
        </member>
        <member name="M:NGit.Api.CloneCommand.SetBare(System.Boolean)">
            <param name="bare">whether the cloned repository is bare or not</param>
            <returns>this instance</returns>
        </member>
        <member name="M:NGit.Api.CloneCommand.SetRemote(System.String)">
            <summary>
            The remote name used to keep track of the upstream repository for the
            clone operation.
            </summary>
            <remarks>
            The remote name used to keep track of the upstream repository for the
            clone operation. If no remote name is set, the default value of
            <code>Constants.DEFAULT_REMOTE_NAME</code> will be used.
            </remarks>
            <seealso cref="F:NGit.Constants.DEFAULT_REMOTE_NAME">NGit.Constants.DEFAULT_REMOTE_NAME
            	</seealso>
            <param name="remote">name that keeps track of the upstream repository</param>
            <returns>this instance</returns>
        </member>
        <member name="M:NGit.Api.CloneCommand.SetBranch(System.String)">
            <param name="branch">the initial branch to check out when cloning the repository</param>
            <returns>this instance</returns>
        </member>
        <member name="M:NGit.Api.CloneCommand.SetProgressMonitor(NGit.ProgressMonitor)">
            <summary>The progress monitor associated with the clone operation.</summary>
            <remarks>
            The progress monitor associated with the clone operation. By default,
            this is set to <code>NullProgressMonitor</code>
            </remarks>
            <seealso cref="T:NGit.NullProgressMonitor">NGit.NullProgressMonitor</seealso>
            <param name="monitor"></param>
            <returns>
            
            <code>this</code>
            </returns>
        </member>
        <member name="M:NGit.Api.CloneCommand.SetCloneAllBranches(System.Boolean)">
            <param name="cloneAllBranches">
            true when all branches have to be fetched (indicates wildcard
            in created fetch refspec), false otherwise.
            </param>
            <returns>
            
            <code>this</code>
            </returns>
        </member>
        <member name="M:NGit.Api.CloneCommand.SetCloneSubmodules(System.Boolean)">
            <param name="cloneSubmodules">
            true to initialize and update submodules. Ignored when
            <see cref="M:NGit.Api.CloneCommand.SetBare(System.Boolean)">SetBare(bool)</see>
            is set to true.
            </param>
            <returns>
            
            <code>this</code>
            </returns>
        </member>
        <member name="M:NGit.Api.CloneCommand.SetBranchesToClone(System.Collections.Generic.ICollection{System.String})">
            <param name="branchesToClone">
            collection of branches to clone. Ignored when allSelected is
            true.
            </param>
            <returns>
            
            <code>this</code>
            </returns>
        </member>
        <member name="M:NGit.Api.CloneCommand.SetNoCheckout(System.Boolean)">
            <param name="noCheckout">
            if set to <code>true</code> no branch will be checked out
            after the clone. This enhances performance of the clone
            command when there is no need for a checked out branch.
            </param>
            <returns>
            
            <code>this</code>
            </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Api.InitCommand" -->
        <member name="M:NGit.Api.InitCommand.Call">
            <summary>
            Executes the
            <code>Init</code>
            command.
            </summary>
            <returns>
            the newly created
            <code>Git</code>
            object with associated repository
            </returns>
            <exception cref="T:NGit.Api.Errors.GitAPIException"></exception>
        </member>
        <member name="M:NGit.Api.InitCommand.SetDirectory(Sharpen.FilePath)">
            <summary>The optional directory associated with the init operation.</summary>
            <remarks>
            The optional directory associated with the init operation. If no
            directory is set, we'll use the current directory
            </remarks>
            <param name="directory">the directory to init to</param>
            <returns>this instance</returns>
        </member>
        <member name="M:NGit.Api.InitCommand.SetBare(System.Boolean)">
            <param name="bare">whether the repository is bare or not</param>
            <returns>this instance</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Api.RmCommand" -->
        <member name="M:NGit.Api.RmCommand.#ctor(NGit.Repository)">
            <param name="repo"></param>
        </member>
        <member name="M:NGit.Api.RmCommand.AddFilepattern(System.String)">
            <param name="filepattern">File to remove.</param>
            <returns>
            
            <code>this</code>
            </returns>
        </member>
        <member name="M:NGit.Api.RmCommand.Call">
            <summary>
            Executes the
            <code>Rm</code>
            command. Each instance of this class should only
            be used for one invocation of the command. Don't call this method twice
            on an instance.
            </summary>
            <returns>the DirCache after Rm</returns>
            <exception cref="T:NGit.Api.Errors.GitAPIException"></exception>
            <exception cref="T:NGit.Api.Errors.NoFilepatternException"></exception>
        </member>
        <member name="T:NGit.Transport.Daemon">
            <summary>Basic daemon for the anonymous <code>git://</code> transport protocol.</summary>
            <remarks>Basic daemon for the anonymous <code>git://</code> transport protocol.</remarks>
        </member>
        <member name="F:NGit.Transport.Daemon.DEFAULT_PORT">
            <summary>9418: IANA assigned port number for Git.</summary>
            <remarks>9418: IANA assigned port number for Git.</remarks>
        </member>
        <member name="M:NGit.Transport.Daemon.#ctor">
            <summary>Configure a daemon to listen on any available network port.</summary>
            <remarks>Configure a daemon to listen on any available network port.</remarks>
        </member>
        <member name="M:NGit.Transport.Daemon.#ctor(System.Net.IPEndPoint)">
            <summary>Configure a new daemon for the specified network address.</summary>
            <remarks>Configure a new daemon for the specified network address.</remarks>
            <param name="addr">
            address to listen for connections on. If null, any available
            port will be chosen on all network interfaces.
            </param>
        </member>
        <member name="M:NGit.Transport.Daemon.GetAddress">
            <returns>the address connections are received on.</returns>
        </member>
        <member name="M:NGit.Transport.Daemon.GetService(System.String)">
            <summary>Lookup a supported service so it can be reconfigured.</summary>
            <remarks>Lookup a supported service so it can be reconfigured.</remarks>
            <param name="name">
            name of the service; e.g. "receive-pack"/"git-receive-pack" or
            "upload-pack"/"git-upload-pack".
            </param>
            <returns>
            the service; null if this daemon implementation doesn't support
            the requested service type.
            </returns>
        </member>
        <member name="M:NGit.Transport.Daemon.GetTimeout">
            <returns>timeout (in seconds) before aborting an IO operation.</returns>
        </member>
        <member name="M:NGit.Transport.Daemon.SetTimeout(System.Int32)">
            <summary>Set the timeout before willing to abort an IO call.</summary>
            <remarks>Set the timeout before willing to abort an IO call.</remarks>
            <param name="seconds">
            number of seconds to wait (with no data transfer occurring)
            before aborting an IO read or write operation with the
            connected client.
            </param>
        </member>
        <member name="M:NGit.Transport.Daemon.GetPackConfig">
            <returns>configuration controlling packing, may be null.</returns>
        </member>
        <member name="M:NGit.Transport.Daemon.SetPackConfig(NGit.Storage.Pack.PackConfig)">
            <summary>Set the configuration used by the pack generator.</summary>
            <remarks>Set the configuration used by the pack generator.</remarks>
            <param name="pc">
            configuration controlling packing parameters. If null the
            source repository's settings will be used.
            </param>
        </member>
        <member name="M:NGit.Transport.Daemon.SetRepositoryResolver(NGit.Transport.Resolver.RepositoryResolver{NGit.Transport.DaemonClient})">
            <summary>Set the resolver used to locate a repository by name.</summary>
            <remarks>Set the resolver used to locate a repository by name.</remarks>
            <param name="resolver">the resolver instance.</param>
        </member>
        <member name="M:NGit.Transport.Daemon.SetUploadPackFactory(NGit.Transport.Resolver.UploadPackFactory{NGit.Transport.DaemonClient})">
            <summary>Set the factory to construct and configure per-request UploadPack.</summary>
            <remarks>Set the factory to construct and configure per-request UploadPack.</remarks>
            <param name="factory">the factory. If null upload-pack is disabled.</param>
        </member>
        <member name="M:NGit.Transport.Daemon.SetReceivePackFactory(NGit.Transport.Resolver.ReceivePackFactory{NGit.Transport.DaemonClient})">
            <summary>Set the factory to construct and configure per-request ReceivePack.</summary>
            <remarks>Set the factory to construct and configure per-request ReceivePack.</remarks>
            <param name="factory">the factory. If null receive-pack is disabled.</param>
        </member>
        <member name="M:NGit.Transport.Daemon.Start">
            <summary>Start this daemon on a background thread.</summary>
            <remarks>Start this daemon on a background thread.</remarks>
            <exception cref="T:System.IO.IOException">the server socket could not be opened.</exception>
            <exception cref="T:System.InvalidOperationException">the daemon is already running.
            	</exception>
        </member>
        <member name="M:NGit.Transport.Daemon.IsRunning">
            <returns>true if this daemon is receiving connections.</returns>
        </member>
        <member name="M:NGit.Transport.Daemon.Stop">
            <summary>Stop this daemon.</summary>
            <remarks>Stop this daemon.</remarks>
        </member>
        <member name="M:NGit.Transport.Daemon.OpenRepository(NGit.Transport.DaemonClient,System.String)">
            <exception cref="T:NGit.Transport.ServiceMayNotContinueException"></exception>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Transport.Resolver.UploadPackFactory`1" -->
        <member name="F:NGit.Transport.Resolver.UploadPackFactory`1.DISABLED">
            <summary>A factory disabling the UploadPack service for all repositories.</summary>
            <remarks>A factory disabling the UploadPack service for all repositories.</remarks>
        </member>
        <member name="M:NGit.Transport.Resolver.UploadPackFactory`1.Create(`0,NGit.Repository)">
            <summary>Create and configure a new UploadPack instance for a repository.</summary>
            <remarks>Create and configure a new UploadPack instance for a repository.</remarks>
            <param name="req">
            current request, in case information from the request may help
            configure the UploadPack instance.
            </param>
            <param name="db">the repository the upload would read from.</param>
            <returns>the newly configured UploadPack instance, must not be null.</returns>
            <exception cref="T:NGit.Transport.Resolver.ServiceNotEnabledException">
            this factory refuses to create the instance because it is not
            allowed on the target repository, by any user.
            </exception>
            <exception cref="T:NGit.Transport.Resolver.ServiceNotAuthorizedException">
            this factory refuses to create the instance for this HTTP
            request and repository, such as due to a permission error.
            </exception>
            <exception cref="T:NGit.Transport.Resolver.ServiceNotEnabledException"></exception>
            <exception cref="T:NGit.Transport.Resolver.ServiceNotAuthorizedException"></exception>
        </member>
        <member name="M:NGit.Transport.Resolver.UploadPackFactory`1._UploadPackFactory_57.Create(`0,NGit.Repository)">
            <exception cref="T:NGit.Transport.Resolver.ServiceNotEnabledException"></exception>
        </member>
        <member name="M:NGit.Transport.Daemon._UploadPackFactory_112.Create(NGit.Transport.DaemonClient,NGit.Repository)">
            <exception cref="T:NGit.Transport.Resolver.ServiceNotEnabledException"></exception>
            <exception cref="T:NGit.Transport.Resolver.ServiceNotAuthorizedException"></exception>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Transport.Resolver.ReceivePackFactory`1" -->
        <member name="F:NGit.Transport.Resolver.ReceivePackFactory`1.DISABLED">
            <summary>A factory disabling the ReceivePack service for all repositories</summary>
        </member>
        <member name="M:NGit.Transport.Resolver.ReceivePackFactory`1.Create(`0,NGit.Repository)">
            <summary>Create and configure a new ReceivePack instance for a repository.</summary>
            <remarks>Create and configure a new ReceivePack instance for a repository.</remarks>
            <param name="req">
            current request, in case information from the request may help
            configure the ReceivePack instance.
            </param>
            <param name="db">the repository the receive would write into.</param>
            <returns>the newly configured ReceivePack instance, must not be null.</returns>
            <exception cref="T:NGit.Transport.Resolver.ServiceNotEnabledException">
            this factory refuses to create the instance because it is not
            allowed on the target repository, by any user.
            </exception>
            <exception cref="T:NGit.Transport.Resolver.ServiceNotAuthorizedException">
            this factory refuses to create the instance for this HTTP
            request and repository, such as due to a permission error.
            </exception>
            <exception cref="T:NGit.Transport.Resolver.ServiceNotEnabledException"></exception>
            <exception cref="T:NGit.Transport.Resolver.ServiceNotAuthorizedException"></exception>
        </member>
        <member name="M:NGit.Transport.Resolver.ReceivePackFactory`1._ReceivePackFactory_57.Create(`0,NGit.Repository)">
            <exception cref="T:NGit.Transport.Resolver.ServiceNotEnabledException"></exception>
        </member>
        <member name="M:NGit.Transport.Daemon._ReceivePackFactory_123.Create(NGit.Transport.DaemonClient,NGit.Repository)">
            <exception cref="T:NGit.Transport.Resolver.ServiceNotEnabledException"></exception>
            <exception cref="T:NGit.Transport.Resolver.ServiceNotAuthorizedException"></exception>
        </member>
        <member name="T:NGit.Transport.DaemonService">
            <summary>
            A service exposed by
            <see cref="T:NGit.Transport.Daemon">Daemon</see>
            over anonymous <code>git://</code>.
            </summary>
        </member>
        <member name="M:NGit.Transport.DaemonService.IsEnabled">
            <returns>is this service enabled for invocation?</returns>
        </member>
        <member name="M:NGit.Transport.DaemonService.SetEnabled(System.Boolean)">
            <param name="on">true to allow this service to be used; false to deny it.</param>
        </member>
        <member name="M:NGit.Transport.DaemonService.IsOverridable">
            <returns>can this service be configured in the repository config file?</returns>
        </member>
        <member name="M:NGit.Transport.DaemonService.SetOverridable(System.Boolean)">
            <param name="on">
            true to permit repositories to override this service's enabled
            state with the <code>daemon.servicename</code> config setting.
            </param>
        </member>
        <member name="M:NGit.Transport.DaemonService.GetCommandName">
            <returns>name of the command requested by clients.</returns>
        </member>
        <member name="M:NGit.Transport.DaemonService.Handles(System.String)">
            <summary>Determine if this service can handle the requested command.</summary>
            <remarks>Determine if this service can handle the requested command.</remarks>
            <param name="commandLine">input line from the client.</param>
            <returns>true if this command can accept the given command line.</returns>
        </member>
        <member name="M:NGit.Transport.DaemonService.Execute(NGit.Transport.DaemonClient,System.String)">
            <exception cref="T:System.IO.IOException"></exception>
            <exception cref="T:NGit.Transport.Resolver.ServiceNotEnabledException"></exception>
            <exception cref="T:NGit.Transport.Resolver.ServiceNotAuthorizedException"></exception>
        </member>
        <member name="M:NGit.Transport.DaemonService.Execute(NGit.Transport.DaemonClient,NGit.Repository)">
            <exception cref="T:System.IO.IOException"></exception>
            <exception cref="T:NGit.Transport.Resolver.ServiceNotEnabledException"></exception>
            <exception cref="T:NGit.Transport.Resolver.ServiceNotAuthorizedException"></exception>
        </member>
        <member name="M:NGit.Transport.Daemon._DaemonService_143.Execute(NGit.Transport.DaemonClient,NGit.Repository)">
            <exception cref="T:System.IO.IOException"></exception>
            <exception cref="T:NGit.Transport.Resolver.ServiceNotEnabledException"></exception>
            <exception cref="T:NGit.Transport.Resolver.ServiceNotAuthorizedException"></exception>
        </member>
        <member name="M:NGit.Transport.Daemon._DaemonService_158.Execute(NGit.Transport.DaemonClient,NGit.Repository)">
            <exception cref="T:System.IO.IOException"></exception>
            <exception cref="T:NGit.Transport.Resolver.ServiceNotEnabledException"></exception>
            <exception cref="T:NGit.Transport.Resolver.ServiceNotAuthorizedException"></exception>
        </member>
        <member name="T:NGit.Transport.SideBandProgressMonitor">
            <summary>Write progress messages out to the sideband channel.</summary>
            <remarks>Write progress messages out to the sideband channel.</remarks>
        </member>
        <member name="T:NGit.BatchingProgressMonitor">
            <summary>ProgressMonitor that batches update events.</summary>
            <remarks>ProgressMonitor that batches update events.</remarks>
        </member>
        <member name="M:NGit.BatchingProgressMonitor.SetDelayStart(System.Int64,Sharpen.TimeUnit)">
            <summary>Set an optional delay before the first output.</summary>
            <remarks>Set an optional delay before the first output.</remarks>
            <param name="time">
            how long to wait before output. If 0 output begins on the
            first
            <see cref="M:NGit.BatchingProgressMonitor.Update(System.Int32)">Update(int)</see>
            call.
            </param>
            <param name="unit">
            time unit of
            <code>time</code>
            .
            </param>
        </member>
        <member name="M:NGit.BatchingProgressMonitor.OnUpdate(System.String,System.Int32)">
            <summary>Update the progress monitor if the total work isn't known,</summary>
            <param name="taskName">name of the task.</param>
            <param name="workCurr">number of units already completed.</param>
        </member>
        <member name="M:NGit.BatchingProgressMonitor.OnEndTask(System.String,System.Int32)">
            <summary>Finish the progress monitor when the total wasn't known in advance.</summary>
            <remarks>Finish the progress monitor when the total wasn't known in advance.</remarks>
            <param name="taskName">name of the task.</param>
            <param name="workCurr">total number of units processed.</param>
        </member>
        <member name="M:NGit.BatchingProgressMonitor.OnUpdate(System.String,System.Int32,System.Int32,System.Int32)">
            <summary>Update the progress monitor when the total is known in advance.</summary>
            <remarks>Update the progress monitor when the total is known in advance.</remarks>
            <param name="taskName">name of the task.</param>
            <param name="workCurr">number of units already completed.</param>
            <param name="workTotal">estimated number of units to process.</param>
            <param name="percentDone">
            <code>workCurr * 100 / workTotal</code>
            .
            </param>
        </member>
        <member name="M:NGit.BatchingProgressMonitor.OnEndTask(System.String,System.Int32,System.Int32,System.Int32)">
            <summary>Finish the progress monitor when the total is known in advance.</summary>
            <remarks>Finish the progress monitor when the total is known in advance.</remarks>
            <param name="taskName">name of the task.</param>
            <param name="workCurr">total number of units processed.</param>
            <param name="workTotal">estimated number of units to process.</param>
            <param name="percentDone">
            <code>workCurr * 100 / workTotal</code>
            .
            </param>
        </member>
        <member name="F:NGit.BatchingProgressMonitor.Task.taskName">
            <summary>Title of the current task.</summary>
            <remarks>Title of the current task.</remarks>
        </member>
        <member name="F:NGit.BatchingProgressMonitor.Task.totalWork">
            <summary>
            Number of work units, or
            <see cref="F:NGit.ProgressMonitor.UNKNOWN">ProgressMonitor.UNKNOWN</see>
            .
            </summary>
        </member>
        <member name="F:NGit.BatchingProgressMonitor.Task.display">
            <summary>True when timer expires and output should occur on next update.</summary>
            <remarks>True when timer expires and output should occur on next update.</remarks>
        </member>
        <member name="F:NGit.BatchingProgressMonitor.Task.timerFuture">
            <summary>Scheduled timer, supporting cancellation if task ends early.</summary>
            <remarks>Scheduled timer, supporting cancellation if task ends early.</remarks>
        </member>
        <member name="F:NGit.BatchingProgressMonitor.Task.output">
            <summary>True if the task has displayed anything.</summary>
            <remarks>True if the task has displayed anything.</remarks>
        </member>
        <member name="F:NGit.BatchingProgressMonitor.Task.lastWork">
            <summary>Number of work units already completed.</summary>
            <remarks>Number of work units already completed.</remarks>
        </member>
        <member name="F:NGit.BatchingProgressMonitor.Task.lastPercent">
            <summary>
            Percentage of
            <see cref="F:NGit.BatchingProgressMonitor.Task.totalWork">totalWork</see>
            that is done.
            </summary>
        </member>
        <member name="T:NGit.Errors.NoRemoteRepositoryException">
            <summary>Indicates a remote repository does not exist.</summary>
            <remarks>Indicates a remote repository does not exist.</remarks>
        </member>
        <member name="M:NGit.Errors.NoRemoteRepositoryException.#ctor(NGit.Transport.URIish,System.String)">
            <summary>Constructs an exception indicating a repository does not exist.</summary>
            <remarks>Constructs an exception indicating a repository does not exist.</remarks>
            <param name="uri">URI used for transport</param>
            <param name="s">message</param>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Treewalk.NameConflictTreeWalk" -->
        <!-- Badly formed XML comment ignored for member "T:NGit.Treewalk.TreeWalk" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Treewalk.TreeWalk.ForPath(NGit.ObjectReader,System.String,NGit.AnyObjectId[])" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Treewalk.TreeWalk.ForPath(NGit.Repository,System.String,NGit.AnyObjectId[])" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Treewalk.TreeWalk.ForPath(NGit.Repository,System.String,NGit.Revwalk.RevTree)" -->
        <member name="M:NGit.Treewalk.TreeWalk.#ctor(NGit.Repository)">
            <summary>Create a new tree walker for a given repository.</summary>
            <remarks>Create a new tree walker for a given repository.</remarks>
            <param name="repo">the repository the walker will obtain data from.</param>
        </member>
        <member name="M:NGit.Treewalk.TreeWalk.#ctor(NGit.ObjectReader)">
            <summary>Create a new tree walker for a given repository.</summary>
            <remarks>Create a new tree walker for a given repository.</remarks>
            <param name="or">the reader the walker will obtain tree data from.</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Treewalk.TreeWalk.Release" -->
        <member name="M:NGit.Treewalk.TreeWalk.Reset">
            <summary>Reset this walker so new tree iterators can be added to it.</summary>
            <remarks>Reset this walker so new tree iterators can be added to it.</remarks>
        </member>
        <member name="M:NGit.Treewalk.TreeWalk.Reset(NGit.AnyObjectId)">
            <summary>Reset this walker to run over a single existing tree.</summary>
            <remarks>Reset this walker to run over a single existing tree.</remarks>
            <param name="id">
            the tree we need to parse. The walker will execute over this
            single tree if the reset is successful.
            </param>
            <exception cref="T:NGit.Errors.MissingObjectException">the given tree object does not exist in this repository.
            	</exception>
            <exception cref="T:NGit.Errors.IncorrectObjectTypeException">
            the given object id does not denote a tree, but instead names
            some other non-tree type of object. Note that commits are not
            trees, even if they are sometimes called a "tree-ish".
            </exception>
            <exception cref="T:NGit.Errors.CorruptObjectException">
            the object claimed to be a tree, but its contents did not
            appear to be a tree. The repository may have data corruption.
            </exception>
            <exception cref="T:System.IO.IOException">a loose object or pack file could not be read.
            	</exception>
        </member>
        <member name="M:NGit.Treewalk.TreeWalk.Reset(NGit.AnyObjectId[])">
            <summary>Reset this walker to run over a set of existing trees.</summary>
            <remarks>Reset this walker to run over a set of existing trees.</remarks>
            <param name="ids">
            the trees we need to parse. The walker will execute over this
            many parallel trees if the reset is successful.
            </param>
            <exception cref="T:NGit.Errors.MissingObjectException">the given tree object does not exist in this repository.
            	</exception>
            <exception cref="T:NGit.Errors.IncorrectObjectTypeException">
            the given object id does not denote a tree, but instead names
            some other non-tree type of object. Note that commits are not
            trees, even if they are sometimes called a "tree-ish".
            </exception>
            <exception cref="T:NGit.Errors.CorruptObjectException">
            the object claimed to be a tree, but its contents did not
            appear to be a tree. The repository may have data corruption.
            </exception>
            <exception cref="T:System.IO.IOException">a loose object or pack file could not be read.
            	</exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Treewalk.TreeWalk.AddTree(NGit.AnyObjectId)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Treewalk.TreeWalk.AddTree(NGit.Treewalk.AbstractTreeIterator)" -->
        <member name="M:NGit.Treewalk.TreeWalk.Next">
            <summary>Advance this walker to the next relevant entry.</summary>
            <remarks>Advance this walker to the next relevant entry.</remarks>
            <returns>
            true if there is an entry available; false if all entries have
            been walked and the walk of this set of tree iterators is over.
            </returns>
            <exception cref="T:NGit.Errors.MissingObjectException">
            <see cref="P:NGit.Treewalk.TreeWalk.Recursive">Recursive()</see>
            was enabled, a subtree was found, but
            the subtree object does not exist in this repository. The
            repository may be missing objects.
            </exception>
            <exception cref="T:NGit.Errors.IncorrectObjectTypeException">
            <see cref="P:NGit.Treewalk.TreeWalk.Recursive">Recursive()</see>
            was enabled, a subtree was found, and
            the subtree id does not denote a tree, but instead names some
            other non-tree type of object. The repository may have data
            corruption.
            </exception>
            <exception cref="T:NGit.Errors.CorruptObjectException">
            the contents of a tree did not appear to be a tree. The
            repository may have data corruption.
            </exception>
            <exception cref="T:System.IO.IOException">a loose object or pack file could not be read.
            	</exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Treewalk.TreeWalk.GetTree``1(System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Treewalk.TreeWalk.GetRawMode(System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Treewalk.TreeWalk.GetFileMode(System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Treewalk.TreeWalk.GetObjectId(System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Treewalk.TreeWalk.GetObjectId(NGit.MutableObjectId,System.Int32)" -->
        <member name="M:NGit.Treewalk.TreeWalk.IdEqual(System.Int32,System.Int32)">
            <summary>Compare two tree's current ObjectId values for equality.</summary>
            <remarks>Compare two tree's current ObjectId values for equality.</remarks>
            <param name="nthA">first tree to compare the object id from.</param>
            <param name="nthB">second tree to compare the object id from.</param>
            <returns>
            result of
            <code>getObjectId(nthA).equals(getObjectId(nthB))</code>.
            </returns>
            <seealso cref="M:NGit.Treewalk.TreeWalk.GetObjectId(System.Int32)">GetObjectId(int)</seealso>
        </member>
        <member name="M:NGit.Treewalk.TreeWalk.GetPathLength">
            <returns>The path length of the current entry.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Treewalk.TreeWalk.IsPathPrefix(System.Byte[],System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Treewalk.TreeWalk.IsPathSuffix(System.Byte[],System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Treewalk.TreeWalk.EnterSubtree" -->
        <member name="M:NGit.Treewalk.TreeWalk.Min">
            <exception cref="T:NGit.Errors.CorruptObjectException"></exception>
        </member>
        <member name="M:NGit.Treewalk.TreeWalk.PopEntriesEqual">
            <exception cref="T:NGit.Errors.CorruptObjectException"></exception>
        </member>
        <member name="M:NGit.Treewalk.TreeWalk.SkipEntriesEqual">
            <exception cref="T:NGit.Errors.CorruptObjectException"></exception>
        </member>
        <member name="M:NGit.Treewalk.TreeWalk.ParserFor(NGit.AnyObjectId)">
            <exception cref="T:NGit.Errors.IncorrectObjectTypeException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="P:NGit.Treewalk.TreeWalk.ObjectReader">
            <returns>the reader this walker is using to load objects.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "P:NGit.Treewalk.TreeWalk.Filter" -->
        <!-- Badly formed XML comment ignored for member "P:NGit.Treewalk.TreeWalk.Recursive" -->
        <!-- Badly formed XML comment ignored for member "P:NGit.Treewalk.TreeWalk.PostOrderTraversal" -->
        <member name="P:NGit.Treewalk.TreeWalk.TreeCount">
            <summary>Get the number of trees known to this walker.</summary>
            <remarks>Get the number of trees known to this walker.</remarks>
            <returns>the total number of trees this walker is iterating over.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "P:NGit.Treewalk.TreeWalk.NameString" -->
        <!-- Badly formed XML comment ignored for member "P:NGit.Treewalk.TreeWalk.PathString" -->
        <member name="P:NGit.Treewalk.TreeWalk.RawPath">
            <summary>Get the current entry's complete path as a UTF-8 byte array.</summary>
            <remarks>Get the current entry's complete path as a UTF-8 byte array.</remarks>
            <returns>
            complete path of the current entry, from the root of the
            repository. If the current entry is in a subtree there will be at
            least one '/' in the returned string.
            </returns>
        </member>
        <member name="P:NGit.Treewalk.TreeWalk.Depth">
            <summary>Get the current subtree depth of this walker.</summary>
            <remarks>Get the current subtree depth of this walker.</remarks>
            <returns>the current subtree depth of this walker.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "P:NGit.Treewalk.TreeWalk.IsSubtree" -->
        <member name="P:NGit.Treewalk.TreeWalk.IsPostChildren">
            <summary>Is the current entry a subtree returned after its children?</summary>
            <returns>
            true if the current node is a tree that has been returned after
            its children were already processed.
            </returns>
            <seealso cref="P:NGit.Treewalk.TreeWalk.PostOrderTraversal">PostOrderTraversal()</seealso>
        </member>
        <member name="M:NGit.Treewalk.NameConflictTreeWalk.#ctor(NGit.Repository)">
            <summary>Create a new tree walker for a given repository.</summary>
            <remarks>Create a new tree walker for a given repository.</remarks>
            <param name="repo">the repository the walker will obtain data from.</param>
        </member>
        <member name="M:NGit.Treewalk.NameConflictTreeWalk.#ctor(NGit.ObjectReader)">
            <summary>Create a new tree walker for a given repository.</summary>
            <remarks>Create a new tree walker for a given repository.</remarks>
            <param name="or">the reader the walker will obtain tree data from.</param>
        </member>
        <member name="M:NGit.Treewalk.NameConflictTreeWalk.Min">
            <exception cref="T:NGit.Errors.CorruptObjectException"></exception>
        </member>
        <member name="M:NGit.Treewalk.NameConflictTreeWalk.SkipEntry(NGit.Treewalk.AbstractTreeIterator)">
            <exception cref="T:NGit.Errors.CorruptObjectException"></exception>
        </member>
        <member name="M:NGit.Treewalk.NameConflictTreeWalk.CombineDF(NGit.Treewalk.AbstractTreeIterator)">
            <exception cref="T:NGit.Errors.CorruptObjectException"></exception>
        </member>
        <member name="M:NGit.Treewalk.NameConflictTreeWalk.PopEntriesEqual">
            <exception cref="T:NGit.Errors.CorruptObjectException"></exception>
        </member>
        <member name="M:NGit.Treewalk.NameConflictTreeWalk.SkipEntriesEqual">
            <exception cref="T:NGit.Errors.CorruptObjectException"></exception>
        </member>
        <member name="M:NGit.Treewalk.NameConflictTreeWalk.IsDirectoryFileConflict">
            <summary>True if the current entry is covered by a directory/file conflict.</summary>
            <remarks>
            True if the current entry is covered by a directory/file conflict.
            This means that for some prefix of the current entry's path, this walk
            has detected a directory/file conflict. Also true if the current entry
            itself is a directory/file conflict.
            Example: If this TreeWalk points to foo/bar/a.txt and this method returns
            true then you know that either for path foo or for path foo/bar files and
            folders were detected.
            </remarks>
            <returns>
            <code>true</code> if the current entry is covered by a
            directory/file conflict, <code>false</code> otherwise
            </returns>
        </member>
        <member name="T:NGit.Storage.Pack.DeltaEncoder">
            <summary>
            Encodes an instruction stream for
            <see cref="T:NGit.Storage.Pack.BinaryDelta">BinaryDelta</see>
            .
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:NGit.Storage.Pack.DeltaEncoder.MAX_V2_COPY" -->
        <member name="F:NGit.Storage.Pack.DeltaEncoder.MAX_COPY_CMD_SIZE">
            <summary>Maximum number of bytes used by a copy instruction.</summary>
            <remarks>Maximum number of bytes used by a copy instruction.</remarks>
        </member>
        <member name="F:NGit.Storage.Pack.DeltaEncoder.MAX_INSERT_DATA_SIZE">
            <summary>Maximum length that an an insert command can encode at once.</summary>
            <remarks>Maximum length that an an insert command can encode at once.</remarks>
        </member>
        <member name="M:NGit.Storage.Pack.DeltaEncoder.#ctor(Sharpen.OutputStream,System.Int64,System.Int64)">
            <summary>Create an encoder with no upper bound on the instruction stream size.</summary>
            <remarks>Create an encoder with no upper bound on the instruction stream size.</remarks>
            <param name="out">buffer to store the instructions written.</param>
            <param name="baseSize">size of the base object, in bytes.</param>
            <param name="resultSize">
            size of the resulting object, after applying this instruction
            stream to the base object, in bytes.
            </param>
            <exception cref="T:System.IO.IOException">
            the output buffer cannot store the instruction stream's
            header with the size fields.
            </exception>
        </member>
        <member name="M:NGit.Storage.Pack.DeltaEncoder.#ctor(Sharpen.OutputStream,System.Int64,System.Int64,System.Int32)">
            <summary>Create an encoder with an upper limit on the instruction size.</summary>
            <remarks>Create an encoder with an upper limit on the instruction size.</remarks>
            <param name="out">buffer to store the instructions written.</param>
            <param name="baseSize">size of the base object, in bytes.</param>
            <param name="resultSize">
            size of the resulting object, after applying this instruction
            stream to the base object, in bytes.
            </param>
            <param name="limit">
            maximum number of bytes to write to the out buffer declaring
            the stream is over limit and should be discarded. May be 0 to
            specify an infinite limit.
            </param>
            <exception cref="T:System.IO.IOException">
            the output buffer cannot store the instruction stream's
            header with the size fields.
            </exception>
        </member>
        <member name="M:NGit.Storage.Pack.DeltaEncoder.WriteVarint(System.Int64)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.Pack.DeltaEncoder.GetSize">
            <returns>current size of the delta stream, in bytes.</returns>
        </member>
        <member name="M:NGit.Storage.Pack.DeltaEncoder.Insert(System.String)">
            <summary>Insert a literal string of text, in UTF-8 encoding.</summary>
            <remarks>Insert a literal string of text, in UTF-8 encoding.</remarks>
            <param name="text">the string to insert.</param>
            <returns>
            true if the insert fits within the limit; false if the insert
            would cause the instruction stream to exceed the limit.
            </returns>
            <exception cref="T:System.IO.IOException">the instruction buffer can't store the instructions.
            	</exception>
        </member>
        <member name="M:NGit.Storage.Pack.DeltaEncoder.Insert(System.Byte[])">
            <summary>Insert a literal binary sequence.</summary>
            <remarks>Insert a literal binary sequence.</remarks>
            <param name="text">the binary to insert.</param>
            <returns>
            true if the insert fits within the limit; false if the insert
            would cause the instruction stream to exceed the limit.
            </returns>
            <exception cref="T:System.IO.IOException">the instruction buffer can't store the instructions.
            	</exception>
        </member>
        <member name="M:NGit.Storage.Pack.DeltaEncoder.Insert(System.Byte[],System.Int32,System.Int32)">
            <summary>Insert a literal binary sequence.</summary>
            <remarks>Insert a literal binary sequence.</remarks>
            <param name="text">the binary to insert.</param>
            <param name="off">
            offset within
            <code>text</code>
            to start copying from.
            </param>
            <param name="cnt">number of bytes to insert.</param>
            <returns>
            true if the insert fits within the limit; false if the insert
            would cause the instruction stream to exceed the limit.
            </returns>
            <exception cref="T:System.IO.IOException">the instruction buffer can't store the instructions.
            	</exception>
        </member>
        <member name="M:NGit.Storage.Pack.DeltaEncoder.Copy(System.Int64,System.Int32)">
            <summary>Create a copy instruction to copy from the base object.</summary>
            <remarks>Create a copy instruction to copy from the base object.</remarks>
            <param name="offset">
            position in the base object to copy from. This is absolute,
            from the beginning of the base.
            </param>
            <param name="cnt">number of bytes to copy.</param>
            <returns>
            true if the copy fits within the limit; false if the copy
            would cause the instruction stream to exceed the limit.
            </returns>
            <exception cref="T:System.IO.IOException">the instruction buffer cannot store the instructions.
            	</exception>
        </member>
        <member name="T:NGit.Storage.File.PackLock">
            <summary>
            Keeps track of a
            <see cref="T:NGit.Storage.File.PackFile">PackFile</see>
            's associated <code>.keep</code> file.
            </summary>
        </member>
        <member name="M:NGit.Storage.File.PackLock.#ctor(Sharpen.FilePath,NGit.Util.FS)">
            <summary>Create a new lock for a pack file.</summary>
            <remarks>Create a new lock for a pack file.</remarks>
            <param name="packFile">location of the <code>pack-*.pack</code> file.</param>
            <param name="fs">the filesystem abstraction used by the repository.</param>
        </member>
        <member name="M:NGit.Storage.File.PackLock.Lock(System.String)">
            <summary>Create the <code>pack-*.keep</code> file, with the given message.</summary>
            <remarks>Create the <code>pack-*.keep</code> file, with the given message.</remarks>
            <param name="msg">message to store in the file.</param>
            <returns>true if the keep file was successfully written; false otherwise.</returns>
            <exception cref="T:System.IO.IOException">the keep file could not be written.</exception>
        </member>
        <member name="M:NGit.Storage.File.PackLock.Unlock">
            <summary>Remove the <code>.keep</code> file that holds this pack in place.</summary>
            <remarks>Remove the <code>.keep</code> file that holds this pack in place.</remarks>
            <exception cref="T:System.IO.IOException">if deletion of .keep file failed</exception>
        </member>
        <member name="T:NGit.Storage.File.PackFile">
            <summary>A Git version 2 pack file representation.</summary>
            <remarks>
            A Git version 2 pack file representation. A pack file contains Git objects in
            delta packed format yielding high compression of lots of object where some
            objects are similar.
            </remarks>
        </member>
        <member name="F:NGit.Storage.File.PackFile.SORT">
            <summary>Sorts PackFiles to be most recently created to least recently created.</summary>
            <remarks>Sorts PackFiles to be most recently created to least recently created.</remarks>
        </member>
        <member name="F:NGit.Storage.File.PackFile.readLock">
            <summary>
            Serializes reads performed against
            <see cref="F:NGit.Storage.File.PackFile.fd">fd</see>
            .
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:NGit.Storage.File.PackFile.corruptObjects" -->
        <member name="M:NGit.Storage.File.PackFile.#ctor(Sharpen.FilePath,Sharpen.FilePath)">
            <summary>Construct a reader for an existing, pre-indexed packfile.</summary>
            <remarks>Construct a reader for an existing, pre-indexed packfile.</remarks>
            <param name="idxFile">path of the <code>.idx</code> file listing the contents.</param>
            <param name="packFile">path of the <code>.pack</code> file holding the data.</param>
        </member>
        <member name="M:NGit.Storage.File.PackFile.Idx">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.PackFile.GetPackFile">
            <returns>the File object which locates this pack on disk.</returns>
        </member>
        <member name="M:NGit.Storage.File.PackFile.GetPackName">
            <returns>
            name extracted from
            <code>pack-*.pack</code>
            pattern.
            </returns>
        </member>
        <member name="M:NGit.Storage.File.PackFile.HasObject(NGit.AnyObjectId)">
            <summary>Determine if an object is contained within the pack file.</summary>
            <remarks>
            Determine if an object is contained within the pack file.
            <p>
            For performance reasons only the index file is searched; the main pack
            content is ignored entirely.
            </p>
            </remarks>
            <param name="id">the object to look for. Must not be null.</param>
            <returns>true if the object is in this pack; false otherwise.</returns>
            <exception cref="T:System.IO.IOException">the index file cannot be loaded into memory.
            	</exception>
        </member>
        <member name="M:NGit.Storage.File.PackFile.Get(NGit.Storage.File.WindowCursor,NGit.AnyObjectId)">
            <summary>Get an object from this pack.</summary>
            <remarks>Get an object from this pack.</remarks>
            <param name="curs">temporary working space associated with the calling thread.</param>
            <param name="id">the object to obtain from the pack. Must not be null.</param>
            <returns>
            the object loader for the requested object if it is contained in
            this pack; null if the object was not found.
            </returns>
            <exception cref="T:System.IO.IOException">the pack file or the index could not be read.
            	</exception>
        </member>
        <member name="M:NGit.Storage.File.PackFile.Resolve(System.Collections.Generic.ICollection{NGit.ObjectId},NGit.AbbreviatedObjectId,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.PackFile.Close">
            <summary>Close the resources utilized by this repository</summary>
        </member>
        <member name="M:NGit.Storage.File.PackFile.Iterator">
            <summary>
            Provide iterator over entries in associated pack index, that should also
            exist in this pack file.
            </summary>
            <remarks>
            Provide iterator over entries in associated pack index, that should also
            exist in this pack file. Objects returned by such iterator are mutable
            during iteration.
            <p>
            Iterator returns objects in SHA-1 lexicographical order.
            </p>
            </remarks>
            <returns>iterator over entries of associated pack index</returns>
            <seealso cref="M:NGit.Storage.File.PackIndex.Iterator">PackIndex.Iterator()</seealso>
        </member>
        <member name="M:NGit.Storage.File.PackFile.GetObjectCount">
            <summary>Obtain the total number of objects available in this pack.</summary>
            <remarks>
            Obtain the total number of objects available in this pack. This method
            relies on pack index, giving number of effectively available objects.
            </remarks>
            <returns>number of objects in index of this pack, likewise in this pack</returns>
            <exception cref="T:System.IO.IOException">the index file cannot be loaded into memory.
            	</exception>
        </member>
        <member name="M:NGit.Storage.File.PackFile.FindObjectForOffset(System.Int64)">
            <summary>
            Search for object id with the specified start offset in associated pack
            (reverse) index.
            </summary>
            <remarks>
            Search for object id with the specified start offset in associated pack
            (reverse) index.
            </remarks>
            <param name="offset">start offset of object to find</param>
            <returns>object id for this offset, or null if no object was found</returns>
            <exception cref="T:System.IO.IOException">the index file cannot be loaded into memory.
            	</exception>
        </member>
        <member name="M:NGit.Storage.File.PackFile.Decompress(System.Int64,System.Int32,NGit.Storage.File.WindowCursor)">
            <exception cref="T:System.IO.IOException"></exception>
            <exception cref="T:ICSharpCode.SharpZipLib.SharpZipBaseException"></exception>
        </member>
        <member name="M:NGit.Storage.File.PackFile.CopyPackAsIs(NGit.Storage.Pack.PackOutputStream,System.Boolean,NGit.Storage.File.WindowCursor)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.PackFile.CopyAsIs(NGit.Storage.Pack.PackOutputStream,NGit.Storage.File.LocalObjectToPack,System.Boolean,NGit.Storage.File.WindowCursor)">
            <exception cref="T:System.IO.IOException"></exception>
            <exception cref="T:NGit.Errors.StoredObjectRepresentationNotAvailableException"></exception>
        </member>
        <member name="M:NGit.Storage.File.PackFile.CopyAsIs2(NGit.Storage.Pack.PackOutputStream,NGit.Storage.File.LocalObjectToPack,System.Boolean,NGit.Storage.File.WindowCursor)">
            <exception cref="T:System.IO.IOException"></exception>
            <exception cref="T:NGit.Errors.StoredObjectRepresentationNotAvailableException"></exception>
        </member>
        <member name="M:NGit.Storage.File.PackFile.ReadFully(System.Int64,System.Byte[],System.Int32,System.Int32,NGit.Storage.File.WindowCursor)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.PackFile.BeginCopyAsIs(NGit.Storage.Pack.ObjectToPack)">
            <exception cref="T:NGit.Errors.StoredObjectRepresentationNotAvailableException"></exception>
        </member>
        <member name="M:NGit.Storage.File.PackFile.BeginWindowCache">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.PackFile.DoOpen">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.PackFile.Read(System.Int64,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.PackFile.Mmap(System.Int64,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.PackFile.OnOpenPack">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.PackFile.Load(NGit.Storage.File.WindowCursor,System.Int64)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.PackFile.FindDeltaBase(NGit.ObjectId)">
            <exception cref="T:System.IO.IOException"></exception>
            <exception cref="T:NGit.Errors.MissingObjectException"></exception>
        </member>
        <member name="M:NGit.Storage.File.PackFile.GetDeltaHeader(NGit.Storage.File.WindowCursor,System.Int64)">
            <exception cref="T:System.IO.IOException"></exception>
            <exception cref="T:ICSharpCode.SharpZipLib.SharpZipBaseException"></exception>
        </member>
        <member name="M:NGit.Storage.File.PackFile.GetObjectType(NGit.Storage.File.WindowCursor,System.Int64)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.PackFile.GetObjectSize(NGit.Storage.File.WindowCursor,NGit.AnyObjectId)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.PackFile.GetObjectSize(NGit.Storage.File.WindowCursor,System.Int64)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.PackFile.Representation(NGit.Storage.File.WindowCursor,NGit.AnyObjectId)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.PackFile.FindEndOffset(System.Int64)">
            <exception cref="T:System.IO.IOException"></exception>
            <exception cref="T:NGit.Errors.CorruptObjectException"></exception>
        </member>
        <member name="M:NGit.Storage.File.PackFile.GetReverseIdx">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="F:NGit.Storage.File.PackFile.Delta.next">
            <summary>Child that applies onto this object.</summary>
            <remarks>Child that applies onto this object.</remarks>
        </member>
        <member name="F:NGit.Storage.File.PackFile.Delta.deltaPos">
            <summary>Offset of the delta object.</summary>
            <remarks>Offset of the delta object.</remarks>
        </member>
        <member name="F:NGit.Storage.File.PackFile.Delta.deltaSize">
            <summary>Size of the inflated delta stream.</summary>
            <remarks>Size of the inflated delta stream.</remarks>
        </member>
        <member name="F:NGit.Storage.File.PackFile.Delta.hdrLen">
            <summary>Total size of the delta's pack entry header (including base).</summary>
            <remarks>Total size of the delta's pack entry header (including base).</remarks>
        </member>
        <member name="F:NGit.Storage.File.PackFile.Delta.basePos">
            <summary>Offset of the base object this delta applies onto.</summary>
            <remarks>Offset of the base object this delta applies onto.</remarks>
        </member>
        <member name="T:NGit.Storage.File.LocalObjectToPack">
            <summary>
            <see cref="T:NGit.Storage.Pack.ObjectToPack">NGit.Storage.Pack.ObjectToPack</see>
            for
            <see cref="T:NGit.Storage.File.ObjectDirectory">ObjectDirectory</see>
            .
            </summary>
        </member>
        <member name="F:NGit.Storage.File.LocalObjectToPack.pack">
            <summary>Pack to reuse compressed data from, otherwise null.</summary>
            <remarks>Pack to reuse compressed data from, otherwise null.</remarks>
        </member>
        <member name="F:NGit.Storage.File.LocalObjectToPack.offset">
            <summary>
            Offset of the object's header in
            <see cref="F:NGit.Storage.File.LocalObjectToPack.pack">pack</see>
            .
            </summary>
        </member>
        <member name="F:NGit.Storage.File.LocalObjectToPack.length">
            <summary>Length of the data section of the object.</summary>
            <remarks>Length of the data section of the object.</remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Revwalk.Filter.AndRevFilter" -->
        <member name="M:NGit.Revwalk.Filter.AndRevFilter.Create(NGit.Revwalk.Filter.RevFilter,NGit.Revwalk.Filter.RevFilter)">
            <summary>Create a filter with two filters, both of which must match.</summary>
            <remarks>Create a filter with two filters, both of which must match.</remarks>
            <param name="a">first filter to test.</param>
            <param name="b">second filter to test.</param>
            <returns>a filter that must match both input filters.</returns>
        </member>
        <member name="M:NGit.Revwalk.Filter.AndRevFilter.Create(NGit.Revwalk.Filter.RevFilter[])">
            <summary>Create a filter around many filters, all of which must match.</summary>
            <remarks>Create a filter around many filters, all of which must match.</remarks>
            <param name="list">
            list of filters to match against. Must contain at least 2
            filters.
            </param>
            <returns>a filter that must match all input filters.</returns>
        </member>
        <member name="M:NGit.Revwalk.Filter.AndRevFilter.Create(System.Collections.Generic.ICollection{NGit.Revwalk.Filter.RevFilter})">
            <summary>Create a filter around many filters, all of which must match.</summary>
            <remarks>Create a filter around many filters, all of which must match.</remarks>
            <param name="list">
            list of filters to match against. Must contain at least 2
            filters.
            </param>
            <returns>a filter that must match all input filters.</returns>
        </member>
        <member name="M:NGit.Revwalk.Filter.AndRevFilter.Binary.Include(NGit.Revwalk.RevWalk,NGit.Revwalk.RevCommit)">
            <exception cref="T:NGit.Errors.MissingObjectException"></exception>
            <exception cref="T:NGit.Errors.IncorrectObjectTypeException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Revwalk.Filter.AndRevFilter.List.Include(NGit.Revwalk.RevWalk,NGit.Revwalk.RevCommit)">
            <exception cref="T:NGit.Errors.MissingObjectException"></exception>
            <exception cref="T:NGit.Errors.IncorrectObjectTypeException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="T:NGit.Revwalk.RevBlob">
            <summary>A binary file, or a symbolic link.</summary>
            <remarks>A binary file, or a symbolic link.</remarks>
        </member>
        <member name="M:NGit.Revwalk.RevBlob.#ctor(NGit.AnyObjectId)">
            <summary>Create a new blob reference.</summary>
            <remarks>Create a new blob reference.</remarks>
            <param name="id">object name for the blob.</param>
        </member>
        <member name="M:NGit.Revwalk.RevBlob.ParseHeaders(NGit.Revwalk.RevWalk)">
            <exception cref="T:NGit.Errors.MissingObjectException"></exception>
            <exception cref="T:NGit.Errors.IncorrectObjectTypeException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Revwalk.RevBlob.ParseBody(NGit.Revwalk.RevWalk)">
            <exception cref="T:NGit.Errors.MissingObjectException"></exception>
            <exception cref="T:NGit.Errors.IncorrectObjectTypeException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Revwalk.FollowFilter" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Revwalk.FollowFilter.Create(System.String)" -->
        <member name="M:NGit.Revwalk.FollowFilter.GetPath">
            <returns>the path this filter matches.</returns>
        </member>
        <member name="M:NGit.Revwalk.FollowFilter.Include(NGit.Treewalk.TreeWalk)">
            <exception cref="T:NGit.Errors.MissingObjectException"></exception>
            <exception cref="T:NGit.Errors.IncorrectObjectTypeException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Revwalk.FollowFilter.GetRenameCallback">
            <returns>
            the callback to which renames are reported, or <code>null</code>
            if none
            </returns>
        </member>
        <member name="M:NGit.Revwalk.FollowFilter.SetRenameCallback(NGit.Revwalk.RenameCallback)">
            <summary>Sets the callback to which renames shall be reported.</summary>
            <remarks>Sets the callback to which renames shall be reported.</remarks>
            <param name="callback">the callback to use</param>
        </member>
        <member name="T:NGit.Patch.HunkHeader">
            <summary>Hunk header describing the layout of a single block of lines</summary>
        </member>
        <member name="F:NGit.Patch.HunkHeader.startOffset">
            <summary>
            Offset within
            <see cref="F:NGit.Patch.HunkHeader.file">file</see>
            .buf to the "@@ -" line.
            </summary>
        </member>
        <member name="F:NGit.Patch.HunkHeader.endOffset">
            <summary>
            Position 1 past the end of this hunk within
            <see cref="F:NGit.Patch.HunkHeader.file">file</see>
            's buf.
            </summary>
        </member>
        <member name="F:NGit.Patch.HunkHeader.newStartLine">
            <summary>First line number in the post-image file where the hunk starts</summary>
        </member>
        <member name="F:NGit.Patch.HunkHeader.newLineCount">
            <summary>Total number of post-image lines this hunk covers (context + inserted)</summary>
        </member>
        <member name="F:NGit.Patch.HunkHeader.nContext">
            <summary>Total number of lines of context appearing in this hunk</summary>
        </member>
        <member name="M:NGit.Patch.HunkHeader.GetFileHeader">
            <returns>header for the file this hunk applies to</returns>
        </member>
        <member name="M:NGit.Patch.HunkHeader.GetBuffer">
            <returns>the byte array holding this hunk's patch script.</returns>
        </member>
        <member name="M:NGit.Patch.HunkHeader.GetStartOffset">
            <returns>
            offset the start of this hunk in
            <see cref="M:NGit.Patch.HunkHeader.GetBuffer">GetBuffer()</see>
            .
            </returns>
        </member>
        <member name="M:NGit.Patch.HunkHeader.GetEndOffset">
            <returns>
            offset one past the end of the hunk in
            <see cref="M:NGit.Patch.HunkHeader.GetBuffer">GetBuffer()</see>
            .
            </returns>
        </member>
        <member name="M:NGit.Patch.HunkHeader.GetOldImage">
            <returns>information about the old image mentioned in this hunk.</returns>
        </member>
        <member name="M:NGit.Patch.HunkHeader.GetNewStartLine">
            <returns>first line number in the post-image file where the hunk starts</returns>
        </member>
        <member name="M:NGit.Patch.HunkHeader.GetNewLineCount">
            <returns>Total number of post-image lines this hunk covers</returns>
        </member>
        <member name="M:NGit.Patch.HunkHeader.GetLinesContext">
            <returns>total number of lines of context appearing in this hunk</returns>
        </member>
        <member name="M:NGit.Patch.HunkHeader.ToEditList">
            <returns>a list describing the content edits performed within the hunk.</returns>
        </member>
        <member name="M:NGit.Patch.HunkHeader.ExtractFileLines(Sharpen.OutputStream[])">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="T:NGit.Patch.HunkHeader.OldImage">
            <summary>Details about an old image of the file.</summary>
            <remarks>Details about an old image of the file.</remarks>
        </member>
        <member name="F:NGit.Patch.HunkHeader.OldImage.startLine">
            <summary>First line number the hunk starts on in this file.</summary>
            <remarks>First line number the hunk starts on in this file.</remarks>
        </member>
        <member name="F:NGit.Patch.HunkHeader.OldImage.lineCount">
            <summary>Total number of lines this hunk covers in this file.</summary>
            <remarks>Total number of lines this hunk covers in this file.</remarks>
        </member>
        <member name="F:NGit.Patch.HunkHeader.OldImage.nDeleted">
            <summary>Number of lines deleted by the post-image from this file.</summary>
            <remarks>Number of lines deleted by the post-image from this file.</remarks>
        </member>
        <member name="F:NGit.Patch.HunkHeader.OldImage.nAdded">
            <summary>Number of lines added by the post-image not in this file.</summary>
            <remarks>Number of lines added by the post-image not in this file.</remarks>
        </member>
        <member name="M:NGit.Patch.HunkHeader.OldImage.GetStartLine">
            <returns>first line number the hunk starts on in this file.</returns>
        </member>
        <member name="M:NGit.Patch.HunkHeader.OldImage.GetLineCount">
            <returns>total number of lines this hunk covers in this file.</returns>
        </member>
        <member name="M:NGit.Patch.HunkHeader.OldImage.GetLinesDeleted">
            <returns>number of lines deleted by the post-image from this file.</returns>
        </member>
        <member name="M:NGit.Patch.HunkHeader.OldImage.GetLinesAdded">
            <returns>number of lines added by the post-image not in this file.</returns>
        </member>
        <member name="M:NGit.Patch.HunkHeader.OldImage.GetId">
            <returns>object id of the pre-image file.</returns>
        </member>
        <member name="T:NGit.Patch.BinaryHunk">
            <summary>Part of a "GIT binary patch" to describe the pre-image or post-image</summary>
        </member>
        <member name="F:NGit.Patch.BinaryHunk.startOffset">
            <summary>
            Offset within
            <see cref="F:NGit.Patch.BinaryHunk.file">file</see>
            .buf to the "literal" or "delta " line.
            </summary>
        </member>
        <member name="F:NGit.Patch.BinaryHunk.endOffset">
            <summary>
            Position 1 past the end of this hunk within
            <see cref="F:NGit.Patch.BinaryHunk.file">file</see>
            's buf.
            </summary>
        </member>
        <member name="F:NGit.Patch.BinaryHunk.type">
            <summary>Type of the data meaning.</summary>
            <remarks>Type of the data meaning.</remarks>
        </member>
        <member name="F:NGit.Patch.BinaryHunk.length">
            <summary>Inflated length of the data.</summary>
            <remarks>Inflated length of the data.</remarks>
        </member>
        <member name="M:NGit.Patch.BinaryHunk.GetFileHeader">
            <returns>header for the file this hunk applies to</returns>
        </member>
        <member name="M:NGit.Patch.BinaryHunk.GetBuffer">
            <returns>the byte array holding this hunk's patch script.</returns>
        </member>
        <member name="M:NGit.Patch.BinaryHunk.GetStartOffset">
            <returns>
            offset the start of this hunk in
            <see cref="M:NGit.Patch.BinaryHunk.GetBuffer">GetBuffer()</see>
            .
            </returns>
        </member>
        <member name="M:NGit.Patch.BinaryHunk.GetEndOffset">
            <returns>
            offset one past the end of the hunk in
            <see cref="M:NGit.Patch.BinaryHunk.GetBuffer">GetBuffer()</see>
            .
            </returns>
        </member>
        <member name="M:NGit.Patch.BinaryHunk.GetType">
            <returns>type of this binary hunk</returns>
        </member>
        <member name="M:NGit.Patch.BinaryHunk.GetSize">
            <returns>inflated size of this hunk's data</returns>
        </member>
        <member name="T:NGit.Patch.BinaryHunk.Type">
            <summary>Type of information stored in a binary hunk.</summary>
            <remarks>Type of information stored in a binary hunk.</remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Nls.GlobalBundleCache" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Nls.GlobalBundleCache.LookupBundle``1(System.Globalization.CultureInfo)" -->
        <member name="T:NGit.Errors.ConfigInvalidException">
            <summary>Indicates a text string is not a valid Git style configuration.</summary>
            <remarks>Indicates a text string is not a valid Git style configuration.</remarks>
        </member>
        <member name="M:NGit.Errors.ConfigInvalidException.#ctor(System.String)">
            <summary>Construct an invalid configuration error.</summary>
            <remarks>Construct an invalid configuration error.</remarks>
            <param name="message">why the configuration is invalid.</param>
        </member>
        <member name="M:NGit.Errors.ConfigInvalidException.#ctor(System.String,System.Exception)">
            <summary>Construct an invalid configuration error.</summary>
            <remarks>Construct an invalid configuration error.</remarks>
            <param name="message">why the configuration is invalid.</param>
            <param name="cause">root cause of the error.</param>
        </member>
        <member name="T:NGit.TextProgressMonitor">
            <summary>A simple progress reporter printing on a stream.</summary>
            <remarks>A simple progress reporter printing on a stream.</remarks>
        </member>
        <member name="M:NGit.TextProgressMonitor.#ctor">
            <summary>Initialize a new progress monitor.</summary>
            <remarks>Initialize a new progress monitor.</remarks>
        </member>
        <member name="M:NGit.TextProgressMonitor.#ctor(System.IO.TextWriter)">
            <summary>Initialize a new progress monitor.</summary>
            <remarks>Initialize a new progress monitor.</remarks>
            <param name="out">the stream to receive messages on.</param>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Transport.AdvertiseRefsHookChain" -->
        <member name="M:NGit.Transport.AdvertiseRefsHookChain.NewChain``1(System.Collections.Generic.IList{``0})">
            <summary>Create a new hook chaining the given hooks together.</summary>
            <remarks>Create a new hook chaining the given hooks together.</remarks>
            <param name="hooks">hooks to execute, in order.</param>
            <returns>a new hook chain of the given hooks.</returns>
        </member>
        <member name="M:NGit.Transport.AdvertiseRefsHookChain.AdvertiseRefs(NGit.Transport.BaseReceivePack)">
            <exception cref="T:NGit.Transport.ServiceMayNotContinueException"></exception>
        </member>
        <member name="M:NGit.Transport.AdvertiseRefsHookChain.AdvertiseRefs(NGit.Transport.UploadPack)">
            <exception cref="T:NGit.Transport.ServiceMayNotContinueException"></exception>
        </member>
        <member name="T:NGit.BranchTrackingStatus">
            <summary>Status of a branch's relation to its remote-tracking branch.</summary>
            <remarks>Status of a branch's relation to its remote-tracking branch.</remarks>
        </member>
        <member name="M:NGit.BranchTrackingStatus.Of(NGit.Repository,System.String)">
            <summary>
            Compute the tracking status for the <code>branchName</code> in
            <code>repository</code>.
            </summary>
            <remarks>
            Compute the tracking status for the <code>branchName</code> in
            <code>repository</code>.
            </remarks>
            <param name="repository">the git repository to compute the status from</param>
            <param name="branchName">the local branch</param>
            <returns>the tracking status, or null if it is not known</returns>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:NGit.BranchTrackingStatus.GetRemoteTrackingBranch">
            <returns>full remote-tracking branch name</returns>
        </member>
        <member name="M:NGit.BranchTrackingStatus.GetAheadCount">
            <returns>
            number of commits that the local branch is ahead of the
            remote-tracking branch
            </returns>
        </member>
        <member name="M:NGit.BranchTrackingStatus.GetBehindCount">
            <returns>
            number of commits that the local branch is behind of the
            remote-tracking branch
            </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Transport.PostReceiveHookChain" -->
        <member name="M:NGit.Transport.PostReceiveHookChain.NewChain``1(System.Collections.Generic.IList{``0})">
            <summary>Create a new hook chaining the given hooks together.</summary>
            <remarks>Create a new hook chaining the given hooks together.</remarks>
            <param name="hooks">hooks to execute, in order.</param>
            <returns>a new hook chain of the given hooks.</returns>
        </member>
        <member name="T:NGit.Util.IO.CountingOutputStream">
            <summary>Counts the number of bytes written.</summary>
            <remarks>Counts the number of bytes written.</remarks>
        </member>
        <member name="M:NGit.Util.IO.CountingOutputStream.#ctor(Sharpen.OutputStream)">
            <summary>Initialize a new counting stream.</summary>
            <remarks>Initialize a new counting stream.</remarks>
            <param name="out">stream to output all writes to.</param>
        </member>
        <member name="M:NGit.Util.IO.CountingOutputStream.GetCount">
            <returns>current number of bytes written.</returns>
        </member>
        <member name="M:NGit.Util.IO.CountingOutputStream.Write(System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Util.IO.CountingOutputStream.Write(System.Byte[],System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Util.IO.CountingOutputStream.Flush">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Util.IO.CountingOutputStream.Close">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Api.SubmoduleAddCommand" -->
        <member name="M:NGit.Api.SubmoduleAddCommand.#ctor(NGit.Repository)">
            <param name="repo"></param>
        </member>
        <member name="M:NGit.Api.SubmoduleAddCommand.SetPath(System.String)">
            <summary>Set repository-relative path of submodule</summary>
            <param name="path"></param>
            <returns>this command</returns>
        </member>
        <member name="M:NGit.Api.SubmoduleAddCommand.SetURI(System.String)">
            <summary>Set URI to clone submodule from</summary>
            <param name="uri"></param>
            <returns>this command</returns>
        </member>
        <member name="M:NGit.Api.SubmoduleAddCommand.SetProgressMonitor(NGit.ProgressMonitor)">
            <summary>The progress monitor associated with the clone operation.</summary>
            <remarks>
            The progress monitor associated with the clone operation. By default,
            this is set to <code>NullProgressMonitor</code>
            </remarks>
            <seealso cref="T:NGit.NullProgressMonitor">NGit.NullProgressMonitor</seealso>
            <param name="monitor"></param>
            <returns>this command</returns>
        </member>
        <member name="M:NGit.Api.SubmoduleAddCommand.SubmoduleExists">
            <summary>Is the configured already a submodule in the index?</summary>
            <returns>true if submodule exists in index, false otherwise</returns>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:NGit.Api.SubmoduleAddCommand.Call">
            <exception cref="T:NGit.Api.Errors.GitAPIException"></exception>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Api.ListTagCommand" -->
        <member name="M:NGit.Api.ListTagCommand.#ctor(NGit.Repository)">
            <param name="repo"></param>
        </member>
        <member name="M:NGit.Api.ListTagCommand.Call">
            <returns>the tags available</returns>
            <exception cref="T:NGit.Api.Errors.GitAPIException"></exception>
        </member>
        <member name="T:NGit.Storage.Pack.CachedPack">
            <summary>
            Describes a pack file
            <see cref="T:NGit.Storage.Pack.ObjectReuseAsIs">ObjectReuseAsIs</see>
            can append onto a stream.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Storage.Pack.CachedPack.GetTips" -->
        <member name="M:NGit.Storage.Pack.CachedPack.GetObjectCount">
            <summary>Get the number of objects in this pack.</summary>
            <remarks>Get the number of objects in this pack.</remarks>
            <returns>the total object count for the pack.</returns>
            <exception cref="T:System.IO.IOException">if the object count cannot be read.</exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Storage.Pack.CachedPack.GetDeltaCount" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Storage.Pack.CachedPack.HasObject(NGit.Storage.Pack.ObjectToPack,NGit.Storage.Pack.StoredObjectRepresentation)" -->
        <member name="M:NGit.Storage.File.LocalCachedPack.GetObjectCount">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.LocalCachedPack.CopyAsIs(NGit.Storage.Pack.PackOutputStream,System.Boolean,NGit.Storage.File.WindowCursor)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.LocalCachedPack.GetPacks">
            <exception cref="T:System.IO.FileNotFoundException"></exception>
        </member>
        <member name="M:NGit.Storage.File.LocalCachedPack.GetPackFile(System.String)">
            <exception cref="T:System.IO.FileNotFoundException"></exception>
        </member>
        <member name="T:NGit.Api.CheckoutResult">
            <summary>
            Encapsulates the result of a
            <see cref="T:NGit.Api.CheckoutCommand">CheckoutCommand</see>
            </summary>
        </member>
        <member name="F:NGit.Api.CheckoutResult.OK_RESULT">
            <summary>
            The
            <see cref="F:NGit.Api.CheckoutResult.Status.OK">Status.OK</see>
            result;
            </summary>
        </member>
        <member name="F:NGit.Api.CheckoutResult.ERROR_RESULT">
            <summary>
            The
            <see cref="F:NGit.Api.CheckoutResult.Status.ERROR">Status.ERROR</see>
            result;
            </summary>
        </member>
        <member name="F:NGit.Api.CheckoutResult.NOT_TRIED_RESULT">
            <summary>
            The
            <see cref="F:NGit.Api.CheckoutResult.Status.NOT_TRIED">Status.NOT_TRIED</see>
            result;
            </summary>
        </member>
        <member name="M:NGit.Api.CheckoutResult.GetStatus">
            <returns>the status</returns>
        </member>
        <member name="M:NGit.Api.CheckoutResult.GetConflictList">
            <returns>
            the list of files that created a checkout conflict, or an empty
            list if
            <see cref="M:NGit.Api.CheckoutResult.GetStatus">GetStatus()</see>
            is not
            <see cref="F:NGit.Api.CheckoutResult.Status.CONFLICTS">Status.CONFLICTS</see>
            ;
            </returns>
        </member>
        <member name="M:NGit.Api.CheckoutResult.GetUndeletedList">
            <returns>
            the list of files that could not be deleted during checkout, or
            an empty list if
            <see cref="M:NGit.Api.CheckoutResult.GetStatus">GetStatus()</see>
            is not
            <see cref="F:NGit.Api.CheckoutResult.Status.NONDELETED">Status.NONDELETED</see>
            ;
            </returns>
        </member>
        <member name="T:NGit.Api.CheckoutResult.Status">
            <summary>The status</summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Storage.File.FileSnapshot" -->
        <!-- Badly formed XML comment ignored for member "F:NGit.Storage.File.FileSnapshot.DIRTY" -->
        <!-- Badly formed XML comment ignored for member "F:NGit.Storage.File.FileSnapshot.MISSING_FILE" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Storage.File.FileSnapshot.Save(Sharpen.FilePath)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Storage.File.FileSnapshot.Save(System.Int64)" -->
        <member name="F:NGit.Storage.File.FileSnapshot.lastModified">
            <summary>Last observed modification time of the path.</summary>
            <remarks>Last observed modification time of the path.</remarks>
        </member>
        <member name="F:NGit.Storage.File.FileSnapshot.lastRead">
            <summary>Last wall-clock time the path was read.</summary>
            <remarks>Last wall-clock time the path was read.</remarks>
        </member>
        <member name="F:NGit.Storage.File.FileSnapshot.cannotBeRacilyClean">
            <summary>
            True once
            <see cref="F:NGit.Storage.File.FileSnapshot.lastRead">lastRead</see>
            is far later than
            <see cref="F:NGit.Storage.File.FileSnapshot.lastModified">lastModified</see>
            .
            </summary>
        </member>
        <member name="M:NGit.Storage.File.FileSnapshot.LastModified">
            <returns>time of last snapshot update</returns>
        </member>
        <member name="M:NGit.Storage.File.FileSnapshot.IsModified(Sharpen.FilePath)">
            <summary>Check if the path may have been modified since the snapshot was saved.</summary>
            <remarks>Check if the path may have been modified since the snapshot was saved.</remarks>
            <param name="path">the path the snapshot describes.</param>
            <returns>true if the path needs to be read again.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Storage.File.FileSnapshot.SetClean(NGit.Storage.File.FileSnapshot)" -->
        <member name="M:NGit.Storage.File.FileSnapshot.Equals(NGit.Storage.File.FileSnapshot)">
            <summary>Compare two snapshots to see if they cache the same information.</summary>
            <remarks>Compare two snapshots to see if they cache the same information.</remarks>
            <param name="other">the other snapshot.</param>
            <returns>true if the two snapshots share the same information.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Treewalk.Filter.IndexDiffFilter" -->
        <member name="M:NGit.Treewalk.Filter.IndexDiffFilter.#ctor(System.Int32,System.Int32)">
            <summary>Creates a new instance of this filter.</summary>
            <remarks>
            Creates a new instance of this filter. Do not use an instance of this
            filter in multiple treewalks.
            </remarks>
            <param name="dirCacheIndex">
            the index of the
            <see cref="T:NGit.Dircache.DirCacheIterator">NGit.Dircache.DirCacheIterator</see>
            in the associated
            treewalk
            </param>
            <param name="workingTreeIndex">
            the index of the
            <see cref="T:NGit.Treewalk.WorkingTreeIterator">NGit.Treewalk.WorkingTreeIterator</see>
            in the associated
            treewalk
            </param>
        </member>
        <member name="M:NGit.Treewalk.Filter.IndexDiffFilter.#ctor(System.Int32,System.Int32,System.Boolean)">
            <summary>Creates a new instance of this filter.</summary>
            <remarks>
            Creates a new instance of this filter. Do not use an instance of this
            filter in multiple treewalks.
            </remarks>
            <param name="dirCacheIndex">
            the index of the
            <see cref="T:NGit.Dircache.DirCacheIterator">NGit.Dircache.DirCacheIterator</see>
            in the associated
            treewalk
            </param>
            <param name="workingTreeIndex">
            the index of the
            <see cref="T:NGit.Treewalk.WorkingTreeIterator">NGit.Treewalk.WorkingTreeIterator</see>
            in the associated
            treewalk
            </param>
            <param name="honorIgnores">
            true if the filter should skip working tree files that are
            declared as ignored by the standard exclude mechanisms..
            </param>
        </member>
        <member name="M:NGit.Treewalk.Filter.IndexDiffFilter.Include(NGit.Treewalk.TreeWalk)">
            <exception cref="T:NGit.Errors.MissingObjectException"></exception>
            <exception cref="T:NGit.Errors.IncorrectObjectTypeException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Treewalk.Filter.IndexDiffFilter.CopyUntrackedFolders(System.String)">
            <summary>
            Copy all entries which are still in untrackedParentFolders and which
            belong to a path this treewalk has left into untrackedFolders.
            </summary>
            <remarks>
            Copy all entries which are still in untrackedParentFolders and which
            belong to a path this treewalk has left into untrackedFolders. It is sure
            that we will not find any tracked files underneath these paths. Therefore
            these paths definitely belong to untracked folders.
            </remarks>
            <param name="currentPath">the current path of the treewalk</param>
        </member>
        <member name="M:NGit.Treewalk.Filter.IndexDiffFilter.GetIgnoredPaths">
            <summary>The method returns the list of ignored files and folders.</summary>
            <remarks>
            The method returns the list of ignored files and folders. Only the root
            folder of an ignored folder hierarchy is reported. If a/b/c is listed in
            the .gitignore then you should not expect a/b/c/d/e/f to be reported
            here. Only a/b/c will be reported. Furthermore only ignored files /
            folders are returned that are NOT in the index.
            </remarks>
            <returns>ignored paths</returns>
        </member>
        <member name="M:NGit.Treewalk.Filter.IndexDiffFilter.GetUntrackedFolders">
            <returns>
            all paths of folders which contain only untracked files/folders.
            If on the associated treewalk postorder traversal was turned on
            (see
            <see cref="!:NGit.Treewalk.TreeWalk.PostOrderTraversal(bool)">NGit.Treewalk.TreeWalk.PostOrderTraversal(bool)
            	</see>
            ) then an
            empty list will be returned.
            </returns>
        </member>
        <member name="T:NGit.Notes.NoteMap">
            <summary>Index of notes from a note branch.</summary>
            <remarks>
            Index of notes from a note branch.
            This class is not thread-safe, and relies on an
            <see cref="T:NGit.ObjectReader">NGit.ObjectReader</see>
            that it
            borrows/shares with the caller. The reader can be used during any call, and
            is not released by this class. The caller should arrange for releasing the
            shared
            <code>ObjectReader</code>
            at the proper times.
            </remarks>
        </member>
        <member name="M:NGit.Notes.NoteMap.NewEmptyMap">
            <summary>Construct a new empty note map.</summary>
            <remarks>Construct a new empty note map.</remarks>
            <returns>an empty note map.</returns>
        </member>
        <member name="M:NGit.Notes.NoteMap.ShortenRefName(System.String)">
            <summary>
            Shorten the note ref name by trimming off the
            <see cref="F:NGit.Constants.R_NOTES">NGit.Constants.R_NOTES</see>
            prefix if it exists.
            </summary>
            <param name="noteRefName"></param>
            <returns>a more user friendly note name</returns>
        </member>
        <member name="M:NGit.Notes.NoteMap.Read(NGit.ObjectReader,NGit.Revwalk.RevCommit)">
            <summary>Load a collection of notes from a branch.</summary>
            <remarks>Load a collection of notes from a branch.</remarks>
            <param name="reader">
            reader to scan the note branch with. This reader may be
            retained by the NoteMap for the life of the map in order to
            support lazy loading of entries.
            </param>
            <param name="commit">the revision of the note branch to read.</param>
            <returns>the note map read from the commit.</returns>
            <exception cref="T:System.IO.IOException">the repository cannot be accessed through the reader.
            	</exception>
            <exception cref="T:NGit.Errors.CorruptObjectException">a tree object is corrupt and cannot be read.
            	</exception>
            <exception cref="T:NGit.Errors.IncorrectObjectTypeException">a tree object wasn't actually a tree.
            	</exception>
            <exception cref="T:NGit.Errors.MissingObjectException">a reference tree object doesn't exist.
            	</exception>
        </member>
        <member name="M:NGit.Notes.NoteMap.Read(NGit.ObjectReader,NGit.Revwalk.RevTree)">
            <summary>Load a collection of notes from a tree.</summary>
            <remarks>Load a collection of notes from a tree.</remarks>
            <param name="reader">
            reader to scan the note branch with. This reader may be
            retained by the NoteMap for the life of the map in order to
            support lazy loading of entries.
            </param>
            <param name="tree">the note tree to read.</param>
            <returns>the note map read from the tree.</returns>
            <exception cref="T:System.IO.IOException">the repository cannot be accessed through the reader.
            	</exception>
            <exception cref="T:NGit.Errors.CorruptObjectException">a tree object is corrupt and cannot be read.
            	</exception>
            <exception cref="T:NGit.Errors.IncorrectObjectTypeException">a tree object wasn't actually a tree.
            	</exception>
            <exception cref="T:NGit.Errors.MissingObjectException">a reference tree object doesn't exist.
            	</exception>
        </member>
        <member name="M:NGit.Notes.NoteMap.ReadTree(NGit.ObjectReader,NGit.ObjectId)">
            <summary>Load a collection of notes from a tree.</summary>
            <remarks>Load a collection of notes from a tree.</remarks>
            <param name="reader">
            reader to scan the note branch with. This reader may be
            retained by the NoteMap for the life of the map in order to
            support lazy loading of entries.
            </param>
            <param name="treeId">the note tree to read.</param>
            <returns>the note map read from the tree.</returns>
            <exception cref="T:System.IO.IOException">the repository cannot be accessed through the reader.
            	</exception>
            <exception cref="T:NGit.Errors.CorruptObjectException">a tree object is corrupt and cannot be read.
            	</exception>
            <exception cref="T:NGit.Errors.IncorrectObjectTypeException">a tree object wasn't actually a tree.
            	</exception>
            <exception cref="T:NGit.Errors.MissingObjectException">a reference tree object doesn't exist.
            	</exception>
        </member>
        <member name="M:NGit.Notes.NoteMap.NewMap(NGit.Notes.InMemoryNoteBucket,NGit.ObjectReader)">
            <summary>Construct a new note map from an existing note bucket.</summary>
            <remarks>Construct a new note map from an existing note bucket.</remarks>
            <param name="root">the root bucket of this note map</param>
            <param name="reader">
            reader to scan the note branch with. This reader may be
            retained by the NoteMap for the life of the map in order to
            support lazy loading of entries.
            </param>
            <returns>the note map built from the note bucket</returns>
        </member>
        <member name="F:NGit.Notes.NoteMap.reader">
            <summary>Borrowed reader to access the repository.</summary>
            <remarks>Borrowed reader to access the repository.</remarks>
        </member>
        <member name="F:NGit.Notes.NoteMap.root">
            <summary>All of the notes that have been loaded.</summary>
            <remarks>All of the notes that have been loaded.</remarks>
        </member>
        <member name="M:NGit.Notes.NoteMap.Iterator">
            <returns>
            an iterator that iterates over notes of this NoteMap. Non note
            entries are ignored by this iterator.
            </returns>
        </member>
        <member name="M:NGit.Notes.NoteMap.Get(NGit.AnyObjectId)">
            <summary>Lookup a note for a specific ObjectId.</summary>
            <remarks>Lookup a note for a specific ObjectId.</remarks>
            <param name="id">the object to look for.</param>
            <returns>the note's blob ObjectId, or null if no note exists.</returns>
            <exception cref="T:System.IO.IOException">a portion of the note space is not accessible.
            	</exception>
        </member>
        <member name="M:NGit.Notes.NoteMap.GetNote(NGit.AnyObjectId)">
            <summary>Lookup a note for a specific ObjectId.</summary>
            <remarks>Lookup a note for a specific ObjectId.</remarks>
            <param name="id">the object to look for.</param>
            <returns>the note for the given object id, or null if no note exists.</returns>
            <exception cref="T:System.IO.IOException">a portion of the note space is not accessible.
            	</exception>
        </member>
        <member name="M:NGit.Notes.NoteMap.Contains(NGit.AnyObjectId)">
            <summary>Determine if a note exists for the specified ObjectId.</summary>
            <remarks>Determine if a note exists for the specified ObjectId.</remarks>
            <param name="id">the object to look for.</param>
            <returns>true if a note exists; false if there is no note.</returns>
            <exception cref="T:System.IO.IOException">a portion of the note space is not accessible.
            	</exception>
        </member>
        <member name="M:NGit.Notes.NoteMap.GetCachedBytes(NGit.AnyObjectId,System.Int32)">
            <summary>Open and return the content of an object's note.</summary>
            <remarks>
            Open and return the content of an object's note.
            This method assumes the note is fairly small and can be accessed
            efficiently. Larger notes should be accessed by streaming:
            <pre>
            ObjectId dataId = thisMap.get(id);
            if (dataId != null)
            reader.open(dataId).openStream();
            </pre>
            </remarks>
            <param name="id">object to lookup the note of.</param>
            <param name="sizeLimit">
            maximum number of bytes to return. If the note data size is
            larger than this limit, LargeObjectException will be thrown.
            </param>
            <returns>
            if a note is defined for
            <code>id</code>
            , the note content. If no note
            is defined, null.
            </returns>
            <exception cref="T:NGit.Errors.LargeObjectException">
            the note data is larger than
            <code>sizeLimit</code>
            .
            </exception>
            <exception cref="T:NGit.Errors.MissingObjectException">the note's blob does not exist in the repository.
            	</exception>
            <exception cref="T:System.IO.IOException">the note's blob cannot be read from the repository
            	</exception>
        </member>
        <member name="M:NGit.Notes.NoteMap.Set(NGit.AnyObjectId,NGit.ObjectId)">
            <summary>Attach (or remove) a note on an object.</summary>
            <remarks>
            Attach (or remove) a note on an object.
            If no note exists, a new note is stored. If a note already exists for the
            given object, it is replaced (or removed).
            This method only updates the map in memory.
            If the caller wants to attach a UTF-8 encoded string message to an
            object,
            <see cref="M:NGit.Notes.NoteMap.Set(NGit.AnyObjectId,System.String,NGit.ObjectInserter)">Set(NGit.AnyObjectId, string, NGit.ObjectInserter)
            	</see>
            is a convenient
            way to encode and update a note in one step.
            </remarks>
            <param name="noteOn">
            the object to attach the note to. This same ObjectId can later
            be used as an argument to
            <see cref="M:NGit.Notes.NoteMap.Get(NGit.AnyObjectId)">Get(NGit.AnyObjectId)</see>
            or
            <see cref="M:NGit.Notes.NoteMap.GetCachedBytes(NGit.AnyObjectId,System.Int32)">GetCachedBytes(NGit.AnyObjectId, int)
            	</see>
            to read back the
            <code>noteData</code>
            .
            </param>
            <param name="noteData">
            data to associate with the note. This must be the ObjectId of
            a blob that already exists in the repository. If null the note
            will be deleted, if present.
            </param>
            <exception cref="T:System.IO.IOException">a portion of the note space is not accessible.
            	</exception>
        </member>
        <member name="M:NGit.Notes.NoteMap.Set(NGit.AnyObjectId,System.String,NGit.ObjectInserter)">
            <summary>Attach a note to an object.</summary>
            <remarks>
            Attach a note to an object.
            If no note exists, a new note is stored. If a note already exists for the
            given object, it is replaced (or removed).
            </remarks>
            <param name="noteOn">
            the object to attach the note to. This same ObjectId can later
            be used as an argument to
            <see cref="M:NGit.Notes.NoteMap.Get(NGit.AnyObjectId)">Get(NGit.AnyObjectId)</see>
            or
            <see cref="M:NGit.Notes.NoteMap.GetCachedBytes(NGit.AnyObjectId,System.Int32)">GetCachedBytes(NGit.AnyObjectId, int)
            	</see>
            to read back the
            <code>noteData</code>
            .
            </param>
            <param name="noteData">
            text to store in the note. The text will be UTF-8 encoded when
            stored in the repository. If null the note will be deleted, if
            the empty string a note with the empty string will be stored.
            </param>
            <param name="ins">
            inserter to write the encoded
            <code>noteData</code>
            out as a blob.
            The caller must ensure the inserter is flushed before the
            updated note map is made available for reading.
            </param>
            <exception cref="T:System.IO.IOException">the note data could not be stored in the repository.
            	</exception>
        </member>
        <member name="M:NGit.Notes.NoteMap.Remove(NGit.AnyObjectId)">
            <summary>Remove a note from an object.</summary>
            <remarks>
            Remove a note from an object.
            If no note exists, no action is performed.
            This method only updates the map in memory.
            </remarks>
            <param name="noteOn">the object to remove the note from.</param>
            <exception cref="T:System.IO.IOException">a portion of the note space is not accessible.
            	</exception>
        </member>
        <member name="M:NGit.Notes.NoteMap.WriteTree(NGit.ObjectInserter)">
            <summary>Write this note map as a tree.</summary>
            <remarks>Write this note map as a tree.</remarks>
            <param name="inserter">
            inserter to use when writing trees to the object database.
            Caller is responsible for flushing the inserter before trying
            to read the objects, or exposing them through a reference.
            </param>
            <returns>the top level tree.</returns>
            <exception cref="T:System.IO.IOException">a tree could not be written.</exception>
        </member>
        <member name="M:NGit.Notes.NoteMap.GetRoot">
            <returns>the root note bucket</returns>
        </member>
        <member name="M:NGit.Notes.NoteMap.Load(NGit.ObjectId)">
            <exception cref="T:NGit.Errors.MissingObjectException"></exception>
            <exception cref="T:NGit.Errors.IncorrectObjectTypeException"></exception>
            <exception cref="T:NGit.Errors.CorruptObjectException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="T:NGit.Api.Errors.InvalidRefNameException">
            <summary>Exception thrown when an invalid Ref name was encountered</summary>
        </member>
        <member name="M:NGit.Api.Errors.InvalidRefNameException.#ctor(System.String)">
            <param name="msg"></param>
        </member>
        <member name="M:NGit.Api.Errors.InvalidRefNameException.#ctor(System.String,System.Exception)">
            <param name="msg"></param>
            <param name="cause"></param>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Api.CreateBranchCommand" -->
        <member name="M:NGit.Api.CreateBranchCommand.#ctor(NGit.Repository)">
            <param name="repo"></param>
        </member>
        <member name="M:NGit.Api.CreateBranchCommand.Call">
            <exception cref="T:NGit.Api.Errors.RefAlreadyExistsException">
            when trying to create (without force) a branch with a name
            that already exists
            </exception>
            <exception cref="T:NGit.Api.Errors.RefNotFoundException">if the start point can not be found
            	</exception>
            <exception cref="T:NGit.Api.Errors.InvalidRefNameException">
            if the provided name is <code>null</code> or otherwise
            invalid
            </exception>
            <returns>the newly created branch</returns>
            <exception cref="T:NGit.Api.Errors.GitAPIException"></exception>
        </member>
        <member name="M:NGit.Api.CreateBranchCommand.GetStartPoint">
            <exception cref="T:NGit.Errors.AmbiguousObjectException"></exception>
            <exception cref="T:NGit.Api.Errors.RefNotFoundException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Api.CreateBranchCommand.ProcessOptions">
            <exception cref="T:NGit.Api.Errors.InvalidRefNameException"></exception>
        </member>
        <member name="M:NGit.Api.CreateBranchCommand.SetName(System.String)">
            <param name="name">the name of the new branch</param>
            <returns>this instance</returns>
        </member>
        <member name="M:NGit.Api.CreateBranchCommand.SetForce(System.Boolean)">
            <param name="force">
            if <code>true</code> and the branch with the given name
            already exists, the start-point of an existing branch will be
            set to a new start-point; if false, the existing branch will
            not be changed
            </param>
            <returns>this instance</returns>
        </member>
        <member name="M:NGit.Api.CreateBranchCommand.SetStartPoint(System.String)">
            <param name="startPoint">
            corresponds to the start-point option; if <code>null</code>,
            the current HEAD will be used
            </param>
            <returns>this instance</returns>
        </member>
        <member name="M:NGit.Api.CreateBranchCommand.SetStartPoint(NGit.Revwalk.RevCommit)">
            <param name="startPoint">
            corresponds to the start-point option; if <code>null</code>,
            the current HEAD will be used
            </param>
            <returns>this instance</returns>
        </member>
        <member name="M:NGit.Api.CreateBranchCommand.SetUpstreamMode(NGit.Api.CreateBranchCommand.SetupUpstreamMode)">
            <param name="mode">
            corresponds to the --track/--no-track/--set-upstream options;
            may be <code>null</code>
            </param>
            <returns>this instance</returns>
        </member>
        <member name="T:NGit.Api.CreateBranchCommand.SetupUpstreamMode">
            <summary>
            The modes available for setting up the upstream configuration
            (corresponding to the --set-upstream, --track, --no-track options
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Diff.Subsequence`1" -->
        <member name="T:NGit.Diff.Sequence">
            <summary>Arbitrary sequence of elements.</summary>
            <remarks>
            Arbitrary sequence of elements.
            A sequence of elements is defined to contain elements in the index range
            <code>[0,
            <see cref="M:NGit.Diff.Sequence.Size">Size()</see>
            )</code>, like a standard Java List implementation.
            Unlike a List, the members of the sequence are not directly obtainable.
            Implementations of Sequence are primarily intended for use in content
            difference detection algorithms, to produce an
            <see cref="T:NGit.Diff.EditList">EditList</see>
            of
            <see cref="T:NGit.Diff.Edit">Edit</see>
            instances describing how two Sequence instances differ.
            To be compared against another Sequence of the same type, a supporting
            <see cref="T:NGit.Diff.SequenceComparator`1">SequenceComparator&lt;S&gt;</see>
            must also be supplied.
            </remarks>
        </member>
        <member name="M:NGit.Diff.Sequence.Size">
            <returns>total number of items in the sequence.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Diff.Subsequence`1.A``1(``0,NGit.Diff.Edit)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Diff.Subsequence`1.B``1(``0,NGit.Diff.Edit)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Diff.Subsequence`1.ToBase``1(NGit.Diff.Edit,NGit.Diff.Subsequence{``0},NGit.Diff.Subsequence{``0})" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Diff.Subsequence`1.ToBase``1(NGit.Diff.EditList,NGit.Diff.Subsequence{``0},NGit.Diff.Subsequence{``0})" -->
        <member name="M:NGit.Diff.Subsequence`1.#ctor(`0,System.Int32,System.Int32)">
            <summary>Construct a subset of another sequence.</summary>
            <remarks>
            Construct a subset of another sequence.
            The size of the subsequence will be
            <code>end - begin</code>
            .
            </remarks>
            <param name="base">the real sequence.</param>
            <param name="begin">
            First element index of
            <code>base</code>
            that will be part of this
            new subsequence. The element at
            <code>begin</code>
            will be this
            sequence's element 0.
            </param>
            <param name="end">
            One past the last element index of
            <code>base</code>
            that will be
            part of this new subsequence.
            </param>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Transport.WalkFetchConnection" -->
        <member name="F:NGit.Transport.WalkFetchConnection.local">
            <summary>The repository this transport fetches into, or pushes out of.</summary>
            <remarks>The repository this transport fetches into, or pushes out of.</remarks>
        </member>
        <member name="F:NGit.Transport.WalkFetchConnection.objCheck">
            <summary>If not null the validator for received objects.</summary>
            <remarks>If not null the validator for received objects.</remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "F:NGit.Transport.WalkFetchConnection.remotes" -->
        <member name="F:NGit.Transport.WalkFetchConnection.lastRemoteIdx">
            <summary>
            Most recently used item in
            <see cref="F:NGit.Transport.WalkFetchConnection.remotes">remotes</see>
            .
            </summary>
        </member>
        <member name="F:NGit.Transport.WalkFetchConnection.COMPLETE">
            <summary>Objects whose direct dependents we know we have (or will have).</summary>
            <remarks>Objects whose direct dependents we know we have (or will have).</remarks>
        </member>
        <member name="F:NGit.Transport.WalkFetchConnection.IN_WORK_QUEUE">
            <summary>
            Objects that have already entered
            <see cref="F:NGit.Transport.WalkFetchConnection.workQueue">workQueue</see>
            .
            </summary>
        </member>
        <member name="F:NGit.Transport.WalkFetchConnection.LOCALLY_SEEN">
            <summary>
            Commits that have already entered
            <see cref="F:NGit.Transport.WalkFetchConnection.localCommitQueue">localCommitQueue</see>
            .
            </summary>
        </member>
        <member name="F:NGit.Transport.WalkFetchConnection.localCommitQueue">
            <summary>Commits already reachable from all local refs.</summary>
            <remarks>Commits already reachable from all local refs.</remarks>
        </member>
        <member name="F:NGit.Transport.WalkFetchConnection.workQueue">
            <summary>Objects we need to copy from the remote repository.</summary>
            <remarks>Objects we need to copy from the remote repository.</remarks>
        </member>
        <member name="F:NGit.Transport.WalkFetchConnection.noPacksYet">
            <summary>Databases we have not yet obtained the list of packs from.</summary>
            <remarks>Databases we have not yet obtained the list of packs from.</remarks>
        </member>
        <member name="F:NGit.Transport.WalkFetchConnection.noAlternatesYet">
            <summary>Databases we have not yet obtained the alternates from.</summary>
            <remarks>Databases we have not yet obtained the alternates from.</remarks>
        </member>
        <member name="F:NGit.Transport.WalkFetchConnection.unfetchedPacks">
            <summary>Packs we have discovered, but have not yet fetched locally.</summary>
            <remarks>Packs we have discovered, but have not yet fetched locally.</remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "F:NGit.Transport.WalkFetchConnection.packsConsidered" -->
        <!-- Badly formed XML comment ignored for member "F:NGit.Transport.WalkFetchConnection.fetchErrors" -->
        <member name="F:NGit.Transport.WalkFetchConnection.inserter">
            <summary>
            Inserter to write objects onto
            <see cref="F:NGit.Transport.WalkFetchConnection.local">local</see>
            .
            </summary>
        </member>
        <member name="F:NGit.Transport.WalkFetchConnection.reader">
            <summary>
            Inserter to read objects from
            <see cref="F:NGit.Transport.WalkFetchConnection.local">local</see>
            .
            </summary>
        </member>
        <member name="M:NGit.Transport.WalkFetchConnection.DoFetch(NGit.ProgressMonitor,System.Collections.Generic.ICollection{NGit.Ref},System.Collections.Generic.ICollection{NGit.ObjectId})">
            <exception cref="T:NGit.Errors.TransportException"></exception>
        </member>
        <member name="M:NGit.Transport.WalkFetchConnection.QueueWants(System.Collections.Generic.ICollection{NGit.Ref})">
            <exception cref="T:NGit.Errors.TransportException"></exception>
        </member>
        <member name="M:NGit.Transport.WalkFetchConnection.Process(NGit.ObjectId)">
            <exception cref="T:NGit.Errors.TransportException"></exception>
        </member>
        <member name="M:NGit.Transport.WalkFetchConnection.ProcessBlob(NGit.Revwalk.RevObject)">
            <exception cref="T:NGit.Errors.TransportException"></exception>
        </member>
        <member name="M:NGit.Transport.WalkFetchConnection.ProcessTree(NGit.Revwalk.RevObject)">
            <exception cref="T:NGit.Errors.TransportException"></exception>
        </member>
        <member name="M:NGit.Transport.WalkFetchConnection.ProcessCommit(NGit.Revwalk.RevObject)">
            <exception cref="T:NGit.Errors.TransportException"></exception>
        </member>
        <member name="M:NGit.Transport.WalkFetchConnection.DownloadObject(NGit.ProgressMonitor,NGit.AnyObjectId)">
            <exception cref="T:NGit.Errors.TransportException"></exception>
        </member>
        <member name="M:NGit.Transport.WalkFetchConnection.AlreadyHave(NGit.AnyObjectId)">
            <exception cref="T:NGit.Errors.TransportException"></exception>
        </member>
        <member name="M:NGit.Transport.WalkFetchConnection.DownloadPackedObject(NGit.ProgressMonitor,NGit.AnyObjectId)">
            <exception cref="T:NGit.Errors.TransportException"></exception>
        </member>
        <member name="M:NGit.Transport.WalkFetchConnection.DownloadLooseObject(NGit.AnyObjectId,System.String,NGit.Transport.WalkRemoteObjectDatabase)">
            <exception cref="T:NGit.Errors.TransportException"></exception>
        </member>
        <member name="M:NGit.Transport.WalkFetchConnection.VerifyAndInsertLooseObject(NGit.AnyObjectId,System.Byte[])">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Transport.WalkFetchConnection.MarkLocalRefsComplete(System.Collections.Generic.ICollection{NGit.ObjectId})">
            <exception cref="T:NGit.Errors.TransportException"></exception>
        </member>
        <member name="M:NGit.Transport.WalkFetchConnection.MarkLocalObjComplete(NGit.Revwalk.RevObject)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Transport.WalkFetchConnection.MarkLocalCommitsComplete(System.Int32)">
            <exception cref="T:NGit.Errors.TransportException"></exception>
        </member>
        <member name="M:NGit.Transport.WalkFetchConnection.PushLocalCommit(NGit.Revwalk.RevCommit)">
            <exception cref="T:NGit.Errors.MissingObjectException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Transport.WalkFetchConnection.MarkTreeComplete(NGit.Revwalk.RevTree)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Transport.WalkFetchConnection.RemotePack.OpenIndex(NGit.ProgressMonitor)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Transport.WalkFetchConnection.RemotePack.DownloadPack(NGit.ProgressMonitor)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Transport.RefFilter" -->
        <member name="F:NGit.Transport.RefFilter.DEFAULT">
            <summary>The default filter, allows all refs to be shown.</summary>
            <remarks>The default filter, allows all refs to be shown.</remarks>
        </member>
        <member name="M:NGit.Transport.RefFilter.Filter(System.Collections.Generic.IDictionary{System.String,NGit.Ref})">
            <summary>
            Filters a
            <code>Map</code>
            of refs before it is advertised to the client.
            </summary>
            <param name="refs">the refs which this method need to consider.</param>
            <returns>the filtered map of refs.</returns>
        </member>
        <member name="T:NGit.Util.IO.TimeoutInputStream">
            <summary>InputStream with a configurable timeout.</summary>
            <remarks>InputStream with a configurable timeout.</remarks>
        </member>
        <member name="M:NGit.Util.IO.TimeoutInputStream.#ctor(Sharpen.InputStream,NGit.Util.IO.InterruptTimer)">
            <summary>Wrap an input stream with a timeout on all read operations.</summary>
            <remarks>Wrap an input stream with a timeout on all read operations.</remarks>
            <param name="src">
            base input stream (to read from). The stream must be
            interruptible (most socket streams are).
            </param>
            <param name="timer">timer to manage the timeouts during reads.</param>
        </member>
        <member name="M:NGit.Util.IO.TimeoutInputStream.GetTimeout">
            <returns>number of milliseconds before aborting a read.</returns>
        </member>
        <member name="M:NGit.Util.IO.TimeoutInputStream.SetTimeout(System.Int32)">
            <param name="millis">number of milliseconds before aborting a read. Must be &gt; 0.
            	</param>
        </member>
        <member name="M:NGit.Util.IO.TimeoutInputStream.Read">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Util.IO.TimeoutInputStream.Read(System.Byte[])">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Util.IO.TimeoutInputStream.Read(System.Byte[],System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Util.IO.TimeoutInputStream.Skip(System.Int64)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Util.RefMap" -->
        <!-- Badly formed XML comment ignored for member "F:NGit.Util.RefMap.prefix" -->
        <member name="F:NGit.Util.RefMap.packed">
            <summary>Immutable collection of the packed references at construction time.</summary>
            <remarks>Immutable collection of the packed references at construction time.</remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "F:NGit.Util.RefMap.loose" -->
        <!-- Badly formed XML comment ignored for member "F:NGit.Util.RefMap.resolved" -->
        <member name="M:NGit.Util.RefMap.#ctor">
            <summary>Construct an empty map with a small initial capacity.</summary>
            <remarks>Construct an empty map with a small initial capacity.</remarks>
        </member>
        <member name="M:NGit.Util.RefMap.#ctor(System.String,NGit.Util.RefList{NGit.Ref},NGit.Util.RefList{NGit.Ref},NGit.Util.RefList{NGit.Ref})">
            <summary>Construct a map to merge 3 collections together.</summary>
            <remarks>Construct a map to merge 3 collections together.</remarks>
            <param name="prefix">
            prefix used to slice the lists down. Only references whose
            names start with this prefix will appear to reside in the map.
            Must not be null, use
            <code>""</code>
            (the empty string) to select
            all list items.
            </param>
            <param name="packed">
            items from the packed reference list, this is the last list
            searched.
            </param>
            <param name="loose">
            items from the loose reference list, this list overrides
            <code>packed</code>
            if a name appears in both.
            </param>
            <param name="resolved">
            resolved symbolic references. This list overrides the prior
            list
            <code>loose</code>
            , if an item appears in both. Items in this
            list <b>must</b> also appear in
            <code>loose</code>
            .
            </param>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Util.RawCharSequence" -->
        <member name="F:NGit.Util.RawCharSequence.EMPTY">
            <summary>A zero-length character sequence.</summary>
            <remarks>A zero-length character sequence.</remarks>
        </member>
        <member name="M:NGit.Util.RawCharSequence.#ctor(System.Byte[],System.Int32,System.Int32)">
            <summary>Create a rough character sequence around the raw byte buffer.</summary>
            <remarks>Create a rough character sequence around the raw byte buffer.</remarks>
            <param name="buf">buffer to scan.</param>
            <param name="start">starting position for the sequence.</param>
            <param name="end">ending position for the sequence.</param>
        </member>
        <member name="T:NGit.Treewalk.Filter.NotIgnoredFilter">
            <summary>
            Skip
            <see cref="T:NGit.Treewalk.WorkingTreeIterator">NGit.Treewalk.WorkingTreeIterator</see>
            entries that appear in gitignore files.
            </summary>
        </member>
        <member name="M:NGit.Treewalk.Filter.NotIgnoredFilter.#ctor(System.Int32)">
            <summary>Construct a filter to ignore paths known to a particular iterator.</summary>
            <remarks>Construct a filter to ignore paths known to a particular iterator.</remarks>
            <param name="workdirTreeIndex">index of the workdir tree in the tree walk</param>
        </member>
        <member name="M:NGit.Treewalk.Filter.NotIgnoredFilter.Include(NGit.Treewalk.TreeWalk)">
            <exception cref="T:NGit.Errors.MissingObjectException"></exception>
            <exception cref="T:NGit.Errors.IncorrectObjectTypeException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Treewalk.FileTreeIterator" -->
        <!-- Badly formed XML comment ignored for member "T:NGit.Treewalk.WorkingTreeIterator" -->
        <member name="F:NGit.Treewalk.WorkingTreeIterator.BUFFER_SIZE">
            <summary>Size we perform file IO in if we have to read and hash a file.</summary>
            <remarks>Size we perform file IO in if we have to read and hash a file.</remarks>
        </member>
        <member name="F:NGit.Treewalk.WorkingTreeIterator.MAXIMUM_FILE_SIZE_TO_READ_FULLY">
            <summary>
            Maximum size of files which may be read fully into memory for performance
            reasons.
            </summary>
            <remarks>
            Maximum size of files which may be read fully into memory for performance
            reasons.
            </remarks>
        </member>
        <member name="F:NGit.Treewalk.WorkingTreeIterator.EOF">
            <summary>
            An empty entry array, suitable for
            <see cref="M:NGit.Treewalk.WorkingTreeIterator.Init(NGit.Treewalk.WorkingTreeIterator.Entry[])">Init(Entry[])</see>
            .
            </summary>
        </member>
        <member name="F:NGit.Treewalk.WorkingTreeIterator.state">
            <summary>Inherited state of this iterator, describing working tree, etc.</summary>
            <remarks>Inherited state of this iterator, describing working tree, etc.</remarks>
        </member>
        <member name="F:NGit.Treewalk.WorkingTreeIterator.contentId">
            <summary>
            The
            <see cref="P:NGit.Treewalk.WorkingTreeIterator.IdBuffer">IdBuffer()</see>
            for the current entry.
            </summary>
        </member>
        <member name="F:NGit.Treewalk.WorkingTreeIterator.contentIdFromPtr">
            <summary>
            Index within
            <see cref="F:NGit.Treewalk.WorkingTreeIterator.entries">entries</see>
            that
            <see cref="F:NGit.Treewalk.WorkingTreeIterator.contentId">contentId</see>
            came from.
            </summary>
        </member>
        <member name="F:NGit.Treewalk.WorkingTreeIterator.entries">
            <summary>List of entries obtained from the subclass.</summary>
            <remarks>List of entries obtained from the subclass.</remarks>
        </member>
        <member name="F:NGit.Treewalk.WorkingTreeIterator.entryCnt">
            <summary>
            Total number of entries in
            <see cref="F:NGit.Treewalk.WorkingTreeIterator.entries">entries</see>
            that are valid.
            </summary>
        </member>
        <member name="F:NGit.Treewalk.WorkingTreeIterator.ptr">
            <summary>
            Current position within
            <see cref="F:NGit.Treewalk.WorkingTreeIterator.entries">entries</see>
            .
            </summary>
        </member>
        <member name="F:NGit.Treewalk.WorkingTreeIterator.ignoreNode">
            <summary>If there is a .gitignore file present, the parsed rules from it.</summary>
            <remarks>If there is a .gitignore file present, the parsed rules from it.</remarks>
        </member>
        <member name="F:NGit.Treewalk.WorkingTreeIterator.repository">
            <summary>Repository that is the root level being iterated over</summary>
        </member>
        <member name="F:NGit.Treewalk.WorkingTreeIterator.canonLen">
            <summary>
            Cached canonical length, initialized from
            <see cref="P:NGit.Treewalk.WorkingTreeIterator.IdBuffer">IdBuffer()</see>
            
            </summary>
        </member>
        <member name="F:NGit.Treewalk.WorkingTreeIterator.ignoreStatus">
            <summary>Cached value of isEntryIgnored().</summary>
            <remarks>
            Cached value of isEntryIgnored(). 0 if not ignored, 1 if ignored, -1 if
            the value is not yet cached.
            </remarks>
        </member>
        <member name="M:NGit.Treewalk.WorkingTreeIterator.#ctor(NGit.Treewalk.WorkingTreeOptions)">
            <summary>Create a new iterator with no parent.</summary>
            <remarks>Create a new iterator with no parent.</remarks>
            <param name="options">working tree options to be used</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Treewalk.WorkingTreeIterator.#ctor(System.String,NGit.Treewalk.WorkingTreeOptions)" -->
        <member name="M:NGit.Treewalk.WorkingTreeIterator.#ctor(NGit.Treewalk.WorkingTreeIterator)">
            <summary>Create an iterator for a subtree of an existing iterator.</summary>
            <remarks>Create an iterator for a subtree of an existing iterator.</remarks>
            <param name="p">parent tree iterator.</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Treewalk.WorkingTreeIterator.InitRootIterator(NGit.Repository)" -->
        <member name="M:NGit.Treewalk.WorkingTreeIterator.SetDirCacheIterator(NGit.Treewalk.TreeWalk,System.Int32)">
            <summary>
            Define the matching
            <see cref="T:NGit.Dircache.DirCacheIterator">NGit.Dircache.DirCacheIterator</see>
            , to optimize ObjectIds.
            Once the DirCacheIterator has been set this iterator must only be
            advanced by the TreeWalk that is supplied, as it assumes that itself and
            the corresponding DirCacheIterator are positioned on the same file path
            whenever
            <see cref="P:NGit.Treewalk.WorkingTreeIterator.IdBuffer">IdBuffer()</see>
            is invoked.
            </summary>
            <param name="walk">the walk that will be advancing this iterator.</param>
            <param name="treeId">
            index of the matching
            <see cref="T:NGit.Dircache.DirCacheIterator">NGit.Dircache.DirCacheIterator</see>
            .
            </param>
        </member>
        <member name="M:NGit.Treewalk.WorkingTreeIterator.IdSubmodule(NGit.Treewalk.WorkingTreeIterator.Entry)">
            <summary>Get submodule id for given entry.</summary>
            <remarks>Get submodule id for given entry.</remarks>
            <param name="e"></param>
            <returns>non-null submodule id</returns>
        </member>
        <member name="M:NGit.Treewalk.WorkingTreeIterator.IdSubmodule(Sharpen.FilePath,NGit.Treewalk.WorkingTreeIterator.Entry)">
            <summary>
            Get submodule id using the repository at the location of the entry
            relative to the directory.
            </summary>
            <remarks>
            Get submodule id using the repository at the location of the entry
            relative to the directory.
            </remarks>
            <param name="directory"></param>
            <param name="e"></param>
            <returns>non-null submodule id</returns>
        </member>
        <member name="M:NGit.Treewalk.WorkingTreeIterator.PossiblyFilteredInputStream(NGit.Treewalk.WorkingTreeIterator.Entry,Sharpen.InputStream,System.Int64)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Treewalk.WorkingTreeIterator.IsBinary(NGit.Treewalk.WorkingTreeIterator.Entry)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Treewalk.WorkingTreeIterator.FilterClean(System.Byte[],System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Treewalk.WorkingTreeIterator.GetOptions">
            <summary>Returns the working tree options used by this iterator.</summary>
            <remarks>Returns the working tree options used by this iterator.</remarks>
            <returns>working tree options</returns>
        </member>
        <member name="M:NGit.Treewalk.WorkingTreeIterator.Next(System.Int32)">
            <exception cref="T:NGit.Errors.CorruptObjectException"></exception>
        </member>
        <member name="M:NGit.Treewalk.WorkingTreeIterator.Back(System.Int32)">
            <exception cref="T:NGit.Errors.CorruptObjectException"></exception>
        </member>
        <member name="M:NGit.Treewalk.WorkingTreeIterator.GetEntryLength">
            <summary>Get the raw byte length of this entry.</summary>
            <remarks>Get the raw byte length of this entry.</remarks>
            <returns>size of this file, in bytes.</returns>
        </member>
        <member name="M:NGit.Treewalk.WorkingTreeIterator.GetEntryContentLength">
            <summary>Get the filtered input length of this entry</summary>
            <returns>size of the content, in bytes</returns>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:NGit.Treewalk.WorkingTreeIterator.GetEntryLastModified">
            <summary>Get the last modified time of this entry.</summary>
            <remarks>Get the last modified time of this entry.</remarks>
            <returns>
            last modified time of this file, in milliseconds since the epoch
            (Jan 1, 1970 UTC).
            </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Treewalk.WorkingTreeIterator.OpenEntryStream" -->
        <member name="M:NGit.Treewalk.WorkingTreeIterator.IsEntryIgnored">
            <summary>Determine if the current entry path is ignored by an ignore rule.</summary>
            <remarks>Determine if the current entry path is ignored by an ignore rule.</remarks>
            <returns>true if the entry was ignored by an ignore rule file.</returns>
            <exception cref="T:System.IO.IOException">a relevant ignore rule file exists but cannot be read.
            	</exception>
        </member>
        <member name="M:NGit.Treewalk.WorkingTreeIterator.IsEntryIgnored(System.Int32)">
            <summary>Determine if the entry path is ignored by an ignore rule.</summary>
            <remarks>Determine if the entry path is ignored by an ignore rule.</remarks>
            <param name="pLen">the length of the path in the path buffer.</param>
            <returns>true if the entry is ignored by an ignore rule.</returns>
            <exception cref="T:System.IO.IOException">a relevant ignore rule file exists but cannot be read.
            	</exception>
        </member>
        <member name="M:NGit.Treewalk.WorkingTreeIterator.GetIgnoreNode">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Treewalk.WorkingTreeIterator.Init(NGit.Treewalk.WorkingTreeIterator.Entry[])">
            <summary>Constructor helper.</summary>
            <remarks>Constructor helper.</remarks>
            <param name="list">
            files in the subtree of the work tree this iterator operates
            on
            </param>
        </member>
        <member name="M:NGit.Treewalk.WorkingTreeIterator.Current">
            <summary>Obtain the current entry from this iterator.</summary>
            <remarks>Obtain the current entry from this iterator.</remarks>
            <returns>the currently selected entry.</returns>
        </member>
        <member name="M:NGit.Treewalk.WorkingTreeIterator.IsModeDifferent(System.Int32)">
            <summary>Is the file mode of the current entry different than the given raw mode?
            	</summary>
            <param name="rawMode"></param>
            <returns>true if different, false otherwise</returns>
        </member>
        <member name="M:NGit.Treewalk.WorkingTreeIterator.CompareMetadata(NGit.Dircache.DirCacheEntry)">
            <summary>
            Compare the metadata (mode, length, modification-timestamp) of the
            current entry and a
            <see cref="T:NGit.Dircache.DirCacheEntry">NGit.Dircache.DirCacheEntry</see>
            </summary>
            <param name="entry">
            the
            <see cref="T:NGit.Dircache.DirCacheEntry">NGit.Dircache.DirCacheEntry</see>
            to compare with
            </param>
            <returns>
            a
            <see cref="T:NGit.Treewalk.WorkingTreeIterator.MetadataDiff">MetadataDiff</see>
            which tells whether and how the entries
            metadata differ
            </returns>
        </member>
        <member name="M:NGit.Treewalk.WorkingTreeIterator.IsModified(NGit.Dircache.DirCacheEntry,System.Boolean)">
            <summary>
            Checks whether this entry differs from a given entry from the
            <see cref="T:NGit.Dircache.DirCache">NGit.Dircache.DirCache</see>
            .
            File status information is used and if status is same we consider the
            file identical to the state in the working directory. Native git uses
            more stat fields than we have accessible in Java.
            </summary>
            <param name="entry">the entry from the dircache we want to compare against</param>
            <param name="forceContentCheck">
            True if the actual file content should be checked if
            modification time differs.
            </param>
            <returns>true if content is most likely different.</returns>
        </member>
        <member name="M:NGit.Treewalk.WorkingTreeIterator.GetIndexFileMode(NGit.Dircache.DirCacheIterator)">
            <summary>
            Get the file mode to use for the current entry when it is to be updated
            in the index.
            </summary>
            <remarks>
            Get the file mode to use for the current entry when it is to be updated
            in the index.
            </remarks>
            <param name="indexIter">
            <see cref="T:NGit.Dircache.DirCacheIterator">NGit.Dircache.DirCacheIterator</see>
            positioned at the same entry as this
            iterator or null if no
            <see cref="T:NGit.Dircache.DirCacheIterator">NGit.Dircache.DirCacheIterator</see>
            is available
            at this iterator's current entry
            </param>
            <returns>index file mode</returns>
        </member>
        <member name="M:NGit.Treewalk.WorkingTreeIterator.ContentCheck(NGit.Dircache.DirCacheEntry)">
            <summary>Compares the entries content with the content in the filesystem.</summary>
            <remarks>
            Compares the entries content with the content in the filesystem.
            Unsmudges the entry when it is detected that it is clean.
            </remarks>
            <param name="entry">the entry to be checked</param>
            <returns>
            <code>true</code> if the content matches, <code>false</code>
            otherwise
            </returns>
        </member>
        <member name="M:NGit.Treewalk.WorkingTreeIterator.ComputeLength(Sharpen.InputStream)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Treewalk.WorkingTreeIterator.ComputeHash(Sharpen.InputStream,System.Int64)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="T:NGit.Treewalk.WorkingTreeIterator.MetadataDiff">
            <summary>
            The result of a metadata-comparison between the current entry and a
            <see cref="T:NGit.Dircache.DirCacheEntry">DirCacheEntry</see>
            </summary>
        </member>
        <member name="T:NGit.Treewalk.WorkingTreeIterator.Entry">
            <summary>A single entry within a working directory tree.</summary>
            <remarks>A single entry within a working directory tree.</remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Treewalk.WorkingTreeIterator.Entry.GetMode" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Treewalk.WorkingTreeIterator.Entry.GetLength" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Treewalk.WorkingTreeIterator.Entry.GetLastModified" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Treewalk.WorkingTreeIterator.Entry.GetName" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Treewalk.WorkingTreeIterator.Entry.OpenInputStream" -->
        <member name="T:NGit.Treewalk.WorkingTreeIterator.PerDirectoryIgnoreNode">
            <summary>Magic type indicating we know rules exist, but they aren't loaded.</summary>
            <remarks>Magic type indicating we know rules exist, but they aren't loaded.</remarks>
        </member>
        <member name="T:NGit.Ignore.IgnoreNode">
            <summary>Represents a bundle of ignore rules inherited from a base directory.</summary>
            <remarks>
            Represents a bundle of ignore rules inherited from a base directory.
            This class is not thread safe, it maintains state about the last match.
            </remarks>
        </member>
        <member name="F:NGit.Ignore.IgnoreNode.rules">
            <summary>The rules that have been parsed into this node.</summary>
            <remarks>The rules that have been parsed into this node.</remarks>
        </member>
        <member name="M:NGit.Ignore.IgnoreNode.#ctor">
            <summary>Create an empty ignore node with no rules.</summary>
            <remarks>Create an empty ignore node with no rules.</remarks>
        </member>
        <member name="M:NGit.Ignore.IgnoreNode.#ctor(System.Collections.Generic.IList{NGit.Ignore.IgnoreRule})">
            <summary>Create an ignore node with given rules.</summary>
            <remarks>Create an ignore node with given rules.</remarks>
            <param name="rules">list of rules.</param>
        </member>
        <member name="M:NGit.Ignore.IgnoreNode.Parse(Sharpen.InputStream)">
            <summary>Parse files according to gitignore standards.</summary>
            <remarks>Parse files according to gitignore standards.</remarks>
            <param name="in">
            input stream holding the standard ignore format. The caller is
            responsible for closing the stream.
            </param>
            <exception cref="T:System.IO.IOException">Error thrown when reading an ignore file.
            	</exception>
        </member>
        <member name="M:NGit.Ignore.IgnoreNode.GetRules">
            <returns>list of all ignore rules held by this node.</returns>
        </member>
        <member name="M:NGit.Ignore.IgnoreNode.IsIgnored(System.String,System.Boolean)">
            <summary>Determine if an entry path matches an ignore rule.</summary>
            <remarks>Determine if an entry path matches an ignore rule.</remarks>
            <param name="entryPath">
            the path to test. The path must be relative to this ignore
            node's own repository path, and in repository path format
            (uses '/' and not '\').
            </param>
            <param name="isDirectory">true if the target item is a directory.</param>
            <returns>status of the path.</returns>
        </member>
        <member name="T:NGit.Ignore.IgnoreNode.MatchResult">
            <summary>
            Result from
            <see cref="M:NGit.Ignore.IgnoreNode.IsIgnored(System.String,System.Boolean)">IsIgnored(string, bool)</see>
            .
            </summary>
        </member>
        <member name="M:NGit.Treewalk.WorkingTreeIterator.PerDirectoryIgnoreNode.Load">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="T:NGit.Treewalk.WorkingTreeIterator.RootIgnoreNode">
            <summary>Magic type indicating there may be rules for the top level.</summary>
            <remarks>Magic type indicating there may be rules for the top level.</remarks>
        </member>
        <member name="M:NGit.Treewalk.WorkingTreeIterator.RootIgnoreNode.Load">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Treewalk.WorkingTreeIterator.RootIgnoreNode.LoadRulesFromFile(NGit.Ignore.IgnoreNode,Sharpen.FilePath)">
            <exception cref="T:System.IO.FileNotFoundException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="F:NGit.Treewalk.WorkingTreeIterator.IteratorState.options">
            <summary>Options used to process the working tree.</summary>
            <remarks>Options used to process the working tree.</remarks>
        </member>
        <member name="F:NGit.Treewalk.WorkingTreeIterator.IteratorState.nameEncoder">
            <summary>File name character encoder.</summary>
            <remarks>File name character encoder.</remarks>
        </member>
        <member name="F:NGit.Treewalk.WorkingTreeIterator.IteratorState.contentDigest">
            <summary>
            Digest computer for
            <see cref="F:NGit.Treewalk.WorkingTreeIterator.contentId">WorkingTreeIterator.contentId</see>
            computations.
            </summary>
        </member>
        <member name="F:NGit.Treewalk.WorkingTreeIterator.IteratorState.contentReadBuffer">
            <summary>
            Buffer used to perform
            <see cref="F:NGit.Treewalk.WorkingTreeIterator.contentId">WorkingTreeIterator.contentId</see>
            computations.
            </summary>
        </member>
        <member name="F:NGit.Treewalk.WorkingTreeIterator.IteratorState.walk">
            <summary>TreeWalk with a (supposedly) matching DirCacheIterator.</summary>
            <remarks>TreeWalk with a (supposedly) matching DirCacheIterator.</remarks>
        </member>
        <member name="F:NGit.Treewalk.WorkingTreeIterator.IteratorState.dirCacheTree">
            <summary>
            Position of the matching
            <see cref="T:NGit.Dircache.DirCacheIterator">NGit.Dircache.DirCacheIterator</see>
            .
            </summary>
        </member>
        <member name="F:NGit.Treewalk.FileTreeIterator.directory">
            <summary>the starting directory.</summary>
            <remarks>
            the starting directory. This directory should correspond to the root of
            the repository.
            </remarks>
        </member>
        <member name="F:NGit.Treewalk.FileTreeIterator.fs">
            <summary>
            the file system abstraction which will be necessary to perform certain
            file system operations.
            </summary>
            <remarks>
            the file system abstraction which will be necessary to perform certain
            file system operations.
            </remarks>
        </member>
        <member name="M:NGit.Treewalk.FileTreeIterator.#ctor(NGit.Repository)">
            <summary>Create a new iterator to traverse the work tree and its children.</summary>
            <remarks>Create a new iterator to traverse the work tree and its children.</remarks>
            <param name="repo">the repository whose working tree will be scanned.</param>
        </member>
        <member name="M:NGit.Treewalk.FileTreeIterator.#ctor(Sharpen.FilePath,NGit.Util.FS,NGit.Treewalk.WorkingTreeOptions)">
            <summary>Create a new iterator to traverse the given directory and its children.</summary>
            <remarks>Create a new iterator to traverse the given directory and its children.</remarks>
            <param name="root">
            the starting directory. This directory should correspond to
            the root of the repository.
            </param>
            <param name="fs">
            the file system abstraction which will be necessary to perform
            certain file system operations.
            </param>
            <param name="options">working tree options to be used</param>
        </member>
        <member name="M:NGit.Treewalk.FileTreeIterator.#ctor(NGit.Treewalk.FileTreeIterator,Sharpen.FilePath,NGit.Util.FS)">
            <summary>Create a new iterator to traverse a subdirectory.</summary>
            <remarks>Create a new iterator to traverse a subdirectory.</remarks>
            <param name="p">the parent iterator we were created from.</param>
            <param name="fs">
            the file system abstraction which will be necessary to perform
            certain file system operations.
            </param>
            <param name="root">
            the subdirectory. This should be a directory contained within
            the parent directory.
            </param>
        </member>
        <member name="M:NGit.Treewalk.FileTreeIterator.CreateSubtreeIterator(NGit.ObjectReader)">
            <exception cref="T:NGit.Errors.IncorrectObjectTypeException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Treewalk.FileTreeIterator.GetDirectory">
            <returns>The root directory of this iterator</returns>
        </member>
        <member name="M:NGit.Treewalk.FileTreeIterator.GetEntryFile">
            <returns>
            The location of the working file. This is the same as
            <code>
            new
            File(getDirectory(), getEntryPath())
            </code>
            but may be faster by
            reusing an internal File instance.
            </returns>
        </member>
        <member name="T:NGit.Treewalk.FileTreeIterator.FileEntry">
            <summary>Wrapper for a standard Java IO file</summary>
        </member>
        <member name="M:NGit.Treewalk.FileTreeIterator.FileEntry.OpenInputStream">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Treewalk.FileTreeIterator.FileEntry.GetFile">
            <summary>Get the underlying file of this entry.</summary>
            <remarks>Get the underlying file of this entry.</remarks>
            <returns>the underlying file of this entry</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Revwalk.RevFlag" -->
        <!-- Badly formed XML comment ignored for member "F:NGit.Revwalk.RevFlag.UNINTERESTING" -->
        <member name="M:NGit.Revwalk.RevFlag.GetRevWalk">
            <summary>Get the revision walk instance this flag was created from.</summary>
            <remarks>Get the revision walk instance this flag was created from.</remarks>
            <returns>the walker this flag was allocated out of, and belongs to.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Revwalk.FooterLine" -->
        <member name="M:NGit.Revwalk.FooterLine.Matches(NGit.Revwalk.FooterKey)">
            <param name="key">key to test this line's key name against.</param>
            <returns>
            true if
            <code>key.getName().equalsIgnorecase(getKey())</code>
            .
            </returns>
        </member>
        <member name="M:NGit.Revwalk.FooterLine.GetKey">
            <returns>
            key name of this footer; that is the text before the ":" on the
            line footer's line. The text is decoded according to the commit's
            specified (or assumed) character encoding.
            </returns>
        </member>
        <member name="M:NGit.Revwalk.FooterLine.GetValue">
            <returns>
            value of this footer; that is the text after the ":" and any
            leading whitespace has been skipped. May be the empty string if
            the footer has no value (line ended with ":"). The text is
            decoded according to the commit's specified (or assumed)
            character encoding.
            </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Revwalk.FooterLine.GetEmailAddress" -->
        <!-- Badly formed XML comment ignored for member "T:NGit.Patch.CombinedFileHeader" -->
        <member name="M:NGit.Patch.CombinedFileHeader.GetParentCount">
            <returns>number of ancestor revisions mentioned in this diff.</returns>
        </member>
        <member name="M:NGit.Patch.CombinedFileHeader.GetOldMode">
            <returns>get the file mode of the first parent.</returns>
        </member>
        <member name="M:NGit.Patch.CombinedFileHeader.GetOldMode(System.Int32)">
            <summary>Get the file mode of the nth ancestor</summary>
            <param name="nthParent">the ancestor to get the mode of</param>
            <returns>the mode of the requested ancestor.</returns>
        </member>
        <member name="M:NGit.Patch.CombinedFileHeader.GetOldId">
            <returns>get the object id of the first parent.</returns>
        </member>
        <member name="M:NGit.Patch.CombinedFileHeader.GetOldId(System.Int32)">
            <summary>Get the ObjectId of the nth ancestor</summary>
            <param name="nthParent">the ancestor to get the object id of</param>
            <returns>the id of the requested ancestor.</returns>
        </member>
        <member name="M:NGit.Patch.CombinedFileHeader.GetScriptText(System.Text.Encoding[])">
            <summary>Convert the patch script for this file into a string.</summary>
            <remarks>Convert the patch script for this file into a string.</remarks>
            <param name="charsetGuess">
            optional array to suggest the character set to use when
            decoding each file's line. If supplied the array must have a
            length of <code>
            <see cref="M:NGit.Patch.CombinedFileHeader.GetParentCount">GetParentCount()</see>
            + 1</code>
            representing the old revision character sets and the new
            revision character set.
            </param>
            <returns>the patch script, as a Unicode string.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Nls.TranslationBundle" -->
        <member name="M:NGit.Nls.TranslationBundle.EffectiveLocale">
            <returns>
            the locale locale used for loading the resource bundle from which
            the field values were taken
            </returns>
        </member>
        <member name="M:NGit.Nls.TranslationBundle.ResourceBundle">
            <returns>the resource bundle on which this translation bundle is based</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Nls.TranslationBundle.Load(System.Globalization.CultureInfo)" -->
        <member name="T:NGit.Events.ListenerList">
            <summary>
            Manages a thread-safe list of
            <see cref="T:NGit.Events.RepositoryListener">RepositoryListener</see>
            s.
            </summary>
        </member>
        <member name="M:NGit.Events.ListenerList.AddIndexChangedListener(NGit.Events.IndexChangedListener)">
            <summary>Register an IndexChangedListener.</summary>
            <remarks>Register an IndexChangedListener.</remarks>
            <param name="listener">the listener implementation.</param>
            <returns>handle to later remove the listener.</returns>
        </member>
        <member name="M:NGit.Events.ListenerList.AddRefsChangedListener(NGit.Events.RefsChangedListener)">
            <summary>Register a RefsChangedListener.</summary>
            <remarks>Register a RefsChangedListener.</remarks>
            <param name="listener">the listener implementation.</param>
            <returns>handle to later remove the listener.</returns>
        </member>
        <member name="M:NGit.Events.ListenerList.AddConfigChangedListener(NGit.Events.ConfigChangedListener)">
            <summary>Register a ConfigChangedListener.</summary>
            <remarks>Register a ConfigChangedListener.</remarks>
            <param name="listener">the listener implementation.</param>
            <returns>handle to later remove the listener.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Events.ListenerList.AddListener``1(``0)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Events.ListenerList.Dispatch(NGit.Events.RepositoryEvent)" -->
        <!-- Badly formed XML comment ignored for member "T:NGit.Dircache.DirCacheTree" -->
        <member name="F:NGit.Dircache.DirCacheTree.parent">
            <summary>Tree this tree resides in; null if we are the root.</summary>
            <remarks>Tree this tree resides in; null if we are the root.</remarks>
        </member>
        <member name="F:NGit.Dircache.DirCacheTree.encodedName">
            <summary>Name of this tree within its parent.</summary>
            <remarks>Name of this tree within its parent.</remarks>
        </member>
        <member name="F:NGit.Dircache.DirCacheTree.entrySpan">
            <summary>
            Number of
            <see cref="T:NGit.Dircache.DirCacheEntry">DirCacheEntry</see>
            records that belong to this tree.
            </summary>
        </member>
        <member name="F:NGit.Dircache.DirCacheTree.id">
            <summary>Unique SHA-1 of this tree; null if invalid.</summary>
            <remarks>Unique SHA-1 of this tree; null if invalid.</remarks>
        </member>
        <member name="F:NGit.Dircache.DirCacheTree.children">
            <summary>
            Child trees, if any, sorted by
            <see cref="F:NGit.Dircache.DirCacheTree.encodedName">encodedName</see>
            .
            </summary>
        </member>
        <member name="F:NGit.Dircache.DirCacheTree.childCnt">
            <summary>
            Number of valid children in
            <see cref="F:NGit.Dircache.DirCacheTree.children">children</see>
            .
            </summary>
        </member>
        <member name="M:NGit.Dircache.DirCacheTree.Write(System.Byte[],Sharpen.OutputStream)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Dircache.DirCacheTree.IsValid" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Dircache.DirCacheTree.GetEntrySpan" -->
        <member name="M:NGit.Dircache.DirCacheTree.GetChildCount">
            <summary>Get the number of cached subtrees contained within this tree.</summary>
            <remarks>Get the number of cached subtrees contained within this tree.</remarks>
            <returns>number of child trees available through this tree.</returns>
        </member>
        <member name="M:NGit.Dircache.DirCacheTree.GetChild(System.Int32)">
            <summary>Get the i-th child cache tree.</summary>
            <remarks>Get the i-th child cache tree.</remarks>
            <param name="i">index of the child to obtain.</param>
            <returns>the child tree.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Dircache.DirCacheTree.GetNameString" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Dircache.DirCacheTree.GetPathString" -->
        <member name="M:NGit.Dircache.DirCacheTree.WriteTree(NGit.Dircache.DirCacheEntry[],System.Int32,System.Int32,NGit.ObjectInserter)">
            <summary>Write (if necessary) this tree to the object store.</summary>
            <remarks>Write (if necessary) this tree to the object store.</remarks>
            <param name="cache">the complete cache from DirCache.</param>
            <param name="cIdx">
            first position of <code>cache</code> that is a member of this
            tree. The path of <code>cache[cacheIdx].path</code> for the
            range <code>[0,pathOff-1)</code> matches the complete path of
            this tree, from the root of the repository.
            </param>
            <param name="pathOffset">
            number of bytes of <code>cache[cacheIdx].path</code> that
            matches this tree's path. The value at array position
            <code>cache[cacheIdx].path[pathOff-1]</code> is always '/' if
            <code>pathOff</code> is &gt; 0.
            </param>
            <param name="ow">the writer to use when serializing to the store.</param>
            <returns>identity of this tree.</returns>
            <exception cref="T:NGit.Errors.UnmergedPathException">
            one or more paths contain higher-order stages (stage &gt; 0),
            which cannot be stored in a tree object.
            </exception>
            <exception cref="T:System.IO.IOException">an unexpected error occurred writing to the object store.
            	</exception>
        </member>
        <member name="M:NGit.Dircache.DirCacheTree.ComputeSize(NGit.Dircache.DirCacheEntry[],System.Int32,System.Int32,NGit.ObjectInserter)">
            <exception cref="T:NGit.Errors.UnmergedPathException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Dircache.DirCacheTree.Validate(NGit.Dircache.DirCacheEntry[],System.Int32,System.Int32,System.Int32)">
            <summary>Update (if necessary) this tree's entrySpan.</summary>
            <remarks>Update (if necessary) this tree's entrySpan.</remarks>
            <param name="cache">the complete cache from DirCache.</param>
            <param name="cCnt">
            number of entries in <code>cache</code> that are valid for
            iteration.
            </param>
            <param name="cIdx">
            first position of <code>cache</code> that is a member of this
            tree. The path of <code>cache[cacheIdx].path</code> for the
            range <code>[0,pathOff-1)</code> matches the complete path of
            this tree, from the root of the repository.
            </param>
            <param name="pathOff">
            number of bytes of <code>cache[cacheIdx].path</code> that
            matches this tree's path. The value at array position
            <code>cache[cacheIdx].path[pathOff-1]</code> is always '/' if
            <code>pathOff</code> is &gt; 0.
            </param>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Dircache.DirCacheIterator" -->
        <member name="F:NGit.Dircache.DirCacheIterator.cache">
            <summary>The cache this iterator was created to walk.</summary>
            <remarks>The cache this iterator was created to walk.</remarks>
        </member>
        <member name="F:NGit.Dircache.DirCacheIterator.tree">
            <summary>The tree this iterator is walking.</summary>
            <remarks>The tree this iterator is walking.</remarks>
        </member>
        <member name="F:NGit.Dircache.DirCacheIterator.treeStart">
            <summary>First position in this tree.</summary>
            <remarks>First position in this tree.</remarks>
        </member>
        <member name="F:NGit.Dircache.DirCacheIterator.treeEnd">
            <summary>Last position in this tree.</summary>
            <remarks>Last position in this tree.</remarks>
        </member>
        <member name="F:NGit.Dircache.DirCacheIterator.subtreeId">
            <summary>
            Special buffer to hold the ObjectId of
            <see cref="F:NGit.Dircache.DirCacheIterator.currentSubtree">currentSubtree</see>
            .
            </summary>
        </member>
        <member name="F:NGit.Dircache.DirCacheIterator.ptr">
            <summary>
            Index of entry within
            <see cref="F:NGit.Dircache.DirCacheIterator.cache">cache</see>
            .
            </summary>
        </member>
        <member name="F:NGit.Dircache.DirCacheIterator.nextSubtreePos">
            <summary>
            Next subtree to consider within
            <see cref="F:NGit.Dircache.DirCacheIterator.tree">tree</see>
            .
            </summary>
        </member>
        <member name="F:NGit.Dircache.DirCacheIterator.currentEntry">
            <summary>
            The current file entry from
            <see cref="F:NGit.Dircache.DirCacheIterator.cache">cache</see>
            .
            </summary>
        </member>
        <member name="F:NGit.Dircache.DirCacheIterator.currentSubtree">
            <summary>
            The subtree containing
            <see cref="F:NGit.Dircache.DirCacheIterator.currentEntry">currentEntry</see>
            if this is first entry.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Dircache.DirCacheIterator.#ctor(NGit.Dircache.DirCache)" -->
        <member name="M:NGit.Dircache.DirCacheIterator.CreateSubtreeIterator(NGit.ObjectReader)">
            <exception cref="T:NGit.Errors.IncorrectObjectTypeException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Dircache.DirCacheIterator.GetDirCacheEntry">
            <summary>Get the DirCacheEntry for the current file.</summary>
            <remarks>Get the DirCacheEntry for the current file.</remarks>
            <returns>
            the current cache entry, if this iterator is positioned on a
            non-tree.
            </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Dircache.DirCacheBuildIterator" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Dircache.DirCacheBuildIterator.#ctor(NGit.Dircache.DirCacheBuilder)" -->
        <member name="M:NGit.Dircache.DirCacheBuildIterator.CreateSubtreeIterator(NGit.ObjectReader)">
            <exception cref="T:NGit.Errors.IncorrectObjectTypeException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Dircache.DirCacheBuildIterator.Skip">
            <exception cref="T:NGit.Errors.CorruptObjectException"></exception>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Dircache.DirCache" -->
        <member name="M:NGit.Dircache.DirCache.NewInCore">
            <summary>Create a new empty index which is never stored on disk.</summary>
            <remarks>Create a new empty index which is never stored on disk.</remarks>
            <returns>
            an empty cache which has no backing store file. The cache may not
            be read or written, but it may be queried and updated (in
            memory).
            </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Dircache.DirCache.Read(NGit.Repository)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Dircache.DirCache.Read(Sharpen.FilePath,NGit.Util.FS)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Dircache.DirCache.Lock(Sharpen.FilePath,NGit.Util.FS)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Dircache.DirCache.Lock(NGit.Repository,NGit.Events.IndexChangedListener)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Dircache.DirCache.Lock(Sharpen.FilePath,NGit.Util.FS,NGit.Events.IndexChangedListener)" -->
        <member name="F:NGit.Dircache.DirCache.liveFile">
            <summary>Location of the current version of the index file.</summary>
            <remarks>Location of the current version of the index file.</remarks>
        </member>
        <member name="F:NGit.Dircache.DirCache.sortedEntries">
            <summary>Individual file index entries, sorted by path name.</summary>
            <remarks>Individual file index entries, sorted by path name.</remarks>
        </member>
        <member name="F:NGit.Dircache.DirCache.entryCnt">
            <summary>
            Number of positions within
            <see cref="F:NGit.Dircache.DirCache.sortedEntries">sortedEntries</see>
            that are valid.
            </summary>
        </member>
        <member name="F:NGit.Dircache.DirCache.tree">
            <summary>Cache tree for this index; null if the cache tree is not available.</summary>
            <remarks>Cache tree for this index; null if the cache tree is not available.</remarks>
        </member>
        <member name="F:NGit.Dircache.DirCache.myLock">
            <summary>Our active lock (if we hold it); null if we don't have it locked.</summary>
            <remarks>Our active lock (if we hold it); null if we don't have it locked.</remarks>
        </member>
        <member name="F:NGit.Dircache.DirCache.fs">
            <summary>file system abstraction</summary>
        </member>
        <member name="F:NGit.Dircache.DirCache.snapshot">
            <summary>Keep track of whether the index has changed or not</summary>
        </member>
        <member name="F:NGit.Dircache.DirCache.readIndexChecksum">
            <summary>index checksum when index was read from disk</summary>
        </member>
        <member name="F:NGit.Dircache.DirCache.writeIndexChecksum">
            <summary>index checksum when index was written to disk</summary>
        </member>
        <member name="F:NGit.Dircache.DirCache.indexChangedListener">
            <summary>listener to be informed on commit</summary>
        </member>
        <member name="F:NGit.Dircache.DirCache.repository">
            <summary>Repository containing this index</summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Dircache.DirCache.#ctor(Sharpen.FilePath,NGit.Util.FS)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Dircache.DirCache.Builder" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Dircache.DirCache.Editor" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Dircache.DirCache.Read" -->
        <member name="M:NGit.Dircache.DirCache.IsOutdated">
            <returns>true if the memory state differs from the index file</returns>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:NGit.Dircache.DirCache.Clear">
            <summary>Empty this index, removing all entries.</summary>
            <remarks>Empty this index, removing all entries.</remarks>
        </member>
        <member name="M:NGit.Dircache.DirCache.ReadFrom(Sharpen.InputStream)">
            <exception cref="T:System.IO.IOException"></exception>
            <exception cref="T:NGit.Errors.CorruptObjectException"></exception>
        </member>
        <member name="M:NGit.Dircache.DirCache.SkipOptionalExtension(Sharpen.InputStream,Sharpen.MessageDigest,System.Byte[],System.Int64)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Dircache.DirCache.FormatExtensionName(System.Byte[])">
            <exception cref="T:Sharpen.UnsupportedEncodingException"></exception>
        </member>
        <member name="M:NGit.Dircache.DirCache.Lock">
            <summary>Try to establish an update lock on the cache file.</summary>
            <remarks>Try to establish an update lock on the cache file.</remarks>
            <returns>
            true if the lock is now held by the caller; false if it is held
            by someone else.
            </returns>
            <exception cref="T:System.IO.IOException">
            the output file could not be created. The caller does not
            hold the lock.
            </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Dircache.DirCache.Write" -->
        <member name="M:NGit.Dircache.DirCache.WriteTo(Sharpen.OutputStream)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Dircache.DirCache.Commit" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Dircache.DirCache.Unlock" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Dircache.DirCache.FindEntry(System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Dircache.DirCache.NextEntry(System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Dircache.DirCache.GetEntryCount" -->
        <member name="M:NGit.Dircache.DirCache.GetEntry(System.Int32)">
            <summary>Get a specific entry.</summary>
            <remarks>Get a specific entry.</remarks>
            <param name="i">position of the entry to get.</param>
            <returns>the entry at position <code>i</code>.</returns>
        </member>
        <member name="M:NGit.Dircache.DirCache.GetEntry(System.String)">
            <summary>Get a specific entry.</summary>
            <remarks>Get a specific entry.</remarks>
            <param name="path">the path to search for.</param>
            <returns>the entry for the given <code>path</code>.</returns>
        </member>
        <member name="M:NGit.Dircache.DirCache.GetEntriesWithin(System.String)">
            <summary>Recursively get all entries within a subtree.</summary>
            <remarks>Recursively get all entries within a subtree.</remarks>
            <param name="path">the subtree path to get all entries within.</param>
            <returns>all entries recursively contained within the subtree.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Dircache.DirCache.GetCacheTree(System.Boolean)" -->
        <member name="M:NGit.Dircache.DirCache.WriteTree(NGit.ObjectInserter)">
            <summary>Write all index trees to the object store, returning the root tree.</summary>
            <remarks>Write all index trees to the object store, returning the root tree.</remarks>
            <param name="ow">
            the writer to use when serializing to the store. The caller is
            responsible for flushing the inserter before trying to use the
            returned tree identity.
            </param>
            <returns>identity for the root tree.</returns>
            <exception cref="T:NGit.Errors.UnmergedPathException">
            one or more paths contain higher-order stages (stage &gt; 0),
            which cannot be stored in a tree object.
            </exception>
            <exception cref="T:System.InvalidOperationException">
            one or more paths contain an invalid mode which should never
            appear in a tree object.
            </exception>
            <exception cref="T:System.IO.IOException">an unexpected error occurred writing to the object store.
            	</exception>
        </member>
        <member name="M:NGit.Dircache.DirCache.HasUnmergedPaths">
            <summary>Tells whether this index contains unmerged paths.</summary>
            <remarks>Tells whether this index contains unmerged paths.</remarks>
            <returns>
            
            <code>true</code>
            if this index contains unmerged paths. Means: at
            least one entry is of a stage different from 0.
            <code>false</code>
            will be returned if all entries are of stage 0.
            </returns>
        </member>
        <member name="M:NGit.Dircache.DirCache.UpdateSmudgedEntries">
            <summary>Update any smudged entries with information from the working tree.</summary>
            <remarks>Update any smudged entries with information from the working tree.</remarks>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="T:NGit.Diff.RenameDetector">
            <summary>Detect and resolve object renames.</summary>
            <remarks>Detect and resolve object renames.</remarks>
        </member>
        <member name="F:NGit.Diff.RenameDetector.renameScore">
            <summary>Similarity score required to pair an add/delete as a rename.</summary>
            <remarks>Similarity score required to pair an add/delete as a rename.</remarks>
        </member>
        <member name="F:NGit.Diff.RenameDetector.breakScore">
            <summary>Similarity score required to keep modified file pairs together.</summary>
            <remarks>
            Similarity score required to keep modified file pairs together. Any
            modified file pairs with a similarity score below this will be broken
            apart.
            </remarks>
        </member>
        <member name="F:NGit.Diff.RenameDetector.renameLimit">
            <summary>Limit in the number of files to consider for renames.</summary>
            <remarks>Limit in the number of files to consider for renames.</remarks>
        </member>
        <member name="F:NGit.Diff.RenameDetector.overRenameLimit">
            <summary>Set if the number of adds or deletes was over the limit.</summary>
            <remarks>Set if the number of adds or deletes was over the limit.</remarks>
        </member>
        <member name="M:NGit.Diff.RenameDetector.#ctor(NGit.Repository)">
            <summary>Create a new rename detector for the given repository</summary>
            <param name="repo">the repository to use for rename detection</param>
        </member>
        <member name="M:NGit.Diff.RenameDetector.GetRenameScore">
            <returns>
            minimum score required to pair an add/delete as a rename. The
            score ranges are within the bounds of (0, 100).
            </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Diff.RenameDetector.SetRenameScore(System.Int32)" -->
        <member name="M:NGit.Diff.RenameDetector.GetBreakScore">
            <returns>
            the similarity score required to keep modified file pairs
            together. Any modify pairs that score below this will be broken
            apart into separate add/deletes. Values less than or equal to
            zero indicate that no modifies will be broken apart. Values over
            100 cause all modify pairs to be broken.
            </returns>
        </member>
        <member name="M:NGit.Diff.RenameDetector.SetBreakScore(System.Int32)">
            <param name="breakScore">
            the similarity score required to keep modified file pairs
            together. Any modify pairs that score below this will be
            broken apart into separate add/deletes. Values less than or
            equal to zero indicate that no modifies will be broken apart.
            Values over 100 cause all modify pairs to be broken.
            </param>
        </member>
        <member name="M:NGit.Diff.RenameDetector.GetRenameLimit">
            <returns>limit on number of paths to perform inexact rename detection.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Diff.RenameDetector.SetRenameLimit(System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Diff.RenameDetector.IsOverRenameLimit" -->
        <member name="M:NGit.Diff.RenameDetector.AddAll(System.Collections.Generic.ICollection{NGit.Diff.DiffEntry})">
            <summary>Add entries to be considered for rename detection.</summary>
            <remarks>Add entries to be considered for rename detection.</remarks>
            <param name="entriesToAdd">one or more entries to add.</param>
            <exception cref="T:System.InvalidOperationException">
            if
            <code>getEntries</code>
            was already invoked.
            </exception>
        </member>
        <member name="M:NGit.Diff.RenameDetector.Add(NGit.Diff.DiffEntry)">
            <summary>Add an entry to be considered for rename detection.</summary>
            <remarks>Add an entry to be considered for rename detection.</remarks>
            <param name="entry">to add.</param>
            <exception cref="T:System.InvalidOperationException">
            if
            <code>getEntries</code>
            was already invoked.
            </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Diff.RenameDetector.Compute" -->
        <member name="M:NGit.Diff.RenameDetector.Compute(NGit.ProgressMonitor)">
            <summary>Detect renames in the current file set.</summary>
            <remarks>Detect renames in the current file set.</remarks>
            <param name="pm">report progress during the detection phases.</param>
            <returns>
            an unmodifiable list of
            <see cref="T:NGit.Diff.DiffEntry">DiffEntry</see>
            s representing all files
            that have been changed.
            </returns>
            <exception cref="T:System.IO.IOException">file contents cannot be read from the repository.
            	</exception>
        </member>
        <member name="M:NGit.Diff.RenameDetector.Compute(NGit.ObjectReader,NGit.ProgressMonitor)">
            <summary>Detect renames in the current file set.</summary>
            <remarks>Detect renames in the current file set.</remarks>
            <param name="reader">reader to obtain objects from the repository with.</param>
            <param name="pm">report progress during the detection phases.</param>
            <returns>
            an unmodifiable list of
            <see cref="T:NGit.Diff.DiffEntry">DiffEntry</see>
            s representing all files
            that have been changed.
            </returns>
            <exception cref="T:System.IO.IOException">file contents cannot be read from the repository.
            	</exception>
        </member>
        <member name="M:NGit.Diff.RenameDetector.Compute(NGit.Diff.ContentSource.Pair,NGit.ProgressMonitor)">
            <summary>Detect renames in the current file set.</summary>
            <remarks>Detect renames in the current file set.</remarks>
            <param name="reader">reader to obtain objects from the repository with.</param>
            <param name="pm">report progress during the detection phases.</param>
            <returns>
            an unmodifiable list of
            <see cref="T:NGit.Diff.DiffEntry">DiffEntry</see>
            s representing all files
            that have been changed.
            </returns>
            <exception cref="T:System.IO.IOException">file contents cannot be read from the repository.
            	</exception>
        </member>
        <member name="M:NGit.Diff.RenameDetector.Reset">
            <summary>Reset this rename detector for another rename detection pass.</summary>
            <remarks>Reset this rename detector for another rename detection pass.</remarks>
        </member>
        <member name="M:NGit.Diff.RenameDetector.BreakModifies(NGit.Diff.ContentSource.Pair,NGit.ProgressMonitor)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Diff.RenameDetector.CalculateModifyScore(NGit.Diff.ContentSource.Pair,NGit.Diff.DiffEntry)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Diff.RenameDetector.FindContentRenames(NGit.Diff.ContentSource.Pair,NGit.ProgressMonitor)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Diff.RenameDetector.BestPathMatch(NGit.Diff.DiffEntry,System.Collections.Generic.IList{NGit.Diff.DiffEntry})" -->
        <!-- Badly formed XML comment ignored for member "T:NGit.Api.TagCommand" -->
        <member name="M:NGit.Api.TagCommand.#ctor(NGit.Repository)">
            <param name="repo"></param>
        </member>
        <member name="M:NGit.Api.TagCommand.Call">
            <summary>
            Executes the
            <code>tag</code>
            command with all the options and parameters
            collected by the setter methods of this class. Each instance of this
            class should only be used for one invocation of the command (means: one
            call to
            <see cref="M:NGit.Api.TagCommand.Call">Call()</see>
            )
            </summary>
            <returns>
            a
            <see cref="T:NGit.Ref">NGit.Ref</see>
            a ref pointing to a tag
            </returns>
            <exception cref="T:NGit.Api.Errors.NoHeadException">when called on a git repo without a HEAD reference
            	</exception>
            <since>2.0</since>
            <exception cref="T:NGit.Api.Errors.GitAPIException"></exception>
            <exception cref="T:NGit.Api.Errors.ConcurrentRefUpdateException"></exception>
            <exception cref="T:NGit.Api.Errors.InvalidTagNameException"></exception>
        </member>
        <member name="M:NGit.Api.TagCommand.ProcessOptions(NGit.RepositoryState)">
            <summary>Sets default values for not explicitly specified options.</summary>
            <remarks>
            Sets default values for not explicitly specified options. Then validates
            that all required data has been provided.
            </remarks>
            <param name="state">the state of the repository we are working on</param>
            <exception cref="T:NGit.Api.Errors.InvalidTagNameException">if the tag name is null or invalid
            	</exception>
            <exception cref="T:System.NotSupportedException">if the tag is signed (not supported yet)
            	</exception>
        </member>
        <member name="M:NGit.Api.TagCommand.SetName(System.String)">
            <param name="name">
            the tag name used for the
            <code>tag</code>
            </param>
            <returns>
            
            <code>this</code>
            </returns>
        </member>
        <member name="M:NGit.Api.TagCommand.GetName">
            <returns>the tag name used for the <code>tag</code></returns>
        </member>
        <member name="M:NGit.Api.TagCommand.GetMessage">
            <returns>the tag message used for the <code>tag</code></returns>
        </member>
        <member name="M:NGit.Api.TagCommand.SetMessage(System.String)">
            <param name="message">
            the tag message used for the
            <code>tag</code>
            </param>
            <returns>
            
            <code>this</code>
            </returns>
        </member>
        <member name="M:NGit.Api.TagCommand.IsSigned">
            <returns>whether the tag is signed</returns>
        </member>
        <member name="M:NGit.Api.TagCommand.SetSigned(System.Boolean)">
            <summary>If set to true the Tag command creates a signed tag object.</summary>
            <remarks>
            If set to true the Tag command creates a signed tag object. This
            corresponds to the parameter -s on the command line.
            </remarks>
            <param name="signed"></param>
            <returns>
            
            <code>this</code>
            </returns>
        </member>
        <member name="M:NGit.Api.TagCommand.SetTagger(NGit.PersonIdent)">
            <summary>Sets the tagger of the tag.</summary>
            <remarks>
            Sets the tagger of the tag. If the tagger is null, a PersonIdent will be
            created from the info in the repository.
            </remarks>
            <param name="tagger"></param>
            <returns>
            
            <code>this</code>
            </returns>
        </member>
        <member name="M:NGit.Api.TagCommand.GetTagger">
            <returns>the tagger of the tag</returns>
        </member>
        <member name="M:NGit.Api.TagCommand.GetObjectId">
            <returns>the object id of the tag</returns>
        </member>
        <member name="M:NGit.Api.TagCommand.SetObjectId(NGit.Revwalk.RevObject)">
            <summary>Sets the object id of the tag.</summary>
            <remarks>
            Sets the object id of the tag. If the object id is null, the commit
            pointed to from HEAD will be used.
            </remarks>
            <param name="id"></param>
            <returns>
            
            <code>this</code>
            </returns>
        </member>
        <member name="M:NGit.Api.TagCommand.IsForceUpdate">
            <returns>is this a force update</returns>
        </member>
        <member name="M:NGit.Api.TagCommand.SetForceUpdate(System.Boolean)">
            <summary>If set to true the Tag command may replace an existing tag object.</summary>
            <remarks>
            If set to true the Tag command may replace an existing tag object. This
            corresponds to the parameter -f on the command line.
            </remarks>
            <param name="forceUpdate"></param>
            <returns>
            
            <code>this</code>
            </returns>
        </member>
        <member name="T:NGit.TransferConfig">
            <summary>The standard "transfer", "fetch" and "receive" configuration parameters.
            	</summary>
            <remarks>The standard "transfer", "fetch" and "receive" configuration parameters.
            	</remarks>
        </member>
        <member name="F:NGit.TransferConfig.KEY">
            <summary>
            Key for
            <see cref="!:Config.Get&lt;T&gt;(SectionParser&lt;T&gt;)">Config.Get&lt;T&gt;(SectionParser&lt;T&gt;)
            	</see>
            .
            </summary>
        </member>
        <member name="M:NGit.TransferConfig.IsFsckObjects">
            <returns>strictly verify received objects?</returns>
        </member>
        <member name="T:NGit.RepositoryCache">
            <summary>
            Cache of active
            <see cref="T:NGit.Repository">Repository</see>
            instances.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.RepositoryCache.Open(NGit.RepositoryCache.Key)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.RepositoryCache.Open(NGit.RepositoryCache.Key,System.Boolean)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.RepositoryCache.Register(NGit.Repository)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.RepositoryCache.Close(NGit.Repository)" -->
        <member name="M:NGit.RepositoryCache.Clear">
            <summary>Unregister all repositories from the cache.</summary>
            <remarks>Unregister all repositories from the cache.</remarks>
        </member>
        <member name="M:NGit.RepositoryCache.OpenRepository(NGit.RepositoryCache.Key,System.Boolean)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.RepositoryCache.Key" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.RepositoryCache.Key.Open(System.Boolean)" -->
        <member name="T:NGit.RepositoryCache.FileKey">
            <summary>Location of a Repository, using the standard java.io.File API.</summary>
            <remarks>Location of a Repository, using the standard java.io.File API.</remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.RepositoryCache.FileKey.Exact(Sharpen.FilePath,NGit.Util.FS)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.RepositoryCache.FileKey.Lenient(Sharpen.FilePath,NGit.Util.FS)" -->
        <member name="M:NGit.RepositoryCache.FileKey.#ctor(Sharpen.FilePath,NGit.Util.FS)">
            <param name="directory">exact location of the repository.</param>
            <param name="fs">
            the file system abstraction which will be necessary to
            perform certain file system operations.
            </param>
        </member>
        <member name="M:NGit.RepositoryCache.FileKey.GetFile">
            <returns>location supplied to the constructor.</returns>
        </member>
        <member name="M:NGit.RepositoryCache.FileKey.Open(System.Boolean)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.RepositoryCache.FileKey.IsGitRepository(Sharpen.FilePath,NGit.Util.FS)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.RepositoryCache.FileKey.Resolve(Sharpen.FilePath,NGit.Util.FS)" -->
        <!-- Badly formed XML comment ignored for member "T:NGit.ObjectReader" -->
        <member name="F:NGit.ObjectReader.OBJ_ANY">
            <summary>Type hint indicating the caller doesn't know the type.</summary>
            <remarks>Type hint indicating the caller doesn't know the type.</remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.ObjectReader.NewReader" -->
        <member name="M:NGit.ObjectReader.Abbreviate(NGit.AnyObjectId)">
            <summary>Obtain a unique abbreviation (prefix) of an object SHA-1.</summary>
            <remarks>
            Obtain a unique abbreviation (prefix) of an object SHA-1.
            This method uses a reasonable default for the minimum length. Callers who
            don't care about the minimum length should prefer this method.
            The returned abbreviation would expand back to the argument ObjectId when
            passed to
            <see cref="M:NGit.ObjectReader.Resolve(NGit.AbbreviatedObjectId)">Resolve(AbbreviatedObjectId)</see>
            , assuming no new objects
            are added to this repository between calls.
            </remarks>
            <param name="objectId">object identity that needs to be abbreviated.</param>
            <returns>SHA-1 abbreviation.</returns>
            <exception cref="T:System.IO.IOException">the object store cannot be read.</exception>
        </member>
        <member name="M:NGit.ObjectReader.Abbreviate(NGit.AnyObjectId,System.Int32)">
            <summary>Obtain a unique abbreviation (prefix) of an object SHA-1.</summary>
            <remarks>
            Obtain a unique abbreviation (prefix) of an object SHA-1.
            The returned abbreviation would expand back to the argument ObjectId when
            passed to
            <see cref="M:NGit.ObjectReader.Resolve(NGit.AbbreviatedObjectId)">Resolve(AbbreviatedObjectId)</see>
            , assuming no new objects
            are added to this repository between calls.
            The default implementation of this method abbreviates the id to the
            minimum length, then resolves it to see if there are multiple results.
            When multiple results are found, the length is extended by 1 and resolve
            is tried again.
            </remarks>
            <param name="objectId">object identity that needs to be abbreviated.</param>
            <param name="len">
            minimum length of the abbreviated string. Must be in the range
            [2,
            <value>Constants#OBJECT_ID_STRING_LENGTH</value>
            ].
            </param>
            <returns>
            SHA-1 abbreviation. If no matching objects exist in the
            repository, the abbreviation will match the minimum length.
            </returns>
            <exception cref="T:System.IO.IOException">the object store cannot be read.</exception>
        </member>
        <member name="M:NGit.ObjectReader.Resolve(NGit.AbbreviatedObjectId)">
            <summary>Resolve an abbreviated ObjectId to its full form.</summary>
            <remarks>
            Resolve an abbreviated ObjectId to its full form.
            This method searches for an ObjectId that begins with the abbreviation,
            and returns at least some matching candidates.
            If the returned collection is empty, no objects start with this
            abbreviation. The abbreviation doesn't belong to this repository, or the
            repository lacks the necessary objects to complete it.
            If the collection contains exactly one member, the abbreviation is
            (currently) unique within this database. There is a reasonably high
            probability that the returned id is what was previously abbreviated.
            If the collection contains 2 or more members, the abbreviation is not
            unique. In this case the implementation is only required to return at
            least 2 candidates to signal the abbreviation has conflicts. User
            friendly implementations should return as many candidates as reasonably
            possible, as the caller may be able to disambiguate further based on
            context. However since databases can be very large (e.g. 10 million
            objects) returning 625,000 candidates for the abbreviation "0" is simply
            unreasonable, so implementors should draw the line at around 256 matches.
            </remarks>
            <param name="id">
            abbreviated id to resolve to a complete identity. The
            abbreviation must have a length of at least 2.
            </param>
            <returns>candidates that begin with the abbreviated identity.</returns>
            <exception cref="T:System.IO.IOException">the object store cannot be read.</exception>
        </member>
        <member name="M:NGit.ObjectReader.Has(NGit.AnyObjectId)">
            <summary>Does the requested object exist in this database?</summary>
            <param name="objectId">identity of the object to test for existence of.</param>
            <returns>true if the specified object is stored in this database.</returns>
            <exception cref="T:System.IO.IOException">the object store cannot be accessed.</exception>
        </member>
        <member name="M:NGit.ObjectReader.Has(NGit.AnyObjectId,System.Int32)">
            <summary>Does the requested object exist in this database?</summary>
            <param name="objectId">identity of the object to test for existence of.</param>
            <param name="typeHint">
            hint about the type of object being requested;
            <see cref="F:NGit.ObjectReader.OBJ_ANY">OBJ_ANY</see>
            if the object type is not known, or does not
            matter to the caller.
            </param>
            <returns>true if the specified object is stored in this database.</returns>
            <exception cref="T:NGit.Errors.IncorrectObjectTypeException">
            typeHint was not OBJ_ANY, and the object's actual type does
            not match typeHint.
            </exception>
            <exception cref="T:System.IO.IOException">the object store cannot be accessed.</exception>
        </member>
        <member name="M:NGit.ObjectReader.Open(NGit.AnyObjectId)">
            <summary>Open an object from this database.</summary>
            <remarks>Open an object from this database.</remarks>
            <param name="objectId">identity of the object to open.</param>
            <returns>
            a
            <see cref="T:NGit.ObjectLoader">ObjectLoader</see>
            for accessing the object.
            </returns>
            <exception cref="T:NGit.Errors.MissingObjectException">the object does not exist.</exception>
            <exception cref="T:System.IO.IOException">the object store cannot be accessed.</exception>
        </member>
        <member name="M:NGit.ObjectReader.Open(NGit.AnyObjectId,System.Int32)">
            <summary>Open an object from this database.</summary>
            <remarks>Open an object from this database.</remarks>
            <param name="objectId">identity of the object to open.</param>
            <param name="typeHint">
            hint about the type of object being requested;
            <see cref="F:NGit.ObjectReader.OBJ_ANY">OBJ_ANY</see>
            if the object type is not known, or does not
            matter to the caller.
            </param>
            <returns>
            a
            <see cref="T:NGit.ObjectLoader">ObjectLoader</see>
            for accessing the object.
            </returns>
            <exception cref="T:NGit.Errors.MissingObjectException">the object does not exist.</exception>
            <exception cref="T:NGit.Errors.IncorrectObjectTypeException">
            typeHint was not OBJ_ANY, and the object's actual type does
            not match typeHint.
            </exception>
            <exception cref="T:System.IO.IOException">the object store cannot be accessed.</exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.ObjectReader.Open``1(Sharpen.Iterable{``0},System.Boolean)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.ObjectReader.GetObjectSize(NGit.AnyObjectId,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.ObjectReader.GetObjectSize``1(Sharpen.Iterable{``0},System.Boolean)" -->
        <member name="M:NGit.ObjectReader.WalkAdviceBeginCommits(NGit.Revwalk.RevWalk,System.Collections.Generic.ICollection{NGit.Revwalk.RevCommit})">
            <summary>
            Advice from a
            <see cref="T:NGit.Revwalk.RevWalk">NGit.Revwalk.RevWalk</see>
            that a walk is starting from these roots.
            </summary>
            <param name="walk">the revision pool that is using this reader.</param>
            <param name="roots">
            starting points of the revision walk. The starting points have
            their headers parsed, but might be missing bodies.
            </param>
            <exception cref="T:System.IO.IOException">the reader cannot initialize itself to support the walk.
            	</exception>
        </member>
        <member name="M:NGit.ObjectReader.WalkAdviceBeginTrees(NGit.Revwalk.ObjectWalk,NGit.Revwalk.RevCommit,NGit.Revwalk.RevCommit)">
            <summary>
            Advice from an
            <see cref="T:NGit.Revwalk.ObjectWalk">NGit.Revwalk.ObjectWalk</see>
            that trees will be traversed.
            </summary>
            <param name="ow">the object pool that is using this reader.</param>
            <param name="min">the first commit whose root tree will be read.</param>
            <param name="max">the last commit whose root tree will be read.</param>
            <exception cref="T:System.IO.IOException">the reader cannot initialize itself to support the walk.
            	</exception>
        </member>
        <member name="M:NGit.ObjectReader.WalkAdviceEnd">
            <summary>Advice from that a walk is over.</summary>
            <remarks>Advice from that a walk is over.</remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.ObjectReader.Release" -->
        <!-- Badly formed XML comment ignored for member "T:NGit.AsyncObjectLoaderQueue`1" -->
        <member name="M:NGit.AsyncObjectLoaderQueue`1.Next">
            <summary>Position this queue onto the next available result.</summary>
            <remarks>
            Position this queue onto the next available result.
            Even if this method returns true,
            <see cref="M:NGit.AsyncObjectLoaderQueue`1.Open">AsyncObjectLoaderQueue&lt;T&gt;.Open()
            	</see>
            may still throw
            <see cref="T:NGit.Errors.MissingObjectException">NGit.Errors.MissingObjectException
            	</see>
            if the underlying object database was
            concurrently modified and the current object is no longer available.
            </remarks>
            <returns>
            true if there is a result available; false if the queue has
            finished its input iteration.
            </returns>
            <exception cref="T:NGit.Errors.MissingObjectException">
            the object does not exist. If the implementation is retaining
            the application's objects
            <see cref="M:NGit.AsyncObjectLoaderQueue`1.GetCurrent">AsyncObjectLoaderQueue&lt;T&gt;.GetCurrent()
            	</see>
            will be the
            current object that is missing. There may be more results
            still available, so the caller should continue invoking next
            to examine another result.
            </exception>
            <exception cref="T:System.IO.IOException">the object store cannot be accessed.</exception>
        </member>
        <member name="M:NGit.AsyncObjectLoaderQueue`1.GetCurrent">
            <returns>
            the current object, null if the implementation lost track.
            Implementations may for performance reasons discard the caller's
            ObjectId and provider their own through
            <see cref="M:NGit.AsyncObjectLoaderQueue`1.GetObjectId">AsyncObjectLoaderQueue&lt;T&gt;.GetObjectId()
            	</see>
            .
            </returns>
        </member>
        <member name="M:NGit.AsyncObjectLoaderQueue`1.GetObjectId">
            <returns>the ObjectId of the current object. Never null.</returns>
        </member>
        <member name="M:NGit.AsyncObjectLoaderQueue`1.Open">
            <summary>Obtain a loader to read the object.</summary>
            <remarks>
            Obtain a loader to read the object.
            This method can only be invoked once per result
            Due to race conditions with a concurrent modification of the underlying
            object database, an object may be unavailable when this method is
            invoked, even though next returned successfully.
            </remarks>
            <returns>the ObjectLoader to read this object. Never null.</returns>
            <exception cref="T:NGit.Errors.MissingObjectException">
            the object does not exist. If the implementation is retaining
            the application's objects
            <see cref="M:NGit.AsyncObjectLoaderQueue`1.GetCurrent">AsyncObjectLoaderQueue&lt;T&gt;.GetCurrent()
            	</see>
            will be the
            current object that is missing. There may be more results
            still available, so the caller should continue invoking next
            to examine another result.
            </exception>
            <exception cref="T:System.IO.IOException">the object store cannot be accessed.</exception>
        </member>
        <member name="M:NGit.ObjectReader._AsyncObjectLoaderQueue_272`1.Next">
            <exception cref="T:NGit.Errors.MissingObjectException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.ObjectReader._AsyncObjectLoaderQueue_272`1.Open">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.ObjectReader._AsyncObjectSizeQueue_354`1.Next">
            <exception cref="T:NGit.Errors.MissingObjectException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.ObjectChecker" -->
        <member name="F:NGit.ObjectChecker.tree">
            <summary>Header "tree "</summary>
        </member>
        <member name="F:NGit.ObjectChecker.parent">
            <summary>Header "parent "</summary>
        </member>
        <member name="F:NGit.ObjectChecker.author">
            <summary>Header "author "</summary>
        </member>
        <member name="F:NGit.ObjectChecker.committer">
            <summary>Header "committer "</summary>
        </member>
        <member name="F:NGit.ObjectChecker.encoding">
            <summary>Header "encoding "</summary>
        </member>
        <member name="F:NGit.ObjectChecker.object">
            <summary>Header "object "</summary>
        </member>
        <member name="F:NGit.ObjectChecker.type">
            <summary>Header "type "</summary>
        </member>
        <member name="F:NGit.ObjectChecker.tag">
            <summary>Header "tag "</summary>
        </member>
        <member name="F:NGit.ObjectChecker.tagger">
            <summary>Header "tagger "</summary>
        </member>
        <member name="M:NGit.ObjectChecker.Check(System.Int32,System.Byte[])">
            <summary>Check an object for parsing errors.</summary>
            <remarks>Check an object for parsing errors.</remarks>
            <param name="objType">
            type of the object. Must be a valid object type code in
            <see cref="T:NGit.Constants">Constants</see>
            .
            </param>
            <param name="raw">
            the raw data which comprises the object. This should be in the
            canonical format (that is the format used to generate the
            ObjectId of the object). The array is never modified.
            </param>
            <exception cref="T:NGit.Errors.CorruptObjectException">if an error is identified.</exception>
        </member>
        <member name="M:NGit.ObjectChecker.CheckCommit(System.Byte[])">
            <summary>Check a commit for errors.</summary>
            <remarks>Check a commit for errors.</remarks>
            <param name="raw">the commit data. The array is never modified.</param>
            <exception cref="T:NGit.Errors.CorruptObjectException">if any error was detected.</exception>
        </member>
        <member name="M:NGit.ObjectChecker.CheckTag(System.Byte[])">
            <summary>Check an annotated tag for errors.</summary>
            <remarks>Check an annotated tag for errors.</remarks>
            <param name="raw">the tag data. The array is never modified.</param>
            <exception cref="T:NGit.Errors.CorruptObjectException">if any error was detected.</exception>
        </member>
        <member name="M:NGit.ObjectChecker.CheckTree(System.Byte[])">
            <summary>Check a canonical formatted tree for errors.</summary>
            <remarks>Check a canonical formatted tree for errors.</remarks>
            <param name="raw">the raw tree data. The array is never modified.</param>
            <exception cref="T:NGit.Errors.CorruptObjectException">if any error was detected.</exception>
        </member>
        <member name="M:NGit.ObjectChecker.CheckBlob(System.Byte[])">
            <summary>Check a blob for errors.</summary>
            <remarks>Check a blob for errors.</remarks>
            <param name="raw">the blob data. The array is never modified.</param>
            <exception cref="T:NGit.Errors.CorruptObjectException">if any error was detected.</exception>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Transport.PreReceiveHookChain" -->
        <!-- Badly formed XML comment ignored for member "T:NGit.Transport.PreReceiveHook" -->
        <member name="F:NGit.Transport.PreReceiveHook.NULL">
            <summary>A simple no-op hook.</summary>
            <remarks>A simple no-op hook.</remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Transport.PreReceiveHook.OnPreReceive(NGit.Transport.ReceivePack,System.Collections.Generic.ICollection{NGit.Transport.ReceiveCommand})" -->
        <member name="M:NGit.Transport.PreReceiveHookChain.NewChain``1(System.Collections.Generic.IList{``0})">
            <summary>Create a new hook chaining the given hooks together.</summary>
            <remarks>Create a new hook chaining the given hooks together.</remarks>
            <param name="hooks">hooks to execute, in order.</param>
            <returns>a new hook chain of the given hooks.</returns>
        </member>
        <member name="T:NGit.Revwalk.DepthGenerator">
            <summary>Only produce commits which are below a specified depth.</summary>
            <remarks>Only produce commits which are below a specified depth.</remarks>
            <seealso cref="T:NGit.Revwalk.DepthWalk">DepthWalk</seealso>
        </member>
        <member name="F:NGit.Revwalk.DepthGenerator.UNSHALLOW">
            <summary>
            Commits which used to be shallow in the client, but which are
            being extended as part of this fetch.
            </summary>
            <remarks>
            Commits which used to be shallow in the client, but which are
            being extended as part of this fetch.  These commits should be
            returned to the caller as UNINTERESTING so that their blobs/trees
            can be marked appropriately in the pack writer.
            </remarks>
        </member>
        <member name="F:NGit.Revwalk.DepthGenerator.REINTERESTING">
            <summary>
            Commits which the normal framework has marked as UNINTERESTING,
            but which we now care about again.
            </summary>
            <remarks>
            Commits which the normal framework has marked as UNINTERESTING,
            but which we now care about again.  This happens if a client is
            extending a shallow checkout to become deeper--the new commits at
            the bottom of the graph need to be sent, even though they are
            below other commits which the client already has.
            </remarks>
        </member>
        <member name="M:NGit.Revwalk.DepthGenerator.#ctor(NGit.Revwalk.DepthWalk,NGit.Revwalk.Generator)">
            <param name="w"></param>
            <param name="s">Parent generator</param>
            <exception cref="T:NGit.Errors.MissingObjectException">NGit.Errors.MissingObjectException
            	</exception>
            <exception cref="T:NGit.Errors.IncorrectObjectTypeException">NGit.Errors.IncorrectObjectTypeException
            	</exception>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:NGit.Revwalk.DepthGenerator.Next">
            <exception cref="T:NGit.Errors.MissingObjectException"></exception>
            <exception cref="T:NGit.Errors.IncorrectObjectTypeException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="T:NGit.Notes.NotesMergeConflictException">
            <summary>
            This exception will be thrown from the
            <see cref="T:NGit.Notes.NoteMerger">NoteMerger</see>
            when a conflict on
            Notes content is found during merge.
            </summary>
        </member>
        <member name="M:NGit.Notes.NotesMergeConflictException.#ctor(NGit.Notes.Note,NGit.Notes.Note,NGit.Notes.Note)">
            <summary>
            Construct a NotesMergeConflictException for the specified base, ours and
            theirs note versions.
            </summary>
            <remarks>
            Construct a NotesMergeConflictException for the specified base, ours and
            theirs note versions.
            </remarks>
            <param name="base">note version</param>
            <param name="ours">note version</param>
            <param name="theirs">note version</param>
        </member>
        <member name="M:NGit.Notes.NotesMergeConflictException.#ctor(NGit.Notes.NonNoteEntry,NGit.Notes.NonNoteEntry,NGit.Notes.NonNoteEntry)">
            <summary>
            Constructs a NotesMergeConflictException for the specified base, ours and
            theirs versions of the root note tree.
            </summary>
            <remarks>
            Constructs a NotesMergeConflictException for the specified base, ours and
            theirs versions of the root note tree.
            </remarks>
            <param name="base">version of the root note tree</param>
            <param name="ours">version of the root note tree</param>
            <param name="theirs">version of the root note tree</param>
        </member>
        <member name="T:NGit.Notes.FanoutBucket">
            <summary>A note tree holding only note subtrees, each named using a 2 digit hex name.
            	</summary>
            <remarks>
            A note tree holding only note subtrees, each named using a 2 digit hex name.
            The fanout buckets/trees contain on average 256 subtrees, naming the subtrees
            by a slice of the ObjectId contained within them, from "00" through "ff".
            Each fanout bucket has a
            <see cref="F:NGit.Notes.InMemoryNoteBucket.prefixLen">InMemoryNoteBucket.prefixLen</see>
            that defines how many digits it
            skips in an ObjectId before it gets to the digits matching
            <see cref="F:NGit.Notes.FanoutBucket.table">table</see>
            .
            The root tree has
            <code>prefixLen == 0</code>
            , and thus does not skip any digits.
            For ObjectId "c0ffee...", the note (if it exists) will be stored within the
            bucket
            <code>table[0xc0]</code>
            .
            The first level tree has
            <code>prefixLen == 2</code>
            , and thus skips the first two
            digits. For the same example "c0ffee..." object, its note would be found
            within the
            <code>table[0xff]</code>
            bucket (as first 2 digits "c0" are skipped).
            Each subtree is loaded on-demand, reducing startup latency for reads that
            only need to examine a few objects. However, due to the rather uniform
            distribution of the SHA-1 hash that is used for ObjectIds, accessing 256
            objects is very likely to load all of the subtrees into memory.
            A FanoutBucket must be parsed from a tree object by
            <see cref="T:NGit.Notes.NoteParser">NoteParser</see>
            .
            </remarks>
        </member>
        <member name="T:NGit.Notes.InMemoryNoteBucket">
            <summary>A note bucket that has been loaded into the process.</summary>
            <remarks>A note bucket that has been loaded into the process.</remarks>
        </member>
        <member name="T:NGit.Notes.NoteBucket">
            <summary>A tree that stores note objects.</summary>
            <remarks>A tree that stores note objects.</remarks>
            <seealso cref="T:NGit.Notes.FanoutBucket">FanoutBucket</seealso>
            <seealso cref="T:NGit.Notes.LeafBucket">LeafBucket</seealso>
        </member>
        <member name="M:NGit.Notes.NoteBucket.GetNote(NGit.AnyObjectId,NGit.ObjectReader)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Notes.NoteBucket.Iterator(NGit.AnyObjectId,NGit.ObjectReader)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Notes.NoteBucket.EstimateSize(NGit.AnyObjectId,NGit.ObjectReader)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Notes.NoteBucket.Set(NGit.AnyObjectId,NGit.AnyObjectId,NGit.ObjectReader)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Notes.NoteBucket.WriteTree(NGit.ObjectInserter)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="F:NGit.Notes.InMemoryNoteBucket.prefixLen">
            <summary>Number of leading digits that leads to this bucket in the note path.</summary>
            <remarks>
            Number of leading digits that leads to this bucket in the note path.
            This is counted in terms of hex digits, not raw bytes. Each bucket level
            is typically 2 higher than its parent, placing about 256 items in each
            level of the tree.
            </remarks>
        </member>
        <member name="F:NGit.Notes.InMemoryNoteBucket.nonNotes">
            <summary>Chain of non-note tree entries found at this path in the tree.</summary>
            <remarks>
            Chain of non-note tree entries found at this path in the tree.
            During parsing of a note tree into the in-memory representation,
            <see cref="T:NGit.Notes.NoteParser">NoteParser</see>
            keeps track of all non-note tree entries and stores
            them here as a sorted linked list. That list can be merged back with the
            note data that is held by the subclass, allowing the tree to be
            recreated.
            </remarks>
        </member>
        <member name="F:NGit.Notes.FanoutBucket.table">
            <summary>Fan-out table similar to the PackIndex structure.</summary>
            <remarks>
            Fan-out table similar to the PackIndex structure.
            Notes for an object are stored within the sub-bucket that is held here as
            <code>table[ objectId.getByte( prefixLen / 2 ) ]</code>
            . If the slot is null
            there are no notes with that prefix.
            </remarks>
        </member>
        <member name="F:NGit.Notes.FanoutBucket.cnt">
            <summary>
            Number of non-null slots in
            <see cref="F:NGit.Notes.FanoutBucket.table">table</see>
            .
            </summary>
        </member>
        <member name="M:NGit.Notes.FanoutBucket.GetNote(NGit.AnyObjectId,NGit.ObjectReader)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Notes.FanoutBucket.LoadIfLazy(NGit.Notes.NoteBucket,NGit.AnyObjectId,NGit.ObjectReader)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Notes.FanoutBucket.Iterator(NGit.AnyObjectId,NGit.ObjectReader)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Notes.FanoutBucket.EstimateSize(NGit.AnyObjectId,NGit.ObjectReader)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Notes.FanoutBucket.Set(NGit.AnyObjectId,NGit.AnyObjectId,NGit.ObjectReader)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Notes.FanoutBucket.ContractIfTooSmall(NGit.AnyObjectId,NGit.ObjectReader)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Notes.FanoutBucket.WriteTree(NGit.ObjectInserter)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Notes.FanoutBucket.Build(System.Boolean,NGit.ObjectInserter)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Notes.FanoutBucket.LazyNoteBucket.GetNote(NGit.AnyObjectId,NGit.ObjectReader)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Notes.FanoutBucket.LazyNoteBucket.Iterator(NGit.AnyObjectId,NGit.ObjectReader)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Notes.FanoutBucket.LazyNoteBucket.EstimateSize(NGit.AnyObjectId,NGit.ObjectReader)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Notes.FanoutBucket.LazyNoteBucket.Set(NGit.AnyObjectId,NGit.AnyObjectId,NGit.ObjectReader)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Notes.FanoutBucket.LazyNoteBucket.Load(NGit.AnyObjectId,NGit.ObjectReader)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Api.PullCommand" -->
        <member name="M:NGit.Api.PullCommand.#ctor(NGit.Repository)">
            <param name="repo"></param>
        </member>
        <member name="M:NGit.Api.PullCommand.SetProgressMonitor(NGit.ProgressMonitor)">
            <param name="monitor">a progress monitor</param>
            <returns>this instance</returns>
        </member>
        <member name="M:NGit.Api.PullCommand.Call">
            <summary>
            Executes the
            <code>Pull</code>
            command with all the options and parameters
            collected by the setter methods (e.g.
            <see cref="M:NGit.Api.PullCommand.SetProgressMonitor(NGit.ProgressMonitor)">SetProgressMonitor(NGit.ProgressMonitor)
            	</see>
            ) of this class. Each
            instance of this class should only be used for one invocation of the
            command. Don't call this method twice on an instance.
            </summary>
            <returns>the result of the pull</returns>
            <exception cref="T:NGit.Api.Errors.WrongRepositoryStateException">NGit.Api.Errors.WrongRepositoryStateException
            	</exception>
            <exception cref="T:NGit.Api.Errors.InvalidConfigurationException">NGit.Api.Errors.InvalidConfigurationException
            	</exception>
            <exception cref="T:NGit.Api.Errors.DetachedHeadException">NGit.Api.Errors.DetachedHeadException
            	</exception>
            <exception cref="T:NGit.Api.Errors.InvalidRemoteException">NGit.Api.Errors.InvalidRemoteException
            	</exception>
            <exception cref="T:NGit.Api.Errors.CanceledException">NGit.Api.Errors.CanceledException
            	</exception>
            <exception cref="T:NGit.Api.Errors.RefNotFoundException">NGit.Api.Errors.RefNotFoundException
            	</exception>
            <exception cref="T:NGit.Api.Errors.NoHeadException">NGit.Api.Errors.NoHeadException
            	</exception>
            <exception cref="T:NGit.Api.Errors.TransportException">NGit.Api.Errors.TransportException
            	</exception>
            <exception cref="T:NGit.Api.Errors.GitAPIException">NGit.Api.Errors.GitAPIException
            	</exception>
        </member>
        <member name="T:NGit.Transport.DaemonClient">
            <summary>
            Active network client of
            <see cref="T:NGit.Transport.Daemon">Daemon</see>
            .
            </summary>
        </member>
        <member name="M:NGit.Transport.DaemonClient.GetDaemon">
            <returns>the daemon which spawned this client.</returns>
        </member>
        <member name="M:NGit.Transport.DaemonClient.GetRemoteAddress">
            <returns>Internet address of the remote client.</returns>
        </member>
        <member name="M:NGit.Transport.DaemonClient.GetInputStream">
            <returns>input stream to read from the connected client.</returns>
        </member>
        <member name="M:NGit.Transport.DaemonClient.GetOutputStream">
            <returns>output stream to send data to the connected client.</returns>
        </member>
        <member name="M:NGit.Transport.DaemonClient.Execute(System.Net.Sockets.Socket)">
            <exception cref="T:System.IO.IOException"></exception>
            <exception cref="T:NGit.Transport.Resolver.ServiceNotEnabledException"></exception>
            <exception cref="T:NGit.Transport.Resolver.ServiceNotAuthorizedException"></exception>
        </member>
        <member name="T:NGit.Transport.PushResult">
            <summary>Result of push operation to the remote repository.</summary>
            <remarks>
            Result of push operation to the remote repository. Holding information of
            <see cref="T:NGit.Transport.OperationResult">OperationResult</see>
            and remote refs updates status.
            </remarks>
            <seealso cref="!:Transport.Push(NGit.ProgressMonitor, System.Collections.Generic.ICollection&lt;E&gt;)&#xA;            	">Transport.Push(NGit.ProgressMonitor, System.Collections.Generic.ICollection&lt;E&gt;)
            	</seealso>
        </member>
        <member name="M:NGit.Transport.PushResult.GetRemoteUpdates">
            <summary>Get status of remote refs updates.</summary>
            <remarks>
            Get status of remote refs updates. Together with
            <see cref="M:NGit.Transport.OperationResult.GetAdvertisedRefs">OperationResult.GetAdvertisedRefs()
            	</see>
            it provides full description/status of each
            ref update.
            <p>
            Returned collection is not sorted in any order.
            </p>
            </remarks>
            <returns>collection of remote refs updates</returns>
        </member>
        <member name="M:NGit.Transport.PushResult.GetRemoteUpdate(System.String)">
            <summary>Get status of specific remote ref update by remote ref name.</summary>
            <remarks>
            Get status of specific remote ref update by remote ref name. Together
            with
            <see cref="M:NGit.Transport.OperationResult.GetAdvertisedRef(System.String)">OperationResult.GetAdvertisedRef(string)
            	</see>
            it provide full description/status
            of this ref update.
            </remarks>
            <param name="refName">remote ref name</param>
            <returns>status of remote ref update</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Treewalk.Filter.PathFilterGroup" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Treewalk.Filter.PathFilterGroup.CreateFromStrings(System.Collections.Generic.ICollection{System.String})" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Treewalk.Filter.PathFilterGroup.CreateFromStrings(System.String[])" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Treewalk.Filter.PathFilterGroup.Create(System.Collections.Generic.ICollection{NGit.Treewalk.Filter.PathFilter})" -->
        <member name="T:NGit.Storage.File.ObjectDirectoryInserter">
            <summary>
            Creates loose objects in a
            <see cref="T:NGit.Storage.File.ObjectDirectory">ObjectDirectory</see>
            .
            </summary>
        </member>
        <member name="M:NGit.Storage.File.ObjectDirectoryInserter.Insert(System.Int32,System.Byte[],System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.ObjectDirectoryInserter.Insert(System.Int32,System.Int64,Sharpen.InputStream)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.ObjectDirectoryInserter.InsertOneObject(Sharpen.FilePath,NGit.ObjectId)">
            <exception cref="T:System.IO.IOException"></exception>
            <exception cref="T:NGit.Errors.ObjectWritingException"></exception>
        </member>
        <member name="M:NGit.Storage.File.ObjectDirectoryInserter.NewPackParser(Sharpen.InputStream)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.ObjectDirectoryInserter.Flush">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.ObjectDirectoryInserter.ToTemp(Sharpen.MessageDigest,System.Int32,System.Int64,Sharpen.InputStream)">
            <exception cref="T:System.IO.IOException"></exception>
            <exception cref="T:System.IO.FileNotFoundException"></exception>
            <exception cref="T:Sharpen.Error"></exception>
        </member>
        <member name="M:NGit.Storage.File.ObjectDirectoryInserter.ToTemp(System.Int32,System.Byte[],System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
            <exception cref="T:System.IO.FileNotFoundException"></exception>
        </member>
        <member name="M:NGit.Storage.File.ObjectDirectoryInserter.WriteHeader(Sharpen.OutputStream,System.Int32,System.Int64)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.ObjectDirectoryInserter.NewTempFile">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="T:NGit.Revwalk.Filter.RevFlagFilter">
            <summary>Matches only commits with some/all RevFlags already set.</summary>
            <remarks>Matches only commits with some/all RevFlags already set.</remarks>
        </member>
        <member name="M:NGit.Revwalk.Filter.RevFlagFilter.Has(NGit.Revwalk.RevFlag)">
            <summary>Create a new filter that tests for a single flag.</summary>
            <remarks>Create a new filter that tests for a single flag.</remarks>
            <param name="a">the flag to test.</param>
            <returns>filter that selects only commits with flag <code>a</code>.</returns>
        </member>
        <member name="M:NGit.Revwalk.Filter.RevFlagFilter.HasAllFilter(NGit.Revwalk.RevFlag[])">
            <summary>Create a new filter that tests all flags in a set.</summary>
            <remarks>Create a new filter that tests all flags in a set.</remarks>
            <param name="a">set of flags to test.</param>
            <returns>filter that selects only commits with all flags in <code>a</code>.</returns>
        </member>
        <member name="M:NGit.Revwalk.Filter.RevFlagFilter.HasAllFilter(NGit.Revwalk.RevFlagSet)">
            <summary>Create a new filter that tests all flags in a set.</summary>
            <remarks>Create a new filter that tests all flags in a set.</remarks>
            <param name="a">set of flags to test.</param>
            <returns>filter that selects only commits with all flags in <code>a</code>.</returns>
        </member>
        <member name="M:NGit.Revwalk.Filter.RevFlagFilter.HasAnyFilter(NGit.Revwalk.RevFlag[])">
            <summary>Create a new filter that tests for any flag in a set.</summary>
            <remarks>Create a new filter that tests for any flag in a set.</remarks>
            <param name="a">set of flags to test.</param>
            <returns>filter that selects only commits with any flag in <code>a</code>.</returns>
        </member>
        <member name="M:NGit.Revwalk.Filter.RevFlagFilter.HasAnyFilter(NGit.Revwalk.RevFlagSet)">
            <summary>Create a new filter that tests for any flag in a set.</summary>
            <remarks>Create a new filter that tests for any flag in a set.</remarks>
            <param name="a">set of flags to test.</param>
            <returns>filter that selects only commits with any flag in <code>a</code>.</returns>
        </member>
        <member name="M:NGit.Revwalk.Filter.RevFlagFilter.HasAll.Include(NGit.Revwalk.RevWalk,NGit.Revwalk.RevCommit)">
            <exception cref="T:NGit.Errors.MissingObjectException"></exception>
            <exception cref="T:NGit.Errors.IncorrectObjectTypeException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Revwalk.Filter.RevFlagFilter.HasAny.Include(NGit.Revwalk.RevWalk,NGit.Revwalk.RevCommit)">
            <exception cref="T:NGit.Errors.MissingObjectException"></exception>
            <exception cref="T:NGit.Errors.IncorrectObjectTypeException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="T:NGit.Revwalk.RevObjectListBlock">
            <summary>One level of contents, either an intermediate level or a leaf level.</summary>
            <remarks>One level of contents, either an intermediate level or a leaf level.</remarks>
        </member>
        <member name="T:NGit.Revwalk.RevFlagSet">
            <summary>
            Multiple application level mark bits for
            <see cref="T:NGit.Revwalk.RevObject">RevObject</see>
            s.
            </summary>
            <seealso cref="T:NGit.Revwalk.RevFlag">RevFlag</seealso>
        </member>
        <member name="M:NGit.Revwalk.RevFlagSet.#ctor">
            <summary>Create an empty set of flags.</summary>
            <remarks>Create an empty set of flags.</remarks>
        </member>
        <member name="M:NGit.Revwalk.RevFlagSet.#ctor(NGit.Revwalk.RevFlagSet)">
            <summary>Create a set of flags, copied from an existing set.</summary>
            <remarks>Create a set of flags, copied from an existing set.</remarks>
            <param name="s">the set to copy flags from.</param>
        </member>
        <member name="M:NGit.Revwalk.RevFlagSet.#ctor(System.Collections.Generic.ICollection{NGit.Revwalk.RevFlag})">
            <summary>Create a set of flags, copied from an existing collection.</summary>
            <remarks>Create a set of flags, copied from an existing collection.</remarks>
            <param name="s">the collection to copy flags from.</param>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Revwalk.PendingGenerator" -->
        <!-- Badly formed XML comment ignored for member "F:NGit.Revwalk.PendingGenerator.OVER_SCAN" -->
        <member name="F:NGit.Revwalk.PendingGenerator.INIT_LAST">
            <summary>
            A commit near the end of time, to initialize
            <see cref="F:NGit.Revwalk.PendingGenerator.last">last</see>
            with.
            </summary>
        </member>
        <member name="F:NGit.Revwalk.PendingGenerator.last">
            <summary>
            Last commit produced to the caller from
            <see cref="M:NGit.Revwalk.PendingGenerator.Next">Next()</see>
            .
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:NGit.Revwalk.PendingGenerator.overScan" -->
        <member name="M:NGit.Revwalk.PendingGenerator.Next">
            <exception cref="T:NGit.Errors.MissingObjectException"></exception>
            <exception cref="T:NGit.Errors.IncorrectObjectTypeException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="T:NGit.Events.ConfigChangedListener">
            <summary>
            Receives
            <see cref="T:NGit.Events.ConfigChangedEvent">ConfigChangedEvent</see>
            s.
            </summary>
        </member>
        <member name="M:NGit.Events.ConfigChangedListener.OnConfigChanged(NGit.Events.ConfigChangedEvent)">
            <summary>Invoked when any change is made to the configuration.</summary>
            <remarks>Invoked when any change is made to the configuration.</remarks>
            <param name="event">information about the changes.</param>
        </member>
        <member name="T:NGit.Errors.EntryExistsException">
            <summary>Attempt to add an entry to a tree that already exists.</summary>
            <remarks>Attempt to add an entry to a tree that already exists.</remarks>
        </member>
        <member name="M:NGit.Errors.EntryExistsException.#ctor(System.String)">
            <summary>
            Construct an EntryExistsException when the specified name already
            exists in a tree.
            </summary>
            <remarks>
            Construct an EntryExistsException when the specified name already
            exists in a tree.
            </remarks>
            <param name="name">workdir relative file name</param>
        </member>
        <member name="T:NGit.Dircache.DirCacheCheckout">
            <summary>This class handles checking out one or two trees merging with the index.
            	</summary>
            <remarks>This class handles checking out one or two trees merging with the index.
            	</remarks>
        </member>
        <member name="M:NGit.Dircache.DirCacheCheckout.GetUpdated">
            <returns>a list of updated paths and objectIds</returns>
        </member>
        <member name="M:NGit.Dircache.DirCacheCheckout.GetConflicts">
            <returns>a list of conflicts created by this checkout</returns>
        </member>
        <member name="M:NGit.Dircache.DirCacheCheckout.GetToBeDeleted">
            <returns>
            a list of paths (relative to the start of the working tree) of
            files which couldn't be deleted during last call to
            <see cref="M:NGit.Dircache.DirCacheCheckout.Checkout">Checkout()</see>
            .
            <see cref="M:NGit.Dircache.DirCacheCheckout.Checkout">Checkout()</see>
            detected that these
            files should be deleted but the deletion in the filesystem failed
            (e.g. because a file was locked). To have a consistent state of
            the working tree these files have to be deleted by the callers of
            <see cref="T:NGit.Dircache.DirCacheCheckout">DirCacheCheckout</see>
            .
            </returns>
        </member>
        <member name="M:NGit.Dircache.DirCacheCheckout.GetRemoved">
            <returns>a list of all files removed by this checkout</returns>
        </member>
        <member name="M:NGit.Dircache.DirCacheCheckout.#ctor(NGit.Repository,NGit.ObjectId,NGit.Dircache.DirCache,NGit.ObjectId,NGit.Treewalk.WorkingTreeIterator)">
            <summary>
            Constructs a DirCacheCeckout for merging and checking out two trees (HEAD
            and mergeCommitTree) and the index.
            </summary>
            <remarks>
            Constructs a DirCacheCeckout for merging and checking out two trees (HEAD
            and mergeCommitTree) and the index.
            </remarks>
            <param name="repo">the repository in which we do the checkout</param>
            <param name="headCommitTree">the id of the tree of the head commit</param>
            <param name="dc">the (already locked) Dircache for this repo</param>
            <param name="mergeCommitTree">the id of the tree we want to fast-forward to</param>
            <param name="workingTree">an iterator over the repositories Working Tree</param>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:NGit.Dircache.DirCacheCheckout.#ctor(NGit.Repository,NGit.ObjectId,NGit.Dircache.DirCache,NGit.ObjectId)">
            <summary>
            Constructs a DirCacheCeckout for merging and checking out two trees (HEAD
            and mergeCommitTree) and the index.
            </summary>
            <remarks>
            Constructs a DirCacheCeckout for merging and checking out two trees (HEAD
            and mergeCommitTree) and the index. As iterator over the working tree
            this constructor creates a standard
            <see cref="T:NGit.Treewalk.FileTreeIterator">NGit.Treewalk.FileTreeIterator</see>
            </remarks>
            <param name="repo">the repository in which we do the checkout</param>
            <param name="headCommitTree">the id of the tree of the head commit</param>
            <param name="dc">the (already locked) Dircache for this repo</param>
            <param name="mergeCommitTree">the id of the tree we want to fast-forward to</param>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:NGit.Dircache.DirCacheCheckout.#ctor(NGit.Repository,NGit.Dircache.DirCache,NGit.ObjectId,NGit.Treewalk.WorkingTreeIterator)">
            <summary>
            Constructs a DirCacheCeckout for checking out one tree, merging with the
            index.
            </summary>
            <remarks>
            Constructs a DirCacheCeckout for checking out one tree, merging with the
            index.
            </remarks>
            <param name="repo">the repository in which we do the checkout</param>
            <param name="dc">the (already locked) Dircache for this repo</param>
            <param name="mergeCommitTree">the id of the tree we want to fast-forward to</param>
            <param name="workingTree">an iterator over the repositories Working Tree</param>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:NGit.Dircache.DirCacheCheckout.#ctor(NGit.Repository,NGit.Dircache.DirCache,NGit.ObjectId)">
            <summary>
            Constructs a DirCacheCeckout for checking out one tree, merging with the
            index.
            </summary>
            <remarks>
            Constructs a DirCacheCeckout for checking out one tree, merging with the
            index. As iterator over the working tree this constructor creates a
            standard
            <see cref="T:NGit.Treewalk.FileTreeIterator">NGit.Treewalk.FileTreeIterator</see>
            </remarks>
            <param name="repo">the repository in which we do the checkout</param>
            <param name="dc">the (already locked) Dircache for this repo</param>
            <param name="mergeCommitTree">the id of the tree of the</param>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:NGit.Dircache.DirCacheCheckout.PreScanTwoTrees">
            <summary>Scan head, index and merge tree.</summary>
            <remarks>
            Scan head, index and merge tree. Used during normal checkout or merge
            operations.
            </remarks>
            <exception cref="T:NGit.Errors.CorruptObjectException">NGit.Errors.CorruptObjectException
            	</exception>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:NGit.Dircache.DirCacheCheckout.AddTree(NGit.Treewalk.TreeWalk,NGit.ObjectId)">
            <exception cref="T:NGit.Errors.MissingObjectException"></exception>
            <exception cref="T:NGit.Errors.IncorrectObjectTypeException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Dircache.DirCacheCheckout.PrescanOneTree">
            <summary>Scan index and merge tree (no HEAD).</summary>
            <remarks>
            Scan index and merge tree (no HEAD). Used e.g. for initial checkout when
            there is no head yet.
            </remarks>
            <exception cref="T:NGit.Errors.MissingObjectException">NGit.Errors.MissingObjectException
            	</exception>
            <exception cref="T:NGit.Errors.IncorrectObjectTypeException">NGit.Errors.IncorrectObjectTypeException
            	</exception>
            <exception cref="T:NGit.Errors.CorruptObjectException">NGit.Errors.CorruptObjectException
            	</exception>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:NGit.Dircache.DirCacheCheckout.ProcessEntry(NGit.Treewalk.CanonicalTreeParser,NGit.Dircache.DirCacheBuildIterator,NGit.Treewalk.WorkingTreeIterator)">
            <summary>
            Processing an entry in the context of
            <see cref="M:NGit.Dircache.DirCacheCheckout.PrescanOneTree">PrescanOneTree()</see>
            when only
            one tree is given
            </summary>
            <param name="m">the tree to merge</param>
            <param name="i">the index</param>
            <param name="f">the working tree</param>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:NGit.Dircache.DirCacheCheckout.Checkout">
            <summary>Execute this checkout</summary>
            <returns>
            <code>false</code> if this method could not delete all the files
            which should be deleted (e.g. because of of the files was
            locked). In this case
            <see cref="M:NGit.Dircache.DirCacheCheckout.GetToBeDeleted">GetToBeDeleted()</see>
            lists the files
            which should be tried to be deleted outside of this method.
            Although <code>false</code> is returned the checkout was
            successful and the working tree was updated for all other files.
            <code>true</code> is returned when no such problem occurred
            </returns>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:NGit.Dircache.DirCacheCheckout.DoCheckout">
            <exception cref="T:NGit.Errors.CorruptObjectException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
            <exception cref="T:NGit.Errors.MissingObjectException"></exception>
            <exception cref="T:NGit.Errors.IncorrectObjectTypeException"></exception>
            <exception cref="T:NGit.Errors.CheckoutConflictException"></exception>
            <exception cref="T:NGit.Errors.IndexWriteException"></exception>
        </member>
        <member name="M:NGit.Dircache.DirCacheCheckout.EqualIdAndMode(NGit.ObjectId,NGit.FileMode,NGit.ObjectId,NGit.FileMode)">
            <summary>Compares whether two pairs of ObjectId and FileMode are equal.</summary>
            <remarks>Compares whether two pairs of ObjectId and FileMode are equal.</remarks>
            <param name="id1"></param>
            <param name="mode1"></param>
            <param name="id2"></param>
            <param name="mode2"></param>
            <returns>
            <code>true</code> if FileModes and ObjectIds are equal.
            <code>false</code> otherwise
            </returns>
        </member>
        <member name="M:NGit.Dircache.DirCacheCheckout.ProcessEntry(NGit.Treewalk.CanonicalTreeParser,NGit.Treewalk.CanonicalTreeParser,NGit.Dircache.DirCacheBuildIterator,NGit.Treewalk.WorkingTreeIterator)">
            <summary>Here the main work is done.</summary>
            <remarks>
            Here the main work is done. This method is called for each existing path
            in head, index and merge. This method decides what to do with the
            corresponding index entry: keep it, update it, remove it or mark a
            conflict.
            </remarks>
            <param name="h">the entry for the head</param>
            <param name="m">the entry for the merge</param>
            <param name="i">the entry for the index</param>
            <param name="f">the file in the working tree</param>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:NGit.Dircache.DirCacheCheckout.Conflict(System.String,NGit.Dircache.DirCacheEntry,NGit.Treewalk.AbstractTreeIterator,NGit.Treewalk.AbstractTreeIterator)">
            <summary>A conflict is detected - add the three different stages to the index</summary>
            <param name="path">the path of the conflicting entry</param>
            <param name="e">the previous index entry</param>
            <param name="h">the first tree you want to merge (the HEAD)</param>
            <param name="m">the second tree you want to merge</param>
        </member>
        <member name="M:NGit.Dircache.DirCacheCheckout.SetFailOnConflict(System.Boolean)">
            <summary>
            If <code>true</code>, will scan first to see if it's possible to check
            out, otherwise throw
            <see cref="T:NGit.Errors.CheckoutConflictException">NGit.Errors.CheckoutConflictException
            	</see>
            . If
            <code>false</code>, it will silently deal with the problem.
            </summary>
            <param name="failOnConflict"></param>
        </member>
        <member name="M:NGit.Dircache.DirCacheCheckout.CleanUpConflicts">
            <summary>
            This method implements how to handle conflicts when
            <see cref="F:NGit.Dircache.DirCacheCheckout.failOnConflict">failOnConflict</see>
            is false
            </summary>
            <exception cref="T:NGit.Errors.CheckoutConflictException">NGit.Errors.CheckoutConflictException
            	</exception>
        </member>
        <member name="M:NGit.Dircache.DirCacheCheckout.IsModified(System.String)">
            <exception cref="T:NGit.Errors.CorruptObjectException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Dircache.DirCacheCheckout.CheckoutEntry(NGit.Repository,Sharpen.FilePath,NGit.Dircache.DirCacheEntry)">
            <summary>
            Updates the file in the working tree with content and mode from an entry
            in the index.
            </summary>
            <remarks>
            Updates the file in the working tree with content and mode from an entry
            in the index. The new content is first written to a new temporary file in
            the same directory as the real file. Then that new file is renamed to the
            final filename. Use this method only for checkout of a single entry.
            Otherwise use
            <code>checkoutEntry(Repository, File f, DirCacheEntry, ObjectReader)</code>
            instead which allows to reuse one
            <code>ObjectReader</code>
            for multiple
            entries.
            <p>
            TODO: this method works directly on File IO, we may need another
            abstraction (like WorkingTreeIterator). This way we could tell e.g.
            Eclipse that Files in the workspace got changed
            </p>
            </remarks>
            <param name="repository"></param>
            <param name="f">
            the file to be modified. The parent directory for this file
            has to exist already
            </param>
            <param name="entry">the entry containing new mode and content</param>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:NGit.Dircache.DirCacheCheckout.CheckoutEntry(NGit.Repository,Sharpen.FilePath,NGit.Dircache.DirCacheEntry,NGit.ObjectReader)">
            <summary>
            Updates the file in the working tree with content and mode from an entry
            in the index.
            </summary>
            <remarks>
            Updates the file in the working tree with content and mode from an entry
            in the index. The new content is first written to a new temporary file in
            the same directory as the real file. Then that new file is renamed to the
            final filename.
            <p>
            TODO: this method works directly on File IO, we may need another
            abstraction (like WorkingTreeIterator). This way we could tell e.g.
            Eclipse that Files in the workspace got changed
            </p>
            </remarks>
            <param name="repo"></param>
            <param name="f">
            the file to be modified. The parent directory for this file
            has to exist already
            </param>
            <param name="entry">the entry containing new mode and content</param>
            <param name="or">object reader to use for checkout</param>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Repository" -->
        <member name="M:NGit.Repository.GetGlobalListenerList">
            <returns>the global listener list observing all events in this JVM.</returns>
        </member>
        <member name="F:NGit.Repository.gitDir">
            <summary>Metadata directory holding the repository's critical files.</summary>
            <remarks>Metadata directory holding the repository's critical files.</remarks>
        </member>
        <member name="F:NGit.Repository.fs">
            <summary>File abstraction used to resolve paths.</summary>
            <remarks>File abstraction used to resolve paths.</remarks>
        </member>
        <member name="F:NGit.Repository.workTree">
            <summary>If not bare, the top level directory of the working files.</summary>
            <remarks>If not bare, the top level directory of the working files.</remarks>
        </member>
        <member name="F:NGit.Repository.indexFile">
            <summary>If not bare, the index file caching the working file states.</summary>
            <remarks>If not bare, the index file caching the working file states.</remarks>
        </member>
        <member name="M:NGit.Repository.#ctor(NGit.BaseRepositoryBuilder)">
            <summary>Initialize a new repository instance.</summary>
            <remarks>Initialize a new repository instance.</remarks>
            <param name="options">options to configure the repository.</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Repository.FireEvent``1(NGit.Events.RepositoryEvent{``0})" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Repository.Create" -->
        <member name="M:NGit.Repository.Create(System.Boolean)">
            <summary>
            Create a new Git repository initializing the necessary files and
            directories.
            </summary>
            <remarks>
            Create a new Git repository initializing the necessary files and
            directories.
            </remarks>
            <param name="bare">
            if true, a bare repository (a repository without a working
            directory) is created.
            </param>
            <exception cref="T:System.IO.IOException">in case of IO problem</exception>
        </member>
        <member name="M:NGit.Repository.NewObjectInserter">
            <returns>
            a new inserter to create objects in
            <see cref="P:NGit.Repository.ObjectDatabase">ObjectDatabase()</see>
            
            </returns>
        </member>
        <member name="M:NGit.Repository.NewObjectReader">
            <returns>
            a new reader to read objects from
            <see cref="P:NGit.Repository.ObjectDatabase">ObjectDatabase()</see>
            
            </returns>
        </member>
        <member name="M:NGit.Repository.GetConfig">
            <returns>the configuration of this repository</returns>
        </member>
        <member name="M:NGit.Repository.HasObject(NGit.AnyObjectId)">
            <param name="objectId"></param>
            <returns>
            true if the specified object is stored in this repo or any of the
            known shared repositories.
            </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Repository.Open(NGit.AnyObjectId)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Repository.Open(NGit.AnyObjectId,System.Int32)" -->
        <member name="M:NGit.Repository.UpdateRef(System.String)">
            <summary>Create a command to update, create or delete a ref in this repository.</summary>
            <remarks>Create a command to update, create or delete a ref in this repository.</remarks>
            <param name="ref">name of the ref the caller wants to modify.</param>
            <returns>
            an update command. The caller must finish populating this command
            and then invoke one of the update methods to actually make a
            change.
            </returns>
            <exception cref="T:System.IO.IOException">
            a symbolic ref was passed in and could not be resolved back
            to the base ref, as the symbolic ref could not be read.
            </exception>
        </member>
        <member name="M:NGit.Repository.UpdateRef(System.String,System.Boolean)">
            <summary>Create a command to update, create or delete a ref in this repository.</summary>
            <remarks>Create a command to update, create or delete a ref in this repository.</remarks>
            <param name="ref">name of the ref the caller wants to modify.</param>
            <param name="detach">true to create a detached head</param>
            <returns>
            an update command. The caller must finish populating this command
            and then invoke one of the update methods to actually make a
            change.
            </returns>
            <exception cref="T:System.IO.IOException">
            a symbolic ref was passed in and could not be resolved back
            to the base ref, as the symbolic ref could not be read.
            </exception>
        </member>
        <member name="M:NGit.Repository.RenameRef(System.String,System.String)">
            <summary>Create a command to rename a ref in this repository</summary>
            <param name="fromRef">name of ref to rename from</param>
            <param name="toRef">name of ref to rename to</param>
            <returns>an update command that knows how to rename a branch to another.</returns>
            <exception cref="T:System.IO.IOException">the rename could not be performed.</exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Repository.Resolve(System.String)" -->
        <member name="M:NGit.Repository.Resolve(NGit.Revwalk.RevWalk,System.String)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Repository.ParseSimple(NGit.Revwalk.RevWalk,System.String)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Repository.ResolveSimple(System.String)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Repository.ResolveReflog(NGit.Revwalk.RevWalk,NGit.Ref,System.String)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Repository.ResolveAbbreviation(System.String)">
            <exception cref="T:System.IO.IOException"></exception>
            <exception cref="T:NGit.Errors.AmbiguousObjectException"></exception>
        </member>
        <member name="M:NGit.Repository.IncrementOpen">
            <summary>
            Increment the use counter by one, requiring a matched
            <see cref="M:NGit.Repository.Close">Close()</see>
            .
            </summary>
        </member>
        <member name="M:NGit.Repository.Close">
            <summary>Decrement the use count, and maybe close resources.</summary>
            <remarks>Decrement the use count, and maybe close resources.</remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Repository.DoClose" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Repository.GetFullBranch" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Repository.GetBranch" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Repository.GetAdditionalHaves" -->
        <member name="M:NGit.Repository.GetRef(System.String)">
            <summary>Get a ref by name.</summary>
            <remarks>Get a ref by name.</remarks>
            <param name="name">
            the name of the ref to lookup. May be a short-hand form, e.g.
            "master" which is is automatically expanded to
            "refs/heads/master" if "refs/heads/master" already exists.
            </param>
            <returns>the Ref with the given name, or null if it does not exist</returns>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:NGit.Repository.GetAllRefs">
            <returns>mutable map of all known refs (heads, tags, remotes).</returns>
        </member>
        <member name="M:NGit.Repository.GetTags">
            <returns>
            mutable map of all tags; key is short tag name ("v1.0") and value
            of the entry contains the ref with the full tag name
            ("refs/tags/v1.0").
            </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Repository.Peel(NGit.Ref)" -->
        <member name="M:NGit.Repository.GetAllRefsByPeeledObjectId">
            <returns>a map with all objects referenced by a peeled ref.</returns>
        </member>
        <member name="M:NGit.Repository.GetIndexFile">
            <returns>the index file location</returns>
            <exception cref="T:NGit.Errors.NoWorkTreeException">
            if this is bare, which implies it has no working directory.
            See
            <see cref="P:NGit.Repository.IsBare">IsBare()</see>
            .
            </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Repository.ReadDirCache" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Repository.LockDirCache" -->
        <member name="M:NGit.Repository.GetRepositoryState">
            <returns>an important state</returns>
        </member>
        <member name="M:NGit.Repository.IsValidRefName(System.String)">
            <summary>Check validity of a ref name.</summary>
            <remarks>
            Check validity of a ref name. It must not contain character that has
            a special meaning in a Git object reference expression. Some other
            dangerous characters are also excluded.
            For portability reasons '\' is excluded
            </remarks>
            <param name="refName"></param>
            <returns>true if refName is a valid ref name</returns>
        </member>
        <member name="M:NGit.Repository.StripWorkDir(Sharpen.FilePath,Sharpen.FilePath)">
            <summary>Strip work dir and return normalized repository path.</summary>
            <remarks>Strip work dir and return normalized repository path.</remarks>
            <param name="workDir">Work dir</param>
            <param name="file">File whose path shall be stripped of its workdir</param>
            <returns>
            normalized repository relative path or the empty
            string if the file is not relative to the work directory.
            </returns>
        </member>
        <member name="M:NGit.Repository.ScanForRepoChanges">
            <summary>Force a scan for changed refs.</summary>
            <remarks>Force a scan for changed refs.</remarks>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:NGit.Repository.NotifyIndexChanged">
            <summary>Notify that the index changed</summary>
        </member>
        <member name="M:NGit.Repository.ShortenRefName(System.String)">
            <param name="refName"></param>
            <returns>a more user friendly ref name</returns>
        </member>
        <member name="M:NGit.Repository.GetReflogReader(System.String)">
            <param name="refName"></param>
            <returns>
            a
            <see cref="T:NGit.Storage.File.ReflogReader">NGit.Storage.File.ReflogReader</see>
            for the supplied refname, or null if the
            named ref does not exist.
            </returns>
            <exception cref="T:System.IO.IOException">the ref could not be accessed.</exception>
        </member>
        <member name="M:NGit.Repository.ReadMergeCommitMsg">
            <summary>Return the information stored in the file $GIT_DIR/MERGE_MSG.</summary>
            <remarks>
            Return the information stored in the file $GIT_DIR/MERGE_MSG. In this
            file operations triggering a merge will store a template for the commit
            message of the merge commit.
            </remarks>
            <returns>
            a String containing the content of the MERGE_MSG file or
            <code>null</code>
            if this file doesn't exist
            </returns>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
            <exception cref="T:NGit.Errors.NoWorkTreeException">
            if this is bare, which implies it has no working directory.
            See
            <see cref="P:NGit.Repository.IsBare">IsBare()</see>
            .
            </exception>
        </member>
        <member name="M:NGit.Repository.WriteMergeCommitMsg(System.String)">
            <summary>Write new content to the file $GIT_DIR/MERGE_MSG.</summary>
            <remarks>
            Write new content to the file $GIT_DIR/MERGE_MSG. In this file operations
            triggering a merge will store a template for the commit message of the
            merge commit. If <code>null</code> is specified as message the file will
            be deleted.
            </remarks>
            <param name="msg">
            the message which should be written or <code>null</code> to
            delete the file
            </param>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:NGit.Repository.ReadMergeHeads">
            <summary>Return the information stored in the file $GIT_DIR/MERGE_HEAD.</summary>
            <remarks>
            Return the information stored in the file $GIT_DIR/MERGE_HEAD. In this
            file operations triggering a merge will store the IDs of all heads which
            should be merged together with HEAD.
            </remarks>
            <returns>
            a list of commits which IDs are listed in the MERGE_HEAD file or
            <code>null</code>
            if this file doesn't exist. Also if the file exists
            but is empty
            <code>null</code>
            will be returned
            </returns>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
            <exception cref="T:NGit.Errors.NoWorkTreeException">
            if this is bare, which implies it has no working directory.
            See
            <see cref="P:NGit.Repository.IsBare">IsBare()</see>
            .
            </exception>
        </member>
        <member name="M:NGit.Repository.WriteMergeHeads(System.Collections.Generic.IList{NGit.ObjectId})">
            <summary>Write new merge-heads into $GIT_DIR/MERGE_HEAD.</summary>
            <remarks>
            Write new merge-heads into $GIT_DIR/MERGE_HEAD. In this file operations
            triggering a merge will store the IDs of all heads which should be merged
            together with HEAD. If <code>null</code> is specified as list of commits
            the file will be deleted
            </remarks>
            <param name="heads">
            a list of commits which IDs should be written to
            $GIT_DIR/MERGE_HEAD or <code>null</code> to delete the file
            </param>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:NGit.Repository.ReadCherryPickHead">
            <summary>Return the information stored in the file $GIT_DIR/CHERRY_PICK_HEAD.</summary>
            <remarks>Return the information stored in the file $GIT_DIR/CHERRY_PICK_HEAD.</remarks>
            <returns>
            object id from CHERRY_PICK_HEAD file or
            <code>null</code>
            if this file
            doesn't exist. Also if the file exists but is empty
            <code>null</code>
            will be returned
            </returns>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
            <exception cref="T:NGit.Errors.NoWorkTreeException">
            if this is bare, which implies it has no working directory.
            See
            <see cref="P:NGit.Repository.IsBare">IsBare()</see>
            .
            </exception>
        </member>
        <member name="M:NGit.Repository.WriteCherryPickHead(NGit.ObjectId)">
            <summary>Write cherry pick commit into $GIT_DIR/CHERRY_PICK_HEAD.</summary>
            <remarks>
            Write cherry pick commit into $GIT_DIR/CHERRY_PICK_HEAD. This is used in
            case of conflicts to store the cherry which was tried to be picked.
            </remarks>
            <param name="head">
            an object id of the cherry commit or <code>null</code> to
            delete the file
            </param>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:NGit.Repository.WriteOrigHead(NGit.ObjectId)">
            <summary>Write original HEAD commit into $GIT_DIR/ORIG_HEAD.</summary>
            <remarks>Write original HEAD commit into $GIT_DIR/ORIG_HEAD.</remarks>
            <param name="head">
            an object id of the original HEAD commit or <code>null</code>
            to delete the file
            </param>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:NGit.Repository.ReadOrigHead">
            <summary>Return the information stored in the file $GIT_DIR/ORIG_HEAD.</summary>
            <remarks>Return the information stored in the file $GIT_DIR/ORIG_HEAD.</remarks>
            <returns>
            object id from ORIG_HEAD file or
            <code>null</code>
            if this file
            doesn't exist. Also if the file exists but is empty
            <code>null</code>
            will be returned
            </returns>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
            <exception cref="T:NGit.Errors.NoWorkTreeException">
            if this is bare, which implies it has no working directory.
            See
            <see cref="P:NGit.Repository.IsBare">IsBare()</see>
            .
            </exception>
        </member>
        <member name="M:NGit.Repository.ReadSquashCommitMsg">
            <summary>Return the information stored in the file $GIT_DIR/SQUASH_MSG.</summary>
            <remarks>
            Return the information stored in the file $GIT_DIR/SQUASH_MSG. In this
            file operations triggering a squashed merge will store a template for the
            commit message of the squash commit.
            </remarks>
            <returns>
            a String containing the content of the SQUASH_MSG file or
            <code>null</code>
            if this file doesn't exist
            </returns>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
            <exception cref="T:NGit.Errors.NoWorkTreeException">
            if this is bare, which implies it has no working directory.
            See
            <see cref="P:NGit.Repository.IsBare">IsBare()</see>
            .
            </exception>
        </member>
        <member name="M:NGit.Repository.WriteSquashCommitMsg(System.String)">
            <summary>Write new content to the file $GIT_DIR/SQUASH_MSG.</summary>
            <remarks>
            Write new content to the file $GIT_DIR/SQUASH_MSG. In this file
            operations triggering a squashed merge will store a template for the
            commit message of the squash commit. If <code>null</code> is specified as
            message the file will be deleted.
            </remarks>
            <param name="msg">
            the message which should be written or <code>null</code> to
            delete the file
            </param>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:NGit.Repository.ReadCommitMsgFile(System.String)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Repository.WriteCommitMsg(Sharpen.FilePath,System.String)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Repository.ReadGitDirectoryFile(System.String)">
            <summary>Read a file from the git directory.</summary>
            <remarks>Read a file from the git directory.</remarks>
            <param name="filename"></param>
            <returns>the raw contents or null if the file doesn't exist or is empty</returns>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:NGit.Repository.WriteHeadsFile(System.Collections.Generic.IList{NGit.ObjectId},System.String)">
            <summary>Write the given heads to a file in the git directory.</summary>
            <remarks>Write the given heads to a file in the git directory.</remarks>
            <param name="heads">
            a list of object ids to write or null if the file should be
            deleted.
            </param>
            <param name="filename"></param>
            <exception cref="T:System.IO.FileNotFoundException">System.IO.FileNotFoundException
            	</exception>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="P:NGit.Repository.Listeners">
            <returns>listeners observing only events on this repository.</returns>
        </member>
        <member name="P:NGit.Repository.Directory">
            <returns>local metadata directory; null if repository isn't local.</returns>
        </member>
        <member name="P:NGit.Repository.ObjectDatabase">
            <returns>the object database which stores this repository's data.</returns>
        </member>
        <member name="P:NGit.Repository.RefDatabase">
            <returns>the reference database which stores the reference namespace.</returns>
        </member>
        <member name="P:NGit.Repository.FileSystem">
            <returns>the used file system abstraction</returns>
        </member>
        <member name="P:NGit.Repository.IsBare">
            <returns>true if this is bare, which implies it has no working directory.</returns>
        </member>
        <member name="P:NGit.Repository.WorkTree">
            <returns>
            the root directory of the working tree, where files are checked
            out for viewing and editing.
            </returns>
            <exception cref="T:NGit.Errors.NoWorkTreeException">
            if this is bare, which implies it has no working directory.
            See
            <see cref="P:NGit.Repository.IsBare">IsBare()</see>
            .
            </exception>
        </member>
        <member name="T:NGit.Events.IndexChangedListener">
            <summary>
            Receives
            <see cref="T:NGit.Events.IndexChangedEvent">IndexChangedEvent</see>
            s.
            </summary>
        </member>
        <member name="M:NGit.Events.IndexChangedListener.OnIndexChanged(NGit.Events.IndexChangedEvent)">
            <summary>Invoked when any change is made to the index.</summary>
            <remarks>Invoked when any change is made to the index.</remarks>
            <param name="event">information about the changes.</param>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Blame.Candidate" -->
        <member name="F:NGit.Blame.Candidate.queueNext">
            <summary>Next candidate in the candidate queue.</summary>
            <remarks>Next candidate in the candidate queue.</remarks>
        </member>
        <member name="F:NGit.Blame.Candidate.sourceCommit">
            <summary>Commit being considered (or blamed, depending on state).</summary>
            <remarks>Commit being considered (or blamed, depending on state).</remarks>
        </member>
        <member name="F:NGit.Blame.Candidate.sourcePath">
            <summary>
            Path of the candidate file in
            <see cref="F:NGit.Blame.Candidate.sourceCommit">sourceCommit</see>
            .
            </summary>
        </member>
        <member name="F:NGit.Blame.Candidate.sourceBlob">
            <summary>
            Unique name of the candidate blob in
            <see cref="F:NGit.Blame.Candidate.sourceCommit">sourceCommit</see>
            .
            </summary>
        </member>
        <member name="F:NGit.Blame.Candidate.sourceText">
            <summary>
            Complete contents of the file in
            <see cref="F:NGit.Blame.Candidate.sourceCommit">sourceCommit</see>
            .
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:NGit.Blame.Candidate.regionList" -->
        <!-- Badly formed XML comment ignored for member "F:NGit.Blame.Candidate.renameScore" -->
        <member name="M:NGit.Blame.Candidate.LoadText(NGit.ObjectReader)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Blame.Candidate.ReverseCandidate" -->
        <!-- Badly formed XML comment ignored for member "T:NGit.Blame.Candidate.BlobCandidate" -->
        <!-- Badly formed XML comment ignored for member "F:NGit.Blame.Candidate.BlobCandidate.parent" -->
        <member name="F:NGit.Blame.Candidate.BlobCandidate.description">
            <summary>Author name to refer to this blob with.</summary>
            <remarks>Author name to refer to this blob with.</remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Merge.MergeMessageFormatter" -->
        <member name="M:NGit.Merge.MergeMessageFormatter.Format(System.Collections.Generic.IList{NGit.Ref},NGit.Ref)">
            <summary>Construct the merge commit message.</summary>
            <remarks>Construct the merge commit message.</remarks>
            <param name="refsToMerge">the refs which will be merged</param>
            <param name="target">the branch ref which will be merged into</param>
            <returns>merge commit message</returns>
        </member>
        <member name="M:NGit.Merge.MergeMessageFormatter.FormatWithConflicts(System.String,System.Collections.Generic.IList{System.String})">
            <summary>Add section with conflicting paths to merge message.</summary>
            <remarks>Add section with conflicting paths to merge message.</remarks>
            <param name="message">the original merge message</param>
            <param name="conflictingPaths">the paths with conflicts</param>
            <returns>merge message with conflicting paths added</returns>
        </member>
        <member name="T:NGit.Api.Errors.InvalidConfigurationException">
            <summary>Exception thrown when a command fails due to an invalid configuration</summary>
        </member>
        <member name="M:NGit.Api.Errors.InvalidConfigurationException.#ctor(System.String,System.Exception)">
            <param name="message"></param>
            <param name="cause"></param>
        </member>
        <member name="M:NGit.Api.Errors.InvalidConfigurationException.#ctor(System.String)">
            <param name="message"></param>
        </member>
        <member name="T:NGit.Api.Errors.CanceledException">
            <summary>Exception thrown when an operation was canceled</summary>
        </member>
        <member name="M:NGit.Api.Errors.CanceledException.#ctor(System.String)">
            <param name="message"></param>
        </member>
        <member name="T:NGit.Diff.RawTextComparator">
            <summary>
            Equivalence function for
            <see cref="T:NGit.Diff.RawText">RawText</see>
            .
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Diff.SequenceComparator`1" -->
        <member name="M:NGit.Diff.SequenceComparator`1.Equals(`0,System.Int32,`0,System.Int32)">
            <summary>Compare two items to determine if they are equivalent.</summary>
            <remarks>
            Compare two items to determine if they are equivalent.
            It is permissible to compare sequence
            <code>a</code>
            with itself (by passing
            <code>a</code>
            again in position
            <code>b</code>
            ).
            </remarks>
            <param name="a">the first sequence.</param>
            <param name="ai">
            item of
            <code>ai</code>
            to compare.
            </param>
            <param name="b">the second sequence.</param>
            <param name="bi">
            item of
            <code>bi</code>
            to compare.
            </param>
            <returns>
            true if the two items are identical according to this function's
            equivalence rule.
            </returns>
        </member>
        <member name="M:NGit.Diff.SequenceComparator`1.Hash(`0,System.Int32)">
            <summary>Get a hash value for an item in a sequence.</summary>
            <remarks>
            Get a hash value for an item in a sequence.
            If two items are equal according to this comparator's
            <see cref="!:SequenceComparator&lt;S&gt;.Equals(Sequence, int, Sequence, int)">SequenceComparator&lt;S&gt;.Equals(Sequence, int, Sequence, int)
            	</see>
            method, then this hash
            method must produce the same integer result for both items.
            It is not required for two items to have different hash values if they
            are are unequal according to the
            <code>equals()</code>
            method.
            </remarks>
            <param name="seq">the sequence.</param>
            <param name="ptr">the item to obtain the hash for.</param>
            <returns>hash the hash value.</returns>
        </member>
        <member name="M:NGit.Diff.SequenceComparator`1.ReduceCommonStartEnd(`0,`0,NGit.Diff.Edit)">
            <summary>Modify the edit to remove common leading and trailing items.</summary>
            <remarks>
            Modify the edit to remove common leading and trailing items.
            The supplied edit
            <code>e</code>
            is reduced in size by moving the beginning A
            and B points so the edit does not cover any items that are in common
            between the two sequences. The ending A and B points are also shifted to
            remove common items from the end of the region.
            </remarks>
            <param name="a">the first sequence.</param>
            <param name="b">the second sequence.</param>
            <param name="e">the edit to start with and update.</param>
            <returns>
            
            <code>e</code>
            if it was updated in-place, otherwise a new edit
            containing the reduced region.
            </returns>
        </member>
        <member name="F:NGit.Diff.RawTextComparator.DEFAULT">
            <summary>No special treatment.</summary>
            <remarks>No special treatment.</remarks>
        </member>
        <member name="F:NGit.Diff.RawTextComparator.WS_IGNORE_ALL">
            <summary>Ignores all whitespace.</summary>
            <remarks>Ignores all whitespace.</remarks>
        </member>
        <member name="F:NGit.Diff.RawTextComparator.WS_IGNORE_LEADING">
            <summary>Ignores leading whitespace.</summary>
            <remarks>Ignores leading whitespace.</remarks>
        </member>
        <member name="F:NGit.Diff.RawTextComparator.WS_IGNORE_TRAILING">
            <summary>Ignores trailing whitespace.</summary>
            <remarks>Ignores trailing whitespace.</remarks>
        </member>
        <member name="F:NGit.Diff.RawTextComparator.WS_IGNORE_CHANGE">
            <summary>Ignores whitespace occurring between non-whitespace characters.</summary>
            <remarks>Ignores whitespace occurring between non-whitespace characters.</remarks>
        </member>
        <member name="M:NGit.Diff.RawTextComparator.HashRegion(System.Byte[],System.Int32,System.Int32)">
            <summary>Compute a hash code for a region.</summary>
            <remarks>Compute a hash code for a region.</remarks>
            <param name="raw">the raw file content.</param>
            <param name="ptr">first byte of the region to hash.</param>
            <param name="end">1 past the last byte of the region.</param>
            <returns>hash code for the region <code>[ptr, end)</code> of raw.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Diff.HashedSequence`1" -->
        <!-- Badly formed XML comment ignored for member "T:NGit.Transport.TransportGitAnon" -->
        <member name="M:NGit.Transport.TransportGitAnon.OpenFetch">
            <exception cref="T:NGit.Errors.TransportException"></exception>
        </member>
        <member name="M:NGit.Transport.TransportGitAnon.OpenPush">
            <exception cref="T:NGit.Errors.TransportException"></exception>
        </member>
        <member name="M:NGit.Transport.TransportGitAnon.OpenConnection">
            <exception cref="T:NGit.Errors.TransportException"></exception>
        </member>
        <member name="M:NGit.Transport.TransportGitAnon.Service(System.String,NGit.Transport.PacketLineOut)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Transport.TransportGitAnon._TransportProtocol_77.Open(NGit.Transport.URIish,NGit.Repository,System.String)">
            <exception cref="T:System.NotSupportedException"></exception>
        </member>
        <member name="M:NGit.Transport.TransportGitAnon.TcpFetchConnection.#ctor(NGit.Transport.TransportGitAnon)">
            <exception cref="T:NGit.Errors.TransportException"></exception>
        </member>
        <member name="M:NGit.Transport.TransportGitAnon.TcpPushConnection.#ctor(NGit.Transport.TransportGitAnon)">
            <exception cref="T:NGit.Errors.TransportException"></exception>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Transport.PacketLineIn" -->
        <member name="F:NGit.Transport.PacketLineIn.END">
            <summary>
            Magic return from
            <see cref="M:NGit.Transport.PacketLineIn.ReadString">ReadString()</see>
            when a flush packet is found.
            </summary>
        </member>
        <member name="M:NGit.Transport.PacketLineIn.#ctor(Sharpen.InputStream)">
            <summary>Create a new packet line reader.</summary>
            <remarks>Create a new packet line reader.</remarks>
            <param name="i">the input stream to consume.</param>
        </member>
        <member name="M:NGit.Transport.PacketLineIn.ReadACK(NGit.MutableObjectId)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Transport.PacketLineIn.ReadString" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Transport.PacketLineIn.ReadStringRaw" -->
        <member name="M:NGit.Transport.PacketLineIn.ReadLength">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Transport.LongMap`1" -->
        <member name="F:NGit.Transport.LongMap`1.size">
            <summary>Number of entries currently in the map.</summary>
            <remarks>Number of entries currently in the map.</remarks>
        </member>
        <member name="F:NGit.Transport.LongMap`1.growAt">
            <summary>
            Next
            <see cref="F:NGit.Transport.LongMap`1.size">LongMap&lt;V&gt;.size</see>
            to trigger a
            <see cref="M:NGit.Transport.LongMap`1.Grow">LongMap&lt;V&gt;.Grow()</see>
            .
            </summary>
        </member>
        <member name="T:NGit.Util.IO.StreamCopyThread">
            <summary>Thread to copy from an input stream to an output stream.</summary>
            <remarks>Thread to copy from an input stream to an output stream.</remarks>
        </member>
        <member name="M:NGit.Util.IO.StreamCopyThread.#ctor(Sharpen.InputStream,Sharpen.OutputStream)">
            <summary>Create a thread to copy data from an input stream to an output stream.</summary>
            <remarks>Create a thread to copy data from an input stream to an output stream.</remarks>
            <param name="i">
            stream to copy from. The thread terminates when this stream
            reaches EOF. The thread closes this stream before it exits.
            </param>
            <param name="o">
            stream to copy into. The destination stream is automatically
            closed when the thread terminates.
            </param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Util.IO.StreamCopyThread.Flush" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Util.IO.StreamCopyThread.Halt" -->
        <!-- Badly formed XML comment ignored for member "T:NGit.Treewalk.Filter.PathFilter" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Treewalk.Filter.PathFilter.Create(System.String)" -->
        <member name="M:NGit.Treewalk.Filter.PathFilter.GetPath">
            <returns>the path this filter matches.</returns>
        </member>
        <member name="M:NGit.Treewalk.Filter.PathFilter.IsDone(NGit.Treewalk.TreeWalk)">
            <param name="walker">The walk to check against.</param>
            <returns>
            
            <code>true</code>
            if the path length of this filter matches the length
            of the current path of the supplied TreeWalk.
            </returns>
        </member>
        <member name="T:NGit.Treewalk.EmptyTreeIterator">
            <summary>Iterator over an empty tree (a directory with no files).</summary>
            <remarks>Iterator over an empty tree (a directory with no files).</remarks>
        </member>
        <member name="M:NGit.Treewalk.EmptyTreeIterator.#ctor">
            <summary>Create a new iterator with no parent.</summary>
            <remarks>Create a new iterator with no parent.</remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Treewalk.EmptyTreeIterator.#ctor(NGit.Treewalk.AbstractTreeIterator,System.Byte[],System.Int32)" -->
        <member name="M:NGit.Treewalk.EmptyTreeIterator.CreateSubtreeIterator(NGit.ObjectReader)">
            <exception cref="T:NGit.Errors.IncorrectObjectTypeException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Treewalk.EmptyTreeIterator.Next(System.Int32)">
            <exception cref="T:NGit.Errors.CorruptObjectException"></exception>
        </member>
        <member name="M:NGit.Treewalk.EmptyTreeIterator.Back(System.Int32)">
            <exception cref="T:NGit.Errors.CorruptObjectException"></exception>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Storage.File.RefDirectoryRename" -->
        <!-- Badly formed XML comment ignored for member "T:NGit.RefRename" -->
        <member name="F:NGit.RefRename.source">
            <summary>Update operation to read and delete the source reference.</summary>
            <remarks>Update operation to read and delete the source reference.</remarks>
        </member>
        <member name="F:NGit.RefRename.destination">
            <summary>Update operation to create/overwrite the destination reference.</summary>
            <remarks>Update operation to create/overwrite the destination reference.</remarks>
        </member>
        <member name="M:NGit.RefRename.#ctor(NGit.RefUpdate,NGit.RefUpdate)">
            <summary>Initialize a new rename operation.</summary>
            <remarks>Initialize a new rename operation.</remarks>
            <param name="src">operation to read and delete the source.</param>
            <param name="dst">operation to create (or overwrite) the destination.</param>
        </member>
        <member name="M:NGit.RefRename.GetRefLogIdent">
            <returns>identity of the user making the change in the reflog.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.RefRename.SetRefLogIdent(NGit.PersonIdent)" -->
        <member name="M:NGit.RefRename.GetRefLogMessage">
            <summary>Get the message to include in the reflog.</summary>
            <remarks>Get the message to include in the reflog.</remarks>
            <returns>
            message the caller wants to include in the reflog; null if the
            rename should not be logged.
            </returns>
        </member>
        <member name="M:NGit.RefRename.SetRefLogMessage(System.String)">
            <summary>Set the message to include in the reflog.</summary>
            <remarks>Set the message to include in the reflog.</remarks>
            <param name="msg">the message to describe this change.</param>
        </member>
        <member name="M:NGit.RefRename.DisableRefLog">
            <summary>Don't record this rename in the ref's associated reflog.</summary>
            <remarks>Don't record this rename in the ref's associated reflog.</remarks>
        </member>
        <member name="M:NGit.RefRename.GetResult">
            <returns>result of rename operation</returns>
        </member>
        <member name="M:NGit.RefRename.Rename">
            <returns>the result of the new ref update</returns>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:NGit.RefRename.DoRename">
            <returns>the result of the rename operation.</returns>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:NGit.RefRename.NeedToUpdateHEAD">
            <returns>
            true if the
            <code>Constants#HEAD</code>
            reference needs to be linked
            to the new destination name.
            </returns>
            <exception cref="T:System.IO.IOException">
            the current value of
            <code>HEAD</code>
            cannot be read.
            </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "F:NGit.Storage.File.RefDirectoryRename.objId" -->
        <member name="F:NGit.Storage.File.RefDirectoryRename.updateHEAD">
            <summary>True if HEAD must be moved to the destination reference.</summary>
            <remarks>True if HEAD must be moved to the destination reference.</remarks>
        </member>
        <member name="F:NGit.Storage.File.RefDirectoryRename.tmp">
            <summary>
            A reference we backup
            <see cref="F:NGit.Storage.File.RefDirectoryRename.objId">objId</see>
            into during the rename.
            </summary>
        </member>
        <member name="M:NGit.Storage.File.RefDirectoryRename.DoRename">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Revwalk.ObjectWalk" -->
        <!-- Badly formed XML comment ignored for member "F:NGit.Revwalk.ObjectWalk.IN_PENDING" -->
        <member name="M:NGit.Revwalk.ObjectWalk.#ctor(NGit.Repository)">
            <summary>Create a new revision and object walker for a given repository.</summary>
            <remarks>Create a new revision and object walker for a given repository.</remarks>
            <param name="repo">the repository the walker will obtain data from.</param>
        </member>
        <member name="M:NGit.Revwalk.ObjectWalk.#ctor(NGit.ObjectReader)">
            <summary>Create a new revision and object walker for a given repository.</summary>
            <remarks>Create a new revision and object walker for a given repository.</remarks>
            <param name="or">
            the reader the walker will obtain data from. The reader should
            be released by the caller when the walker is no longer
            required.
            </param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Revwalk.ObjectWalk.MarkStart(NGit.Revwalk.RevObject)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Revwalk.ObjectWalk.MarkUninteresting(NGit.Revwalk.RevObject)" -->
        <member name="M:NGit.Revwalk.ObjectWalk.Next">
            <exception cref="T:NGit.Errors.MissingObjectException"></exception>
            <exception cref="T:NGit.Errors.IncorrectObjectTypeException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Revwalk.ObjectWalk.NextObject">
            <summary>Pop the next most recent object.</summary>
            <remarks>Pop the next most recent object.</remarks>
            <returns>next most recent object; null if traversal is over.</returns>
            <exception cref="T:NGit.Errors.MissingObjectException">
            one or or more of the next objects are not available from the
            object database, but were thought to be candidates for
            traversal. This usually indicates a broken link.
            </exception>
            <exception cref="T:NGit.Errors.IncorrectObjectTypeException">
            one or or more of the objects in a tree do not match the type
            indicated.
            </exception>
            <exception cref="T:System.IO.IOException">a pack file or loose object could not be read.
            	</exception>
        </member>
        <member name="M:NGit.Revwalk.ObjectWalk.EnterTree(NGit.Revwalk.RevObject)">
            <exception cref="T:NGit.Errors.MissingObjectException"></exception>
            <exception cref="T:NGit.Errors.IncorrectObjectTypeException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Revwalk.ObjectWalk.CheckConnectivity" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Revwalk.ObjectWalk.GetPathString" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Revwalk.ObjectWalk.GetPathHashCode" -->
        <member name="M:NGit.Revwalk.ObjectWalk.GetPathBuffer">
            <returns>the internal buffer holding the current path.</returns>
        </member>
        <member name="M:NGit.Revwalk.ObjectWalk.GetPathLength">
            <returns>
            length of the path in
            <see cref="M:NGit.Revwalk.ObjectWalk.GetPathBuffer">GetPathBuffer()</see>
            .
            </returns>
        </member>
        <member name="M:NGit.Revwalk.ObjectWalk.MarkTreeUninteresting(NGit.Revwalk.RevTree)">
            <exception cref="T:NGit.Errors.MissingObjectException"></exception>
            <exception cref="T:NGit.Errors.IncorrectObjectTypeException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Revwalk.ObjectWalk.NewTreeVisit(NGit.Revwalk.RevObject)">
            <exception cref="T:NGit.Errors.LargeObjectException"></exception>
            <exception cref="T:NGit.Errors.MissingObjectException"></exception>
            <exception cref="T:NGit.Errors.IncorrectObjectTypeException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="F:NGit.Revwalk.ObjectWalk.TreeVisit.parent">
            <summary>Parent tree visit that entered this tree, null if root tree.</summary>
            <remarks>Parent tree visit that entered this tree, null if root tree.</remarks>
        </member>
        <member name="F:NGit.Revwalk.ObjectWalk.TreeVisit.obj">
            <summary>The RevTree currently being iterated through.</summary>
            <remarks>The RevTree currently being iterated through.</remarks>
        </member>
        <member name="F:NGit.Revwalk.ObjectWalk.TreeVisit.buf">
            <summary>
            Canonical encoding of the tree named by
            <see cref="F:NGit.Revwalk.ObjectWalk.TreeVisit.obj">obj</see>
            .
            </summary>
        </member>
        <member name="F:NGit.Revwalk.ObjectWalk.TreeVisit.ptr">
            <summary>
            Index of next entry to parse in
            <see cref="F:NGit.Revwalk.ObjectWalk.TreeVisit.buf">buf</see>
            .
            </summary>
        </member>
        <member name="F:NGit.Revwalk.ObjectWalk.TreeVisit.namePtr">
            <summary>
            Start of the current name entry in
            <see cref="F:NGit.Revwalk.ObjectWalk.TreeVisit.buf">buf</see>
            .
            </summary>
        </member>
        <member name="F:NGit.Revwalk.ObjectWalk.TreeVisit.nameEnd">
            <summary>
            One past end of name,
            <code>nameEnd - namePtr</code>
            is the length.
            </summary>
        </member>
        <member name="F:NGit.Revwalk.ObjectWalk.TreeVisit.pathLen">
            <summary>Number of bytes in the path leading up to this tree.</summary>
            <remarks>Number of bytes in the path leading up to this tree.</remarks>
        </member>
        <member name="T:NGit.Patch.CombinedHunkHeader">
            <summary>Hunk header for a hunk appearing in a "diff --cc" style patch.</summary>
            <remarks>Hunk header for a hunk appearing in a "diff --cc" style patch.</remarks>
        </member>
        <member name="M:NGit.Patch.CombinedHunkHeader.GetOldImage(System.Int32)">
            <summary>Get the OldImage data related to the nth ancestor</summary>
            <param name="nthParent">the ancestor to get the old image data of</param>
            <returns>image data of the requested ancestor.</returns>
        </member>
        <member name="M:NGit.Patch.CombinedHunkHeader.ExtractFileLines(Sharpen.OutputStream[])">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Merge.StrategySimpleTwoWayInCore" -->
        <member name="M:NGit.Merge.StrategySimpleTwoWayInCore.#ctor">
            <summary>Create a new instance of the strategy.</summary>
            <remarks>Create a new instance of the strategy.</remarks>
        </member>
        <member name="M:NGit.Merge.StrategySimpleTwoWayInCore.InCoreMerger.MergeImpl">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Merge.StrategySimpleTwoWayInCore.InCoreMerger.Add(System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="T:NGit.Events.ListenerHandle">
            <summary>
            Tracks a previously registered
            <see cref="T:NGit.Events.RepositoryListener">RepositoryListener</see>
            .
            </summary>
        </member>
        <member name="M:NGit.Events.ListenerHandle.Remove">
            <summary>Remove the listener and stop receiving events.</summary>
            <remarks>Remove the listener and stop receiving events.</remarks>
        </member>
        <member name="T:NGit.Errors.PackInvalidException">
            <summary>Thrown when a PackFile previously failed and is known to be unusable</summary>
        </member>
        <member name="M:NGit.Errors.PackInvalidException.#ctor(Sharpen.FilePath)">
            <summary>Construct a pack invalid error.</summary>
            <remarks>Construct a pack invalid error.</remarks>
            <param name="path">path of the invalid pack file.</param>
        </member>
        <member name="M:NGit.Errors.PackInvalidException.#ctor(System.String)">
            <summary>Construct a pack invalid error.</summary>
            <remarks>Construct a pack invalid error.</remarks>
            <param name="path">path of the invalid pack file.</param>
        </member>
        <member name="T:NGit.MutableObjectId">
            <summary>A mutable SHA-1 abstraction.</summary>
            <remarks>A mutable SHA-1 abstraction.</remarks>
        </member>
        <member name="M:NGit.MutableObjectId.#ctor">
            <summary>Empty constructor.</summary>
            <remarks>Empty constructor. Initialize object with default (zeros) value.</remarks>
        </member>
        <member name="M:NGit.MutableObjectId.#ctor(NGit.MutableObjectId)">
            <summary>Copying constructor.</summary>
            <remarks>Copying constructor.</remarks>
            <param name="src">original entry, to copy id from</param>
        </member>
        <member name="M:NGit.MutableObjectId.SetByte(System.Int32,System.Int32)">
            <summary>Set any byte in the id.</summary>
            <remarks>Set any byte in the id.</remarks>
            <param name="index">
            index of the byte to set in the raw form of the ObjectId. Must
            be in range [0,
            <see cref="F:NGit.Constants.OBJECT_ID_LENGTH">Constants.OBJECT_ID_LENGTH</see>
            ).
            </param>
            <param name="value">
            the value of the specified byte at
            <code>index</code>
            . Values are
            unsigned and thus are in the range [0,255] rather than the
            signed byte range of [-128, 127].
            </param>
            <exception cref="T:System.IndexOutOfRangeException">
            <code>index</code>
            is less than 0, equal to
            <see cref="F:NGit.Constants.OBJECT_ID_LENGTH">Constants.OBJECT_ID_LENGTH</see>
            , or greater than
            <see cref="F:NGit.Constants.OBJECT_ID_LENGTH">Constants.OBJECT_ID_LENGTH</see>
            .
            </exception>
        </member>
        <member name="M:NGit.MutableObjectId.Clear">
            <summary>
            Make this id match
            <see cref="P:NGit.ObjectId.ZeroId">ObjectId.ZeroId()</see>
            .
            </summary>
        </member>
        <member name="M:NGit.MutableObjectId.FromObjectId(NGit.AnyObjectId)">
            <summary>Copy an ObjectId into this mutable buffer.</summary>
            <remarks>Copy an ObjectId into this mutable buffer.</remarks>
            <param name="src">the source id to copy from.</param>
        </member>
        <member name="M:NGit.MutableObjectId.FromRaw(System.Byte[])">
            <summary>Convert an ObjectId from raw binary representation.</summary>
            <remarks>Convert an ObjectId from raw binary representation.</remarks>
            <param name="bs">
            the raw byte buffer to read from. At least 20 bytes must be
            available within this byte array.
            </param>
        </member>
        <member name="M:NGit.MutableObjectId.FromRaw(System.Byte[],System.Int32)">
            <summary>Convert an ObjectId from raw binary representation.</summary>
            <remarks>Convert an ObjectId from raw binary representation.</remarks>
            <param name="bs">
            the raw byte buffer to read from. At least 20 bytes after p
            must be available within this byte array.
            </param>
            <param name="p">position to read the first byte of data from.</param>
        </member>
        <member name="M:NGit.MutableObjectId.FromRaw(System.Int32[])">
            <summary>Convert an ObjectId from binary representation expressed in integers.</summary>
            <remarks>Convert an ObjectId from binary representation expressed in integers.</remarks>
            <param name="ints">
            the raw int buffer to read from. At least 5 integers must be
            available within this integers array.
            </param>
        </member>
        <member name="M:NGit.MutableObjectId.FromRaw(System.Int32[],System.Int32)">
            <summary>Convert an ObjectId from binary representation expressed in integers.</summary>
            <remarks>Convert an ObjectId from binary representation expressed in integers.</remarks>
            <param name="ints">
            the raw int buffer to read from. At least 5 integers after p
            must be available within this integers array.
            </param>
            <param name="p">position to read the first integer of data from.</param>
        </member>
        <member name="M:NGit.MutableObjectId.FromString(System.Byte[],System.Int32)">
            <summary>Convert an ObjectId from hex characters (US-ASCII).</summary>
            <remarks>Convert an ObjectId from hex characters (US-ASCII).</remarks>
            <param name="buf">
            the US-ASCII buffer to read from. At least 40 bytes after
            offset must be available within this byte array.
            </param>
            <param name="offset">position to read the first character from.</param>
        </member>
        <member name="M:NGit.MutableObjectId.FromString(System.String)">
            <summary>Convert an ObjectId from hex characters.</summary>
            <remarks>Convert an ObjectId from hex characters.</remarks>
            <param name="str">the string to read from. Must be 40 characters long.</param>
        </member>
        <member name="T:NGit.ConfigLine">
            <summary>
            A line in a Git
            <see cref="T:NGit.Config">Config</see>
            file.
            </summary>
        </member>
        <member name="F:NGit.ConfigLine.prefix">
            <summary>The text content before entry.</summary>
            <remarks>The text content before entry.</remarks>
        </member>
        <member name="F:NGit.ConfigLine.section">
            <summary>The section name for the entry.</summary>
            <remarks>The section name for the entry.</remarks>
        </member>
        <member name="F:NGit.ConfigLine.subsection">
            <summary>Subsection name.</summary>
            <remarks>Subsection name.</remarks>
        </member>
        <member name="F:NGit.ConfigLine.name">
            <summary>The key name.</summary>
            <remarks>The key name.</remarks>
        </member>
        <member name="F:NGit.ConfigLine.value">
            <summary>The value.</summary>
            <remarks>The value.</remarks>
        </member>
        <member name="F:NGit.ConfigLine.suffix">
            <summary>The text content after entry.</summary>
            <remarks>The text content after entry.</remarks>
        </member>
        <member name="T:NGit.Util.IO.NullOutputStream">
            <summary>An OutputStream which ignores everything written to it.</summary>
            <remarks>An OutputStream which ignores everything written to it.</remarks>
        </member>
        <member name="F:NGit.Util.IO.NullOutputStream.INSTANCE">
            <summary>The canonical instance.</summary>
            <remarks>The canonical instance.</remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Api.AddNoteCommand" -->
        <member name="M:NGit.Api.AddNoteCommand.#ctor(NGit.Repository)">
            <param name="repo"></param>
        </member>
        <member name="M:NGit.Api.AddNoteCommand.Call">
            <exception cref="T:NGit.Api.Errors.GitAPIException"></exception>
        </member>
        <member name="M:NGit.Api.AddNoteCommand.SetObjectId(NGit.Revwalk.RevObject)">
            <summary>Sets the object id of object you want a note on.</summary>
            <remarks>
            Sets the object id of object you want a note on. If the object already
            has a note, the existing note will be replaced.
            </remarks>
            <param name="id"></param>
            <returns>
            
            <code>this</code>
            </returns>
        </member>
        <member name="M:NGit.Api.AddNoteCommand.SetMessage(System.String)">
            <param name="message">the notes message used when adding a note</param>
            <returns>
            
            <code>this</code>
            </returns>
        </member>
        <member name="M:NGit.Api.AddNoteCommand.CommitNoteMap(NGit.Revwalk.RevWalk,NGit.Notes.NoteMap,NGit.Revwalk.RevCommit,NGit.ObjectInserter,System.String)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Api.AddNoteCommand.SetNotesRef(System.String)">
            <param name="notesRef">
            the ref to read notes from. Note, the default value of
            <see cref="F:NGit.Constants.R_NOTES_COMMITS">NGit.Constants.R_NOTES_COMMITS</see>
            will be used if nothing is
            set
            </param>
            <returns>
            
            <code>this</code>
            </returns>
            <seealso cref="F:NGit.Constants.R_NOTES_COMMITS">NGit.Constants.R_NOTES_COMMITS</seealso>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Transport.JschSession" -->
        <!-- Badly formed XML comment ignored for member "T:NGit.Transport.RemoteSession" -->
        <member name="M:NGit.Transport.RemoteSession.Exec(System.String,System.Int32)">
            <summary>Generate a new remote process to execute the given command.</summary>
            <remarks>
            Generate a new remote process to execute the given command. This function
            should also start execution and may need to create the streams prior to
            execution.
            </remarks>
            <param name="commandName">command to execute</param>
            <param name="timeout">timeout value, in seconds, for command execution</param>
            <returns>a new remote process</returns>
            <exception cref="T:System.IO.IOException">
            may be thrown in several cases. For example, on problems
            opening input or output streams or on problems connecting or
            communicating with the remote host. For the latter two cases,
            a TransportException may be thrown (a subclass of
            IOException).
            </exception>
        </member>
        <member name="M:NGit.Transport.RemoteSession.Disconnect">
            <summary>Disconnect the remote session</summary>
        </member>
        <member name="M:NGit.Transport.JschSession.#ctor(NSch.Session,NGit.Transport.URIish)">
            <summary>
            Create a new session object by passing the real Jsch session and the URI
            information.
            </summary>
            <remarks>
            Create a new session object by passing the real Jsch session and the URI
            information.
            </remarks>
            <param name="session">the real Jsch session created elsewhere.</param>
            <param name="uri">the URI information for the remote connection</param>
        </member>
        <member name="M:NGit.Transport.JschSession.Exec(System.String,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Transport.JschSession.GetSftpChannel">
            <summary>
            A kludge to allow
            <see cref="T:NGit.Transport.TransportSftp">TransportSftp</see>
            to get an Sftp channel from Jsch.
            Ideally, this method would be generic, which would require implementing
            generic Sftp channel operations in the RemoteSession class.
            </summary>
            <returns>a channel suitable for Sftp operations.</returns>
            <exception cref="T:NSch.JSchException">on problems getting the channel.</exception>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Transport.JschSession.JschProcess" -->
        <member name="M:NGit.Transport.JschSession.JschProcess.#ctor(NGit.Transport.JschSession,System.String,System.Int32)">
            <summary>
            Opens a channel on the session ("sock") for executing the given
            command, opens streams, and starts command execution.
            </summary>
            <remarks>
            Opens a channel on the session ("sock") for executing the given
            command, opens streams, and starts command execution.
            </remarks>
            <param name="commandName">the command to execute</param>
            <param name="tms">the timeout value, in seconds, for the command.</param>
            <exception cref="T:NGit.Errors.TransportException">
            on problems opening a channel or connecting to the remote
            host
            </exception>
            <exception cref="T:System.IO.IOException">on problems opening streams</exception>
        </member>
        <member name="M:NGit.Transport.JschSession.JschProcess.SetupStreams">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Transport.JschSession.JschProcess.WaitFor">
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:NGit.Transport.JschSession.JschProcess._PipedOutputStream_173.Flush">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Transport.JschSession.JschProcess._PipedOutputStream_173.Close">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="T:NGit.Util.FileUtils">
            <summary>File Utilities</summary>
        </member>
        <member name="F:NGit.Util.FileUtils.NONE">
            <summary>
            Option to delete given
            <code>File</code>
            </summary>
        </member>
        <member name="F:NGit.Util.FileUtils.RECURSIVE">
            <summary>
            Option to recursively delete given
            <code>File</code>
            </summary>
        </member>
        <member name="F:NGit.Util.FileUtils.RETRY">
            <summary>Option to retry deletion if not successful</summary>
        </member>
        <member name="F:NGit.Util.FileUtils.SKIP_MISSING">
            <summary>Option to skip deletion if file doesn't exist</summary>
        </member>
        <member name="F:NGit.Util.FileUtils.IGNORE_ERRORS">
            <summary>Option not to throw exceptions when a deletion finally doesn't succeed.</summary>
            <remarks>Option not to throw exceptions when a deletion finally doesn't succeed.</remarks>
            <since>2.0</since>
        </member>
        <member name="M:NGit.Util.FileUtils.Delete(Sharpen.FilePath)">
            <summary>Delete file or empty folder</summary>
            <param name="f">
            <code>File</code>
            to be deleted
            </param>
            <exception cref="T:System.IO.IOException">
            if deletion of
            <code>f</code>
            fails. This may occur if
            <code>f</code>
            didn't exist when the method was called. This can therefore
            cause IOExceptions during race conditions when multiple
            concurrent threads all try to delete the same file.
            </exception>
        </member>
        <member name="M:NGit.Util.FileUtils.Delete(Sharpen.FilePath,System.Int32)">
            <summary>Delete file or folder</summary>
            <param name="f">
            <code>File</code>
            to be deleted
            </param>
            <param name="options">
            deletion options,
            <code>RECURSIVE</code>
            for recursive deletion of
            a subtree,
            <code>RETRY</code>
            to retry when deletion failed.
            Retrying may help if the underlying file system doesn't allow
            deletion of files being read by another thread.
            </param>
            <exception cref="T:System.IO.IOException">
            if deletion of
            <code>f</code>
            fails. This may occur if
            <code>f</code>
            didn't exist when the method was called. This can therefore
            cause IOExceptions during race conditions when multiple
            concurrent threads all try to delete the same file. This
            exception is not thrown when IGNORE_ERRORS is set.
            </exception>
        </member>
        <member name="M:NGit.Util.FileUtils.Mkdir(Sharpen.FilePath)">
            <summary>Creates the directory named by this abstract pathname.</summary>
            <remarks>Creates the directory named by this abstract pathname.</remarks>
            <param name="d">directory to be created</param>
            <exception cref="T:System.IO.IOException">
            if creation of
            <code>d</code>
            fails. This may occur if
            <code>d</code>
            did exist when the method was called. This can therefore
            cause IOExceptions during race conditions when multiple
            concurrent threads all try to create the same directory.
            </exception>
        </member>
        <member name="M:NGit.Util.FileUtils.Mkdir(Sharpen.FilePath,System.Boolean)">
            <summary>Creates the directory named by this abstract pathname.</summary>
            <remarks>Creates the directory named by this abstract pathname.</remarks>
            <param name="d">directory to be created</param>
            <param name="skipExisting">
            if
            <code>true</code>
            skip creation of the given directory if it
            already exists in the file system
            </param>
            <exception cref="T:System.IO.IOException">
            if creation of
            <code>d</code>
            fails. This may occur if
            <code>d</code>
            did exist when the method was called. This can therefore
            cause IOExceptions during race conditions when multiple
            concurrent threads all try to create the same directory.
            </exception>
        </member>
        <member name="M:NGit.Util.FileUtils.Mkdirs(Sharpen.FilePath)">
            <summary>
            Creates the directory named by this abstract pathname, including any
            necessary but nonexistent parent directories.
            </summary>
            <remarks>
            Creates the directory named by this abstract pathname, including any
            necessary but nonexistent parent directories. Note that if this operation
            fails it may have succeeded in creating some of the necessary parent
            directories.
            </remarks>
            <param name="d">directory to be created</param>
            <exception cref="T:System.IO.IOException">
            if creation of
            <code>d</code>
            fails. This may occur if
            <code>d</code>
            did exist when the method was called. This can therefore
            cause IOExceptions during race conditions when multiple
            concurrent threads all try to create the same directory.
            </exception>
        </member>
        <member name="M:NGit.Util.FileUtils.Mkdirs(Sharpen.FilePath,System.Boolean)">
            <summary>
            Creates the directory named by this abstract pathname, including any
            necessary but nonexistent parent directories.
            </summary>
            <remarks>
            Creates the directory named by this abstract pathname, including any
            necessary but nonexistent parent directories. Note that if this operation
            fails it may have succeeded in creating some of the necessary parent
            directories.
            </remarks>
            <param name="d">directory to be created</param>
            <param name="skipExisting">
            if
            <code>true</code>
            skip creation of the given directory if it
            already exists in the file system
            </param>
            <exception cref="T:System.IO.IOException">
            if creation of
            <code>d</code>
            fails. This may occur if
            <code>d</code>
            did exist when the method was called. This can therefore
            cause IOExceptions during race conditions when multiple
            concurrent threads all try to create the same directory.
            </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Util.FileUtils.CreateNewFile(Sharpen.FilePath)" -->
        <member name="T:NGit.Transport.CredentialItem">
            <summary>
            A credential requested from a
            <see cref="T:NGit.Transport.CredentialsProvider">CredentialsProvider</see>
            .
            Most users should work with the specialized subclasses:
            <ul>
            <li>
            <see cref="T:NGit.Transport.CredentialItem.Username">Username</see>
            for usernames</li>
            <li>
            <see cref="T:NGit.Transport.CredentialItem.Password">Password</see>
            for passwords</li>
            <li>
            <see cref="T:NGit.Transport.CredentialItem.StringType">StringType</see>
            for other general string information</li>
            <li>
            <see cref="T:NGit.Transport.CredentialItem.CharArrayType">CharArrayType</see>
            for other general secret information</li>
            </ul>
            This class is not thread-safe. Applications should construct their own
            instance for each use, as the value is held within the CredentialItem object.
            </summary>
        </member>
        <member name="M:NGit.Transport.CredentialItem.#ctor(System.String,System.Boolean)">
            <summary>Initialize a prompt.</summary>
            <remarks>Initialize a prompt.</remarks>
            <param name="promptText">
            prompt to display to the user alongside of the input field.
            Should be sufficient text to indicate what to supply for this
            item.
            </param>
            <param name="maskValue">
            true if the value should be masked from displaying during
            input. This should be true for passwords and other secrets,
            false for names and other public data.
            </param>
        </member>
        <member name="M:NGit.Transport.CredentialItem.GetPromptText">
            <returns>prompt to display to the user.</returns>
        </member>
        <member name="M:NGit.Transport.CredentialItem.IsValueSecure">
            <returns>true if the value should be masked when entered.</returns>
        </member>
        <member name="M:NGit.Transport.CredentialItem.Clear">
            <summary>Clear the stored value, destroying it as much as possible.</summary>
            <remarks>Clear the stored value, destroying it as much as possible.</remarks>
        </member>
        <member name="T:NGit.Transport.CredentialItem.StringType">
            <summary>An item whose value is stored as a string.</summary>
            <remarks>
            An item whose value is stored as a string.
            When working with secret data, consider
            <see cref="T:NGit.Transport.CredentialItem.CharArrayType">CharArrayType</see>
            instead, as
            the internal members of the array can be cleared, reducing the chances
            that the password is left in memory after authentication is completed.
            </remarks>
        </member>
        <member name="M:NGit.Transport.CredentialItem.StringType.#ctor(System.String,System.Boolean)">
            <summary>Initialize a prompt for a single string.</summary>
            <remarks>Initialize a prompt for a single string.</remarks>
            <param name="promptText">
            prompt to display to the user alongside of the input
            field. Should be sufficient text to indicate what to
            supply for this item.
            </param>
            <param name="maskValue">
            true if the value should be masked from displaying during
            input. This should be true for passwords and other
            secrets, false for names and other public data.
            </param>
        </member>
        <member name="M:NGit.Transport.CredentialItem.StringType.GetValue">
            <returns>the current value</returns>
        </member>
        <member name="M:NGit.Transport.CredentialItem.StringType.SetValue(System.String)">
            <param name="newValue"></param>
        </member>
        <member name="T:NGit.Transport.CredentialItem.CharArrayType">
            <summary>An item whose value is stored as a char[] and is therefore clearable.</summary>
            <remarks>An item whose value is stored as a char[] and is therefore clearable.</remarks>
        </member>
        <member name="M:NGit.Transport.CredentialItem.CharArrayType.#ctor(System.String,System.Boolean)">
            <summary>Initialize a prompt for a secure value stored in a character array.</summary>
            <remarks>Initialize a prompt for a secure value stored in a character array.</remarks>
            <param name="promptText">
            prompt to display to the user alongside of the input
            field. Should be sufficient text to indicate what to
            supply for this item.
            </param>
            <param name="maskValue">
            true if the value should be masked from displaying during
            input. This should be true for passwords and other
            secrets, false for names and other public data.
            </param>
        </member>
        <member name="M:NGit.Transport.CredentialItem.CharArrayType.Clear">
            <summary>Destroys the current value, clearing the internal array.</summary>
            <remarks>Destroys the current value, clearing the internal array.</remarks>
        </member>
        <member name="M:NGit.Transport.CredentialItem.CharArrayType.GetValue">
            <summary>Get the current value.</summary>
            <remarks>
            Get the current value.
            The returned array will be cleared out when
            <see cref="M:NGit.Transport.CredentialItem.CharArrayType.Clear">Clear()</see>
            is
            called. Callers that need the array elements to survive should delay
            invoking
            <code>clear()</code>
            until the value is no longer necessary.
            </remarks>
            <returns>
            the current value array. The actual internal array is
            returned, reducing the number of copies present in memory.
            </returns>
        </member>
        <member name="M:NGit.Transport.CredentialItem.CharArrayType.SetValue(System.Char[])">
            <summary>Set the new value, clearing the old value array.</summary>
            <remarks>Set the new value, clearing the old value array.</remarks>
            <param name="newValue">if not null, the array is copied.</param>
        </member>
        <member name="M:NGit.Transport.CredentialItem.CharArrayType.SetValueNoCopy(System.Char[])">
            <summary>Set the new value, clearing the old value array.</summary>
            <remarks>Set the new value, clearing the old value array.</remarks>
            <param name="newValue">the new internal array. The array is <b>NOT</b> copied.</param>
        </member>
        <member name="T:NGit.Transport.CredentialItem.YesNoType">
            <summary>An item whose value is a boolean choice, presented as Yes/No.</summary>
            <remarks>An item whose value is a boolean choice, presented as Yes/No.</remarks>
        </member>
        <member name="M:NGit.Transport.CredentialItem.YesNoType.#ctor(System.String)">
            <summary>Initialize a prompt for a single boolean answer.</summary>
            <remarks>Initialize a prompt for a single boolean answer.</remarks>
            <param name="promptText">
            prompt to display to the user alongside of the input
            field. Should be sufficient text to indicate what to
            supply for this item.
            </param>
        </member>
        <member name="M:NGit.Transport.CredentialItem.YesNoType.GetValue">
            <returns>the current value</returns>
        </member>
        <member name="M:NGit.Transport.CredentialItem.YesNoType.SetValue(System.Boolean)">
            <summary>Set the new value.</summary>
            <remarks>Set the new value.</remarks>
            <param name="newValue"></param>
        </member>
        <member name="T:NGit.Transport.CredentialItem.InformationalMessage">
            <summary>An advice message presented to the user, with no response required.</summary>
            <remarks>An advice message presented to the user, with no response required.</remarks>
        </member>
        <member name="M:NGit.Transport.CredentialItem.InformationalMessage.#ctor(System.String)">
            <summary>Initialize an informational message.</summary>
            <remarks>Initialize an informational message.</remarks>
            <param name="messageText">message to display to the user.</param>
        </member>
        <member name="T:NGit.Transport.CredentialItem.Username">
            <summary>Prompt for a username, which is not masked on input.</summary>
            <remarks>Prompt for a username, which is not masked on input.</remarks>
        </member>
        <member name="M:NGit.Transport.CredentialItem.Username.#ctor">
            <summary>Initialize a new username item, with a default username prompt.</summary>
            <remarks>Initialize a new username item, with a default username prompt.</remarks>
        </member>
        <member name="T:NGit.Transport.CredentialItem.Password">
            <summary>Prompt for a password, which is masked on input.</summary>
            <remarks>Prompt for a password, which is masked on input.</remarks>
        </member>
        <member name="M:NGit.Transport.CredentialItem.Password.#ctor">
            <summary>Initialize a new password item, with a default password prompt.</summary>
            <remarks>Initialize a new password item, with a default password prompt.</remarks>
        </member>
        <member name="M:NGit.Transport.CredentialItem.Password.#ctor(System.String)">
            <summary>Initialize a new password item, with given prompt.</summary>
            <remarks>Initialize a new password item, with given prompt.</remarks>
            <param name="msg">prompt message</param>
        </member>
        <member name="T:NGit.Api.Errors.DetachedHeadException">
            <summary>
            Exception thrown when a command expected a non-detached
            <code>HEAD</code>
            reference
            </summary>
        </member>
        <member name="M:NGit.Api.Errors.DetachedHeadException.#ctor">
            <summary>The default constructor with a default message</summary>
        </member>
        <member name="M:NGit.Api.Errors.DetachedHeadException.#ctor(System.String,System.Exception)">
            <param name="message"></param>
            <param name="cause"></param>
        </member>
        <member name="M:NGit.Api.Errors.DetachedHeadException.#ctor(System.String)">
            <param name="message"></param>
        </member>
        <member name="M:NGit.Transport.FetchHeadRecord.Write(System.IO.TextWriter)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="T:NGit.Util.IO.DisabledOutputStream">
            <summary>An OutputStream which always throws IllegalStateExeption during write.</summary>
            <remarks>An OutputStream which always throws IllegalStateExeption during write.</remarks>
        </member>
        <member name="F:NGit.Util.IO.DisabledOutputStream.INSTANCE">
            <summary>The canonical instance which always throws IllegalStateException.</summary>
            <remarks>The canonical instance which always throws IllegalStateException.</remarks>
        </member>
        <member name="M:NGit.Util.IO.DisabledOutputStream.Write(System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Util.RawSubStringPattern" -->
        <member name="M:NGit.Util.RawSubStringPattern.#ctor(System.String)">
            <summary>Construct a new substring pattern.</summary>
            <remarks>Construct a new substring pattern.</remarks>
            <param name="patternText">
            text to locate. This should be a literal string, as no
            meta-characters are supported by this implementation. The
            string may not be the empty string.
            </param>
        </member>
        <member name="M:NGit.Util.RawSubStringPattern.Match(NGit.Util.RawCharSequence)">
            <summary>Match a character sequence against this pattern.</summary>
            <remarks>Match a character sequence against this pattern.</remarks>
            <param name="rcs">
            the sequence to match. Must not be null but the length of the
            sequence is permitted to be 0.
            </param>
            <returns>
            offset within <code>rcs</code> of the first occurrence of this
            pattern; -1 if this pattern does not appear at any position of
            <code>rcs</code>.
            </returns>
        </member>
        <member name="M:NGit.Util.RawSubStringPattern.Pattern">
            <summary>Get the literal pattern string this instance searches for.</summary>
            <remarks>Get the literal pattern string this instance searches for.</remarks>
            <returns>the pattern string given to our constructor.</returns>
        </member>
        <member name="T:NGit.Util.NB">
            <summary>Conversion utilities for network byte order handling.</summary>
            <remarks>Conversion utilities for network byte order handling.</remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Util.NB.CompareUInt32(System.Int32,System.Int32)" -->
        <member name="M:NGit.Util.NB.DecodeUInt16(System.Byte[],System.Int32)">
            <summary>Convert sequence of 2 bytes (network byte order) into unsigned value.</summary>
            <remarks>Convert sequence of 2 bytes (network byte order) into unsigned value.</remarks>
            <param name="intbuf">buffer to acquire the 2 bytes of data from.</param>
            <param name="offset">
            position within the buffer to begin reading from. This
            position and the next byte after it (for a total of 2 bytes)
            will be read.
            </param>
            <returns>unsigned integer value that matches the 16 bits read.</returns>
        </member>
        <member name="M:NGit.Util.NB.DecodeInt32(System.Byte[],System.Int32)">
            <summary>Convert sequence of 4 bytes (network byte order) into signed value.</summary>
            <remarks>Convert sequence of 4 bytes (network byte order) into signed value.</remarks>
            <param name="intbuf">buffer to acquire the 4 bytes of data from.</param>
            <param name="offset">
            position within the buffer to begin reading from. This
            position and the next 3 bytes after it (for a total of 4
            bytes) will be read.
            </param>
            <returns>signed integer value that matches the 32 bits read.</returns>
        </member>
        <member name="M:NGit.Util.NB.DecodeUInt32(System.Byte[],System.Int32)">
            <summary>Convert sequence of 4 bytes (network byte order) into unsigned value.</summary>
            <remarks>Convert sequence of 4 bytes (network byte order) into unsigned value.</remarks>
            <param name="intbuf">buffer to acquire the 4 bytes of data from.</param>
            <param name="offset">
            position within the buffer to begin reading from. This
            position and the next 3 bytes after it (for a total of 4
            bytes) will be read.
            </param>
            <returns>unsigned integer value that matches the 32 bits read.</returns>
        </member>
        <member name="M:NGit.Util.NB.DecodeUInt64(System.Byte[],System.Int32)">
            <summary>Convert sequence of 8 bytes (network byte order) into unsigned value.</summary>
            <remarks>Convert sequence of 8 bytes (network byte order) into unsigned value.</remarks>
            <param name="intbuf">buffer to acquire the 8 bytes of data from.</param>
            <param name="offset">
            position within the buffer to begin reading from. This
            position and the next 7 bytes after it (for a total of 8
            bytes) will be read.
            </param>
            <returns>unsigned integer value that matches the 64 bits read.</returns>
        </member>
        <member name="M:NGit.Util.NB.EncodeInt16(System.Byte[],System.Int32,System.Int32)">
            <summary>Write a 16 bit integer as a sequence of 2 bytes (network byte order).</summary>
            <remarks>Write a 16 bit integer as a sequence of 2 bytes (network byte order).</remarks>
            <param name="intbuf">buffer to write the 2 bytes of data into.</param>
            <param name="offset">
            position within the buffer to begin writing to. This position
            and the next byte after it (for a total of 2 bytes) will be
            replaced.
            </param>
            <param name="v">the value to write.</param>
        </member>
        <member name="M:NGit.Util.NB.EncodeInt32(System.Byte[],System.Int32,System.Int32)">
            <summary>Write a 32 bit integer as a sequence of 4 bytes (network byte order).</summary>
            <remarks>Write a 32 bit integer as a sequence of 4 bytes (network byte order).</remarks>
            <param name="intbuf">buffer to write the 4 bytes of data into.</param>
            <param name="offset">
            position within the buffer to begin writing to. This position
            and the next 3 bytes after it (for a total of 4 bytes) will be
            replaced.
            </param>
            <param name="v">the value to write.</param>
        </member>
        <member name="M:NGit.Util.NB.EncodeInt64(System.Byte[],System.Int32,System.Int64)">
            <summary>Write a 64 bit integer as a sequence of 8 bytes (network byte order).</summary>
            <remarks>Write a 64 bit integer as a sequence of 8 bytes (network byte order).</remarks>
            <param name="intbuf">buffer to write the 48bytes of data into.</param>
            <param name="offset">
            position within the buffer to begin writing to. This position
            and the next 7 bytes after it (for a total of 8 bytes) will be
            replaced.
            </param>
            <param name="v">the value to write.</param>
        </member>
        <member name="T:NGit.Treewalk.Filter.SkipWorkTreeFilter">
            <summary>
            To be used in combination with a DirCacheIterator: includes only tree entries
            for which 'skipWorkTree' flag is not set.
            </summary>
            <remarks>
            To be used in combination with a DirCacheIterator: includes only tree entries
            for which 'skipWorkTree' flag is not set.
            </remarks>
        </member>
        <member name="F:NGit.Treewalk.Filter.SkipWorkTreeFilter.treeIdx">
            <summary>Index of DirCacheIterator to work on.</summary>
            <remarks>Index of DirCacheIterator to work on.</remarks>
        </member>
        <member name="M:NGit.Treewalk.Filter.SkipWorkTreeFilter.#ctor(System.Int32)">
            <summary>Create a filter to work on the specified DirCacheIterator.</summary>
            <remarks>Create a filter to work on the specified DirCacheIterator.</remarks>
            <param name="treeIdx">
            index of DirCacheIterator to work on. If the index does not
            refer to a DirCacheIterator, the filter will include all
            entries.
            </param>
        </member>
        <member name="F:NGit.Storage.Pack.DeltaWindow.maxMemory">
            <summary>Maximum number of bytes to admit to the window at once.</summary>
            <remarks>Maximum number of bytes to admit to the window at once.</remarks>
        </member>
        <member name="F:NGit.Storage.Pack.DeltaWindow.maxDepth">
            <summary>Maximum depth we should create for any delta chain.</summary>
            <remarks>Maximum depth we should create for any delta chain.</remarks>
        </member>
        <member name="F:NGit.Storage.Pack.DeltaWindow.loaded">
            <summary>Amount of memory we have loaded right now.</summary>
            <remarks>Amount of memory we have loaded right now.</remarks>
        </member>
        <member name="F:NGit.Storage.Pack.DeltaWindow.resSlot">
            <summary>
            Position of
            <see cref="F:NGit.Storage.Pack.DeltaWindow.res">res</see>
            within
            <see cref="F:NGit.Storage.Pack.DeltaWindow.window">window</see>
            array.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:NGit.Storage.Pack.DeltaWindow.resMaxDepth" -->
        <member name="F:NGit.Storage.Pack.DeltaWindow.res">
            <summary>Window entry of the object we are currently considering.</summary>
            <remarks>Window entry of the object we are currently considering.</remarks>
        </member>
        <member name="F:NGit.Storage.Pack.DeltaWindow.bestDelta">
            <summary>
            If we have a delta for
            <see cref="F:NGit.Storage.Pack.DeltaWindow.res">res</see>
            , this is the shortest found yet.
            </summary>
        </member>
        <member name="F:NGit.Storage.Pack.DeltaWindow.bestSlot">
            <summary>
            If we have
            <see cref="F:NGit.Storage.Pack.DeltaWindow.bestDelta">bestDelta</see>
            , the window position it was created by.
            </summary>
        </member>
        <member name="F:NGit.Storage.Pack.DeltaWindow.deflater">
            <summary>Used to compress cached deltas.</summary>
            <remarks>Used to compress cached deltas.</remarks>
        </member>
        <member name="M:NGit.Storage.Pack.DeltaWindow.Search(NGit.ProgressMonitor,NGit.Storage.Pack.ObjectToPack[],System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.Pack.DeltaWindow.Search">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.Pack.DeltaWindow.Delta(NGit.Storage.Pack.DeltaWindowEntry,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.Pack.DeltaWindow.Index(NGit.Storage.Pack.DeltaWindowEntry)">
            <exception cref="T:NGit.Errors.MissingObjectException"></exception>
            <exception cref="T:NGit.Errors.IncorrectObjectTypeException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
            <exception cref="T:NGit.Errors.LargeObjectException"></exception>
        </member>
        <member name="M:NGit.Storage.Pack.DeltaWindow.Buffer(NGit.Storage.Pack.DeltaWindowEntry)">
            <exception cref="T:NGit.Errors.MissingObjectException"></exception>
            <exception cref="T:NGit.Errors.IncorrectObjectTypeException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
            <exception cref="T:NGit.Errors.LargeObjectException"></exception>
        </member>
        <member name="M:NGit.Storage.Pack.DeltaWindow.ZipStream.Finish">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.Pack.DeltaWindow.ZipStream.Write(System.Byte[],System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.Pack.DeltaWindow.ZipStream.Write(System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="T:NGit.Storage.File.WindowCacheConfig">
            <summary>
            Configuration parameters for
            <see cref="T:NGit.Storage.File.WindowCache">WindowCache</see>
            .
            </summary>
        </member>
        <member name="F:NGit.Storage.File.WindowCacheConfig.KB">
            <summary>1024 (number of bytes in one kibibyte/kilobyte)</summary>
        </member>
        <member name="F:NGit.Storage.File.WindowCacheConfig.MB">
            <summary>
            1024
            <see cref="F:NGit.Storage.File.WindowCacheConfig.KB">KB</see>
            (number of bytes in one mebibyte/megabyte)
            </summary>
        </member>
        <member name="M:NGit.Storage.File.WindowCacheConfig.#ctor">
            <summary>Create a default configuration.</summary>
            <remarks>Create a default configuration.</remarks>
        </member>
        <member name="M:NGit.Storage.File.WindowCacheConfig.GetPackedGitOpenFiles">
            <returns>
            maximum number of streams to open at a time. Open packs count
            against the process limits. <b>Default is 128.</b>
            </returns>
        </member>
        <member name="M:NGit.Storage.File.WindowCacheConfig.SetPackedGitOpenFiles(System.Int32)">
            <param name="fdLimit">
            maximum number of streams to open at a time. Open packs count
            against the process limits
            </param>
        </member>
        <member name="M:NGit.Storage.File.WindowCacheConfig.GetPackedGitLimit">
            <returns>
            maximum number bytes of heap memory to dedicate to caching pack
            file data. <b>Default is 10 MB.</b>
            </returns>
        </member>
        <member name="M:NGit.Storage.File.WindowCacheConfig.SetPackedGitLimit(System.Int64)">
            <param name="newLimit">
            maximum number bytes of heap memory to dedicate to caching
            pack file data.
            </param>
        </member>
        <member name="M:NGit.Storage.File.WindowCacheConfig.GetPackedGitWindowSize">
            <returns>
            size in bytes of a single window mapped or read in from the pack
            file. <b>Default is 8 KB.</b>
            </returns>
        </member>
        <member name="M:NGit.Storage.File.WindowCacheConfig.SetPackedGitWindowSize(System.Int32)">
            <param name="newSize">size in bytes of a single window read in from the pack file.
            	</param>
        </member>
        <member name="M:NGit.Storage.File.WindowCacheConfig.IsPackedGitMMAP">
            <returns>
            true enables use of Java NIO virtual memory mapping for windows;
            false reads entire window into a byte[] with standard read calls.
            <b>Default false.</b>
            </returns>
        </member>
        <member name="M:NGit.Storage.File.WindowCacheConfig.SetPackedGitMMAP(System.Boolean)">
            <param name="usemmap">
            true enables use of Java NIO virtual memory mapping for
            windows; false reads entire window into a byte[] with standard
            read calls.
            </param>
        </member>
        <member name="M:NGit.Storage.File.WindowCacheConfig.GetDeltaBaseCacheLimit">
            <returns>
            maximum number of bytes to cache in
            <see cref="T:NGit.Storage.File.DeltaBaseCache">DeltaBaseCache</see>
            for inflated, recently accessed objects, without delta chains.
            <b>Default 10 MB.</b>
            </returns>
        </member>
        <member name="M:NGit.Storage.File.WindowCacheConfig.SetDeltaBaseCacheLimit(System.Int32)">
            <param name="newLimit">
            maximum number of bytes to cache in
            <see cref="T:NGit.Storage.File.DeltaBaseCache">DeltaBaseCache</see>
            for inflated, recently accessed
            objects, without delta chains.
            </param>
        </member>
        <member name="M:NGit.Storage.File.WindowCacheConfig.GetStreamFileThreshold">
            <returns>the size threshold beyond which objects must be streamed.</returns>
        </member>
        <member name="M:NGit.Storage.File.WindowCacheConfig.SetStreamFileThreshold(System.Int32)">
            <param name="newLimit">
            new byte limit for objects that must be streamed. Objects
            smaller than this size can be obtained as a contiguous byte
            array, while objects bigger than this size require using an
            <see cref="T:NGit.ObjectStream">NGit.ObjectStream</see>
            .
            </param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Storage.File.WindowCacheConfig.FromConfig(NGit.Config)" -->
        <member name="M:NGit.Storage.File.PackInputStream.#ctor(NGit.Storage.File.PackFile,System.Int64,NGit.Storage.File.WindowCursor)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.PackInputStream.Read(System.Byte[],System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.PackInputStream.Read">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Storage.File.FileRepositoryBuilder" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Storage.File.FileRepositoryBuilder.Build" -->
        <member name="T:NGit.Revwalk.Filter.AuthorRevFilter">
            <summary>Matches only commits whose author name matches the pattern.</summary>
            <remarks>Matches only commits whose author name matches the pattern.</remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Revwalk.Filter.AuthorRevFilter.Create(System.String)" -->
        <member name="T:NGit.Revwalk.Filter.PatternMatchRevFilter">
            <summary>Abstract filter that searches text using extended regular expressions.</summary>
            <remarks>Abstract filter that searches text using extended regular expressions.</remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Revwalk.Filter.PatternMatchRevFilter.ForceToRaw(System.String)" -->
        <member name="M:NGit.Revwalk.Filter.PatternMatchRevFilter.#ctor(System.String,System.Boolean,System.Boolean,System.Int32)">
            <summary>Construct a new pattern matching filter.</summary>
            <remarks>Construct a new pattern matching filter.</remarks>
            <param name="pattern">
            text of the pattern. Callers may want to surround their
            pattern with ".*" on either end to allow matching in the
            middle of the string.
            </param>
            <param name="innerString">
            should .* be wrapped around the pattern of ^ and $ are
            missing? Most users will want this set.
            </param>
            <param name="rawEncoding">
            should
            <see cref="M:NGit.Revwalk.Filter.PatternMatchRevFilter.ForceToRaw(System.String)">ForceToRaw(string)</see>
            be applied to the pattern
            before compiling it?
            </param>
            <param name="flags">
            flags from
            <see cref="T:Sharpen.Pattern">Sharpen.Pattern</see>
            to control how matching performs.
            </param>
        </member>
        <member name="M:NGit.Revwalk.Filter.PatternMatchRevFilter.Pattern">
            <summary>Get the pattern this filter uses.</summary>
            <remarks>Get the pattern this filter uses.</remarks>
            <returns>the pattern this filter is applying to candidate strings.</returns>
        </member>
        <member name="M:NGit.Revwalk.Filter.PatternMatchRevFilter.Include(NGit.Revwalk.RevWalk,NGit.Revwalk.RevCommit)">
            <exception cref="T:NGit.Errors.MissingObjectException"></exception>
            <exception cref="T:NGit.Errors.IncorrectObjectTypeException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Revwalk.Filter.PatternMatchRevFilter.Text(NGit.Revwalk.RevCommit)">
            <summary>Obtain the raw text to match against.</summary>
            <remarks>Obtain the raw text to match against.</remarks>
            <param name="cmit">current commit being evaluated.</param>
            <returns>sequence for the commit's content that we need to match on.</returns>
        </member>
        <member name="T:NGit.Revwalk.Filter.SubStringRevFilter">
            <summary>Abstract filter that searches text using only substring search.</summary>
            <remarks>Abstract filter that searches text using only substring search.</remarks>
        </member>
        <member name="M:NGit.Revwalk.Filter.SubStringRevFilter.Safe(System.String)">
            <summary>Can this string be safely handled by a substring filter?</summary>
            <param name="pattern">the pattern text proposed by the user.</param>
            <returns>
            true if a substring filter can perform this pattern match; false
            if
            <see cref="T:NGit.Revwalk.Filter.PatternMatchRevFilter">PatternMatchRevFilter</see>
            must be used instead.
            </returns>
        </member>
        <member name="M:NGit.Revwalk.Filter.SubStringRevFilter.#ctor(System.String)">
            <summary>Construct a new matching filter.</summary>
            <remarks>Construct a new matching filter.</remarks>
            <param name="patternText">
            text to locate. This should be a safe string as described by
            the
            <see cref="M:NGit.Revwalk.Filter.SubStringRevFilter.Safe(System.String)">Safe(string)</see>
            as regular expression meta
            characters are treated as literals.
            </param>
        </member>
        <member name="M:NGit.Revwalk.Filter.SubStringRevFilter.Include(NGit.Revwalk.RevWalk,NGit.Revwalk.RevCommit)">
            <exception cref="T:NGit.Errors.MissingObjectException"></exception>
            <exception cref="T:NGit.Errors.IncorrectObjectTypeException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Revwalk.Filter.SubStringRevFilter.Text(NGit.Revwalk.RevCommit)">
            <summary>Obtain the raw text to match against.</summary>
            <remarks>Obtain the raw text to match against.</remarks>
            <param name="cmit">current commit being evaluated.</param>
            <returns>sequence for the commit's content that we need to match on.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Revwalk.StartGenerator" -->
        <member name="M:NGit.Revwalk.StartGenerator.Next">
            <exception cref="T:NGit.Errors.MissingObjectException"></exception>
            <exception cref="T:NGit.Errors.IncorrectObjectTypeException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="T:NGit.Events.RefsChangedEvent">
            <summary>Describes a change to one or more references of a repository.</summary>
            <remarks>Describes a change to one or more references of a repository.</remarks>
        </member>
        <member name="T:NGit.Errors.MissingObjectException">
            <summary>An expected object is missing.</summary>
            <remarks>An expected object is missing.</remarks>
        </member>
        <member name="M:NGit.Errors.MissingObjectException.#ctor(NGit.ObjectId,System.String)">
            <summary>Construct a MissingObjectException for the specified object id.</summary>
            <remarks>
            Construct a MissingObjectException for the specified object id.
            Expected type is reported to simplify tracking down the problem.
            </remarks>
            <param name="id">SHA-1</param>
            <param name="type">object type</param>
        </member>
        <member name="M:NGit.Errors.MissingObjectException.#ctor(NGit.ObjectId,System.Int32)">
            <summary>Construct a MissingObjectException for the specified object id.</summary>
            <remarks>
            Construct a MissingObjectException for the specified object id.
            Expected type is reported to simplify tracking down the problem.
            </remarks>
            <param name="id">SHA-1</param>
            <param name="type">object type</param>
        </member>
        <member name="M:NGit.Errors.MissingObjectException.#ctor(NGit.AbbreviatedObjectId,System.Int32)">
            <summary>Construct a MissingObjectException for the specified object id.</summary>
            <remarks>
            Construct a MissingObjectException for the specified object id. Expected
            type is reported to simplify tracking down the problem.
            </remarks>
            <param name="id">SHA-1</param>
            <param name="type">object type</param>
        </member>
        <member name="M:NGit.Errors.MissingObjectException.GetObjectId">
            <returns>the ObjectId that was not found.</returns>
        </member>
        <member name="T:NGit.Errors.CorruptObjectException">
            <summary>Exception thrown when an object cannot be read from Git.</summary>
            <remarks>Exception thrown when an object cannot be read from Git.</remarks>
        </member>
        <member name="M:NGit.Errors.CorruptObjectException.#ctor(NGit.AnyObjectId,System.String)">
            <summary>
            Construct a CorruptObjectException for reporting a problem specified
            object id
            </summary>
            <param name="id"></param>
            <param name="why"></param>
        </member>
        <member name="M:NGit.Errors.CorruptObjectException.#ctor(NGit.ObjectId,System.String)">
            <summary>
            Construct a CorruptObjectException for reporting a problem specified
            object id
            </summary>
            <param name="id"></param>
            <param name="why"></param>
        </member>
        <member name="M:NGit.Errors.CorruptObjectException.#ctor(System.String)">
            <summary>
            Construct a CorruptObjectException for reporting a problem not associated
            with a specific object id.
            </summary>
            <remarks>
            Construct a CorruptObjectException for reporting a problem not associated
            with a specific object id.
            </remarks>
            <param name="why"></param>
        </member>
        <member name="T:NGit.Api.Errors.NoFilepatternException">
            <summary>
            Exception thrown when the options given to a command don't include a
            file pattern which is mandatory for processing.
            </summary>
            <remarks>
            Exception thrown when the options given to a command don't include a
            file pattern which is mandatory for processing.
            </remarks>
        </member>
        <member name="M:NGit.Api.Errors.NoFilepatternException.#ctor(System.String,System.Exception)">
            <param name="message"></param>
            <param name="cause"></param>
        </member>
        <member name="M:NGit.Api.Errors.NoFilepatternException.#ctor(System.String)">
            <param name="message"></param>
        </member>
        <member name="T:NGit.Internal.JGitText">
            <summary>Translation bundle for JGit core</summary>
        </member>
        <member name="M:NGit.Internal.JGitText.Get">
            <returns>an instance of this translation bundle</returns>
        </member>
        <member name="T:NGit.Revwalk.Filter.MaxCountRevFilter">
            <summary>Limits the number of commits output.</summary>
            <remarks>Limits the number of commits output.</remarks>
        </member>
        <member name="M:NGit.Revwalk.Filter.MaxCountRevFilter.Create(System.Int32)">
            <summary>Create a new max count filter.</summary>
            <remarks>Create a new max count filter.</remarks>
            <param name="maxCount">the limit</param>
            <returns>a new filter</returns>
        </member>
        <member name="M:NGit.Revwalk.Filter.MaxCountRevFilter.Include(NGit.Revwalk.RevWalk,NGit.Revwalk.RevCommit)">
            <exception cref="T:NGit.Errors.StopWalkException"></exception>
            <exception cref="T:NGit.Errors.MissingObjectException"></exception>
            <exception cref="T:NGit.Errors.IncorrectObjectTypeException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="T:NGit.Storage.File.ReflogEntry">
            <summary>Parsed reflog entry</summary>
        </member>
        <member name="M:NGit.Storage.File.ReflogEntry.GetOldId">
            <returns>the commit id before the change</returns>
        </member>
        <member name="M:NGit.Storage.File.ReflogEntry.GetNewId">
            <returns>the commit id after the change</returns>
        </member>
        <member name="M:NGit.Storage.File.ReflogEntry.GetWho">
            <returns>user performing the change</returns>
        </member>
        <member name="M:NGit.Storage.File.ReflogEntry.GetComment">
            <returns>textual description of the change</returns>
        </member>
        <member name="M:NGit.Storage.File.ReflogEntry.ParseCheckout">
            <returns>
            a
            <see cref="T:NGit.Storage.File.CheckoutEntry">CheckoutEntry</see>
            with parsed information about a branch
            switch, or null if the entry is not a checkout
            </returns>
        </member>
        <member name="M:NGit.Blame.ReverseWalk.Next">
            <exception cref="T:NGit.Errors.MissingObjectException"></exception>
            <exception cref="T:NGit.Errors.IncorrectObjectTypeException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="T:NGit.Api.CherryPickResult">
            <summary>
            Encapsulates the result of a
            <see cref="T:NGit.Api.CherryPickCommand">CherryPickCommand</see>
            .
            </summary>
        </member>
        <member name="M:NGit.Api.CherryPickResult.#ctor(NGit.Revwalk.RevCommit,System.Collections.Generic.IList{NGit.Ref})">
            <param name="newHead">commit the head points at after this cherry-pick</param>
            <param name="cherryPickedRefs">list of successfully cherry-picked <code>Ref</code>'s
            	</param>
        </member>
        <member name="M:NGit.Api.CherryPickResult.#ctor(System.Collections.Generic.IDictionary{System.String,NGit.Merge.ResolveMerger.MergeFailureReason})">
            <param name="failingPaths">
            list of paths causing this cherry-pick to fail (see
            <see cref="M:NGit.Merge.ResolveMerger.GetFailingPaths">NGit.Merge.ResolveMerger.GetFailingPaths()
            	</see>
            for details)
            </param>
        </member>
        <member name="F:NGit.Api.CherryPickResult.CONFLICT">
            <summary>
            A <code>CherryPickResult</code> with status
            <see cref="F:NGit.Api.CherryPickResult.CherryPickStatus.CONFLICTING">CherryPickStatus.CONFLICTING</see>
            </summary>
        </member>
        <member name="M:NGit.Api.CherryPickResult.GetStatus">
            <returns>the status this cherry-pick resulted in</returns>
        </member>
        <member name="M:NGit.Api.CherryPickResult.GetNewHead">
            <returns>
            the commit the head points at after this cherry-pick,
            <code>null</code> if
            <see cref="M:NGit.Api.CherryPickResult.GetStatus">GetStatus()</see>
            is not
            <see cref="F:NGit.Api.CherryPickResult.CherryPickStatus.OK">CherryPickStatus.OK</see>
            </returns>
        </member>
        <member name="M:NGit.Api.CherryPickResult.GetCherryPickedRefs">
            <returns>
            the list of successfully cherry-picked <code>Ref</code>'s,
            <code>null</code> if
            <see cref="M:NGit.Api.CherryPickResult.GetStatus">GetStatus()</see>
            is not
            <see cref="F:NGit.Api.CherryPickResult.CherryPickStatus.OK">CherryPickStatus.OK</see>
            </returns>
        </member>
        <member name="M:NGit.Api.CherryPickResult.GetFailingPaths">
            <returns>
            the list of paths causing this cherry-pick to fail (see
            <see cref="M:NGit.Merge.ResolveMerger.GetFailingPaths">NGit.Merge.ResolveMerger.GetFailingPaths()
            	</see>
            for details),
            <code>null</code> if
            <see cref="M:NGit.Api.CherryPickResult.GetStatus">GetStatus()</see>
            is not
            <see cref="F:NGit.Api.CherryPickResult.CherryPickStatus.FAILED">CherryPickStatus.FAILED</see>
            </returns>
        </member>
        <member name="T:NGit.Api.CherryPickResult.CherryPickStatus">
            <summary>The cherry-pick status</summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Transport.PackParser" -->
        <member name="F:NGit.Transport.PackParser.BUFFER_SIZE">
            <summary>Size of the internal stream buffer.</summary>
            <remarks>Size of the internal stream buffer.</remarks>
        </member>
        <member name="F:NGit.Transport.PackParser.objectDatabase">
            <summary>Object database used for loading existing objects.</summary>
            <remarks>Object database used for loading existing objects.</remarks>
        </member>
        <member name="F:NGit.Transport.PackParser.bBase">
            <summary>
            Position in the input stream of
            <code>buf[0]</code>
            .
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:NGit.Transport.PackParser.newObjectIds" -->
        <!-- Badly formed XML comment ignored for member "F:NGit.Transport.PackParser.baseObjectIds" -->
        <member name="F:NGit.Transport.PackParser.deferredCheckBlobs">
            <summary>Blobs whose contents need to be double-checked after indexing.</summary>
            <remarks>Blobs whose contents need to be double-checked after indexing.</remarks>
        </member>
        <member name="F:NGit.Transport.PackParser.lockMessage">
            <summary>Message to protect the pack data from garbage collection.</summary>
            <remarks>Message to protect the pack data from garbage collection.</remarks>
        </member>
        <member name="F:NGit.Transport.PackParser.maxObjectSizeLimit">
            <summary>Git object size limit</summary>
        </member>
        <member name="M:NGit.Transport.PackParser.#ctor(NGit.ObjectDatabase,Sharpen.InputStream)">
            <summary>Initialize a pack parser.</summary>
            <remarks>Initialize a pack parser.</remarks>
            <param name="odb">database the parser will write its objects into.</param>
            <param name="src">the stream the parser will read.</param>
        </member>
        <member name="M:NGit.Transport.PackParser.IsAllowThin">
            <returns>true if a thin pack (missing base objects) is permitted.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Transport.PackParser.SetAllowThin(System.Boolean)" -->
        <member name="M:NGit.Transport.PackParser.IsCheckObjectCollisions">
            <returns>if true received objects are verified to prevent collisions.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Transport.PackParser.SetCheckObjectCollisions(System.Boolean)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Transport.PackParser.SetNeedNewObjectIds(System.Boolean)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Transport.PackParser.SetNeedBaseObjectIds(System.Boolean)" -->
        <member name="M:NGit.Transport.PackParser.IsCheckEofAfterPackFooter">
            <returns>true if the EOF should be read from the input after the footer.</returns>
        </member>
        <member name="M:NGit.Transport.PackParser.SetCheckEofAfterPackFooter(System.Boolean)">
            <summary>Ensure EOF is read from the input stream after the footer.</summary>
            <remarks>Ensure EOF is read from the input stream after the footer.</remarks>
            <param name="b">true if the EOF should be read; false if it is not checked.</param>
        </member>
        <member name="M:NGit.Transport.PackParser.IsExpectDataAfterPackFooter">
            <returns>true if there is data expected after the pack footer.</returns>
        </member>
        <member name="M:NGit.Transport.PackParser.SetExpectDataAfterPackFooter(System.Boolean)">
            <param name="e">
            true if there is additional data in InputStream after pack.
            This requires the InputStream to support the mark and reset
            functions.
            </param>
        </member>
        <member name="M:NGit.Transport.PackParser.GetNewObjectIds">
            <returns>the new objects that were sent by the user</returns>
        </member>
        <member name="M:NGit.Transport.PackParser.GetBaseObjectIds">
            <returns>set of objects the incoming pack assumed for delta purposes</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Transport.PackParser.SetObjectChecker(NGit.ObjectChecker)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Transport.PackParser.SetObjectChecking(System.Boolean)" -->
        <member name="M:NGit.Transport.PackParser.GetLockMessage">
            <returns>the message to record with the pack lock.</returns>
        </member>
        <member name="M:NGit.Transport.PackParser.SetLockMessage(System.String)">
            <summary>Set the lock message for the incoming pack data.</summary>
            <remarks>Set the lock message for the incoming pack data.</remarks>
            <param name="msg">
            if not null, the message to associate with the incoming data
            while it is locked to prevent garbage collection.
            </param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Transport.PackParser.SetMaxObjectSizeLimit(System.Int64)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Transport.PackParser.GetObjectCount" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Transport.PackParser.GetObject(System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Transport.PackParser.GetSortedObjectList(System.Collections.Generic.IComparer{NGit.Transport.PackedObjectInfo})" -->
        <member name="M:NGit.Transport.PackParser.Parse(NGit.ProgressMonitor)">
            <summary>Parse the pack stream.</summary>
            <remarks>Parse the pack stream.</remarks>
            <param name="progress">
            callback to provide progress feedback during parsing. If null,
            <see cref="T:NGit.NullProgressMonitor">NGit.NullProgressMonitor</see>
            will be used.
            </param>
            <returns>
            the pack lock, if one was requested by setting
            <see cref="M:NGit.Transport.PackParser.SetLockMessage(System.String)">SetLockMessage(string)</see>
            .
            </returns>
            <exception cref="T:System.IO.IOException">the stream is malformed, or contains corrupt objects.
            	</exception>
        </member>
        <member name="M:NGit.Transport.PackParser.Parse(NGit.ProgressMonitor,NGit.ProgressMonitor)">
            <summary>Parse the pack stream.</summary>
            <remarks>Parse the pack stream.</remarks>
            <param name="receiving">
            receives progress feedback during the initial receiving
            objects phase. If null,
            <see cref="T:NGit.NullProgressMonitor">NGit.NullProgressMonitor</see>
            will be
            used.
            </param>
            <param name="resolving">receives progress feedback during the resolving objects phase.
            	</param>
            <returns>
            the pack lock, if one was requested by setting
            <see cref="M:NGit.Transport.PackParser.SetLockMessage(System.String)">SetLockMessage(string)</see>
            .
            </returns>
            <exception cref="T:System.IO.IOException">the stream is malformed, or contains corrupt objects.
            	</exception>
        </member>
        <member name="M:NGit.Transport.PackParser.ResolveDeltas(NGit.ProgressMonitor)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Transport.PackParser.ResolveDeltas(NGit.Transport.PackedObjectInfo,NGit.ProgressMonitor)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Transport.PackParser.ResolveDeltas(NGit.Transport.PackParser.DeltaVisit,System.Int32,NGit.Transport.PackParser.ObjectTypeAndSize,NGit.ProgressMonitor)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Transport.PackParser.CheckIfTooLarge(System.Int32,System.Int64)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Transport.PackParser.ReadObjectHeader(NGit.Transport.PackParser.ObjectTypeAndSize)" -->
        <member name="M:NGit.Transport.PackParser.ResolveDeltasWithExternalBases(NGit.ProgressMonitor)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Transport.PackParser.ReadPackHeader">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Transport.PackParser.ReadPackFooter">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Transport.PackParser.IndexOneObject">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Transport.PackParser.Whole(System.Int64,System.Int32,System.Int64)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Transport.PackParser.VerifySafeObject(NGit.AnyObjectId,System.Int32,System.Byte[])">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Transport.PackParser.DoDeferredCheckBlobs">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Transport.PackParser.StreamPosition">
            <returns>current position of the input stream being parsed.</returns>
        </member>
        <member name="M:NGit.Transport.PackParser.OpenDatabase(NGit.Transport.PackedObjectInfo,NGit.Transport.PackParser.ObjectTypeAndSize)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Transport.PackParser.OpenDatabase(NGit.Transport.PackParser.UnresolvedDelta,NGit.Transport.PackParser.ObjectTypeAndSize)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Transport.PackParser.ReadFrom(NGit.Transport.PackParser.Source)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Transport.PackParser.Fill(NGit.Transport.PackParser.Source,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Transport.PackParser.Sync">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Transport.PackParser.Buffer">
            <returns>a temporary byte array for use by the caller.</returns>
        </member>
        <member name="M:NGit.Transport.PackParser.NewInfo(NGit.AnyObjectId,NGit.Transport.PackParser.UnresolvedDelta,NGit.ObjectId)">
            <summary>Construct a PackedObjectInfo instance for this parser.</summary>
            <remarks>Construct a PackedObjectInfo instance for this parser.</remarks>
            <param name="id">identity of the object to be tracked.</param>
            <param name="delta">
            if the object was previously an unresolved delta, this is the
            delta object that was tracking it. Otherwise null.
            </param>
            <param name="deltaBase">
            if the object was previously an unresolved delta, this is the
            ObjectId of the base of the delta. The base may be outside of
            the pack stream if the stream was a thin-pack.
            </param>
            <returns>info object containing this object's data.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Transport.PackParser.OnStoreStream(System.Byte[],System.Int32,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Transport.PackParser.OnObjectHeader(NGit.Transport.PackParser.Source,System.Byte[],System.Int32,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Transport.PackParser.OnObjectData(NGit.Transport.PackParser.Source,System.Byte[],System.Int32,System.Int32)" -->
        <member name="M:NGit.Transport.PackParser.OnInflatedObjectData(NGit.Transport.PackedObjectInfo,System.Int32,System.Byte[])">
            <summary>Invoked for commits, trees, tags, and small blobs.</summary>
            <remarks>Invoked for commits, trees, tags, and small blobs.</remarks>
            <param name="obj">the object info, populated.</param>
            <param name="typeCode">the type of the object.</param>
            <param name="data">inflated data for the object.</param>
            <exception cref="T:System.IO.IOException">the object cannot be archived.</exception>
        </member>
        <member name="M:NGit.Transport.PackParser.OnPackHeader(System.Int64)">
            <summary>Provide the implementation with the original stream's pack header.</summary>
            <remarks>Provide the implementation with the original stream's pack header.</remarks>
            <param name="objCnt">number of objects expected in the stream.</param>
            <exception cref="T:System.IO.IOException">the implementation refuses to work with this many objects.
            	</exception>
        </member>
        <member name="M:NGit.Transport.PackParser.OnPackFooter(System.Byte[])">
            <summary>Provide the implementation with the original stream's pack footer.</summary>
            <remarks>Provide the implementation with the original stream's pack footer.</remarks>
            <param name="hash">
            the trailing 20 bytes of the pack, this is a SHA-1 checksum of
            all of the pack data.
            </param>
            <exception cref="T:System.IO.IOException">the stream cannot be archived.</exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Transport.PackParser.OnAppendBase(System.Int32,System.Byte[],NGit.Transport.PackedObjectInfo)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Transport.PackParser.OnEndThinPack" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Transport.PackParser.SeekDatabase(NGit.Transport.PackedObjectInfo,NGit.Transport.PackParser.ObjectTypeAndSize)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Transport.PackParser.SeekDatabase(NGit.Transport.PackParser.UnresolvedDelta,NGit.Transport.PackParser.ObjectTypeAndSize)" -->
        <member name="M:NGit.Transport.PackParser.ReadDatabase(System.Byte[],System.Int32,System.Int32)">
            <summary>Read from the database's current position into the buffer.</summary>
            <remarks>Read from the database's current position into the buffer.</remarks>
            <param name="dst">the buffer to copy read data into.</param>
            <param name="pos">
            position within
            <code>dst</code>
            to start copying data into.
            </param>
            <param name="cnt">
            ideal target number of bytes to read. Actual read length may
            be shorter.
            </param>
            <returns>number of bytes stored.</returns>
            <exception cref="T:System.IO.IOException">the database cannot be accessed.</exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Transport.PackParser.CheckCRC(System.Int32)" -->
        <member name="M:NGit.Transport.PackParser.OnBeginWholeObject(System.Int64,System.Int32,System.Int64)">
            <summary>Event notifying the start of an object stored whole (not as a delta).</summary>
            <remarks>Event notifying the start of an object stored whole (not as a delta).</remarks>
            <param name="streamPosition">position of this object in the incoming stream.</param>
            <param name="type">
            type of the object; one of
            <see cref="F:NGit.Constants.OBJ_COMMIT">NGit.Constants.OBJ_COMMIT</see>
            ,
            <see cref="F:NGit.Constants.OBJ_TREE">NGit.Constants.OBJ_TREE</see>
            ,
            <see cref="F:NGit.Constants.OBJ_BLOB">NGit.Constants.OBJ_BLOB</see>
            , or
            <see cref="F:NGit.Constants.OBJ_TAG">NGit.Constants.OBJ_TAG</see>
            .
            </param>
            <param name="inflatedSize">
            size of the object when fully inflated. The size stored within
            the pack may be larger or smaller, and is not yet known.
            </param>
            <exception cref="T:System.IO.IOException">the object cannot be recorded.</exception>
        </member>
        <member name="M:NGit.Transport.PackParser.OnEndWholeObject(NGit.Transport.PackedObjectInfo)">
            <summary>Event notifying the the current object.</summary>
            <remarks>Event notifying the the current object.</remarks>
            <param name="info">object information.</param>
            <exception cref="T:System.IO.IOException">the object cannot be recorded.</exception>
        </member>
        <member name="M:NGit.Transport.PackParser.OnBeginOfsDelta(System.Int64,System.Int64,System.Int64)">
            <summary>Event notifying start of a delta referencing its base by offset.</summary>
            <remarks>Event notifying start of a delta referencing its base by offset.</remarks>
            <param name="deltaStreamPosition">position of this object in the incoming stream.
            	</param>
            <param name="baseStreamPosition">
            position of the base object in the incoming stream. The base
            must be before the delta, therefore
            <code>
            baseStreamPosition
            &lt; deltaStreamPosition
            </code>
            . This is <b>not</b> the position
            returned by a prior end object event.
            </param>
            <param name="inflatedSize">
            size of the delta when fully inflated. The size stored within
            the pack may be larger or smaller, and is not yet known.
            </param>
            <exception cref="T:System.IO.IOException">the object cannot be recorded.</exception>
        </member>
        <member name="M:NGit.Transport.PackParser.OnBeginRefDelta(System.Int64,NGit.AnyObjectId,System.Int64)">
            <summary>Event notifying start of a delta referencing its base by ObjectId.</summary>
            <remarks>Event notifying start of a delta referencing its base by ObjectId.</remarks>
            <param name="deltaStreamPosition">position of this object in the incoming stream.
            	</param>
            <param name="baseId">
            name of the base object. This object may be later in the
            stream, or might not appear at all in the stream (in the case
            of a thin-pack).
            </param>
            <param name="inflatedSize">
            size of the delta when fully inflated. The size stored within
            the pack may be larger or smaller, and is not yet known.
            </param>
            <exception cref="T:System.IO.IOException">the object cannot be recorded.</exception>
        </member>
        <member name="M:NGit.Transport.PackParser.OnEndDelta">
            <summary>Event notifying the the current object.</summary>
            <remarks>Event notifying the the current object.</remarks>
            <returns>
            object information that must be populated with at least the
            offset.
            </returns>
            <exception cref="T:System.IO.IOException">the object cannot be recorded.</exception>
        </member>
        <member name="M:NGit.Transport.PackParser.InflateAndSkip(NGit.Transport.PackParser.Source,System.Int64)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Transport.PackParser.InflateAndReturn(NGit.Transport.PackParser.Source,System.Int64)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Transport.PackParser.Inflate(NGit.Transport.PackParser.Source,System.Int64)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="T:NGit.Transport.PackParser.Source">
            <summary>Location data is being obtained from.</summary>
            <remarks>Location data is being obtained from.</remarks>
        </member>
        <member name="T:NGit.Transport.PackParser.ObjectTypeAndSize">
            <summary>Type and size information about an object in the database buffer.</summary>
            <remarks>Type and size information about an object in the database buffer.</remarks>
        </member>
        <member name="F:NGit.Transport.PackParser.ObjectTypeAndSize.type">
            <summary>The type of the object.</summary>
            <remarks>The type of the object.</remarks>
        </member>
        <member name="F:NGit.Transport.PackParser.ObjectTypeAndSize.size">
            <summary>The inflated size of the object.</summary>
            <remarks>The inflated size of the object.</remarks>
        </member>
        <member name="T:NGit.Transport.PackParser.UnresolvedDelta">
            <summary>Information about an unresolved delta in this pack stream.</summary>
            <remarks>Information about an unresolved delta in this pack stream.</remarks>
        </member>
        <member name="M:NGit.Transport.PackParser.UnresolvedDelta.GetOffset">
            <returns>offset within the input stream.</returns>
        </member>
        <member name="M:NGit.Transport.PackParser.UnresolvedDelta.GetCRC">
            <returns>the CRC-32 checksum of the stored delta data.</returns>
        </member>
        <member name="M:NGit.Transport.PackParser.UnresolvedDelta.SetCRC(System.Int32)">
            <param name="crc32">the CRC-32 checksum of the stored delta data.</param>
        </member>
        <member name="M:NGit.Transport.PackParser.InflaterStream.Open(NGit.Transport.PackParser.Source,System.Int64)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Transport.PackParser.InflaterStream.Skip(System.Int64)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Transport.PackParser.InflaterStream.Read">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Transport.PackParser.InflaterStream.Read(System.Byte[],System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Transport.PackParser.InflaterStream.Close">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Notes.DefaultNoteMerger" -->
        <!-- Badly formed XML comment ignored for member "T:NGit.Notes.NoteMerger" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Notes.NoteMerger.Merge(NGit.Notes.Note,NGit.Notes.Note,NGit.Notes.Note,NGit.ObjectReader,NGit.ObjectInserter)" -->
        <member name="M:NGit.Notes.DefaultNoteMerger.Merge(NGit.Notes.Note,NGit.Notes.Note,NGit.Notes.Note,NGit.ObjectReader,NGit.ObjectInserter)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="T:NGit.Api.Errors.RefAlreadyExistsException">
            <summary>
            Thrown when trying to create a
            <see cref="T:NGit.Ref">NGit.Ref</see>
            with the same name as an exsiting
            one
            </summary>
        </member>
        <member name="M:NGit.Api.Errors.RefAlreadyExistsException.#ctor(System.String)">
            <param name="message"></param>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Diff.SubsequenceComparator`1" -->
        <member name="M:NGit.Diff.SubsequenceComparator`1.#ctor(NGit.Diff.SequenceComparator{`0})">
            <summary>Construct a comparator wrapping another comparator.</summary>
            <remarks>Construct a comparator wrapping another comparator.</remarks>
            <param name="cmp">the real comparator.</param>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Transport.TransportBundle" -->
        <member name="F:NGit.Transport.TransportBundleConstants.V2_BUNDLE_SIGNATURE">
            <summary>Bundle signature</summary>
        </member>
        <member name="T:NGit.Transport.PushProcess">
            <summary>Class performing push operation on remote repository.</summary>
            <remarks>Class performing push operation on remote repository.</remarks>
            <seealso cref="!:Transport.Push(NGit.ProgressMonitor, System.Collections.Generic.ICollection&lt;E&gt;)&#xA;            	">Transport.Push(NGit.ProgressMonitor, System.Collections.Generic.ICollection&lt;E&gt;)
            	</seealso>
        </member>
        <member name="F:NGit.Transport.PushProcess.PROGRESS_OPENING_CONNECTION">
            <summary>
            Task name for
            <see cref="T:NGit.ProgressMonitor">NGit.ProgressMonitor</see>
            used during opening connection.
            </summary>
        </member>
        <member name="F:NGit.Transport.PushProcess.transport">
            <summary>Transport used to perform this operation.</summary>
            <remarks>Transport used to perform this operation.</remarks>
        </member>
        <member name="F:NGit.Transport.PushProcess.connection">
            <summary>Push operation connection created to perform this operation</summary>
        </member>
        <member name="F:NGit.Transport.PushProcess.toPush">
            <summary>Refs to update on remote side.</summary>
            <remarks>Refs to update on remote side.</remarks>
        </member>
        <member name="F:NGit.Transport.PushProcess.walker">
            <summary>Revision walker for checking some updates properties.</summary>
            <remarks>Revision walker for checking some updates properties.</remarks>
        </member>
        <member name="M:NGit.Transport.PushProcess.#ctor(NGit.Transport.Transport,System.Collections.Generic.ICollection{NGit.Transport.RemoteRefUpdate})">
            <summary>Create process for specified transport and refs updates specification.</summary>
            <remarks>Create process for specified transport and refs updates specification.</remarks>
            <param name="transport">
            transport between remote and local repository, used to create
            connection.
            </param>
            <param name="toPush">specification of refs updates (and local tracking branches).
            	</param>
            <exception cref="T:NGit.Errors.TransportException">NGit.Errors.TransportException</exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Transport.PushProcess.Execute(NGit.ProgressMonitor)" -->
        <member name="M:NGit.Transport.PushProcess.PrepareRemoteUpdates">
            <exception cref="T:NGit.Errors.TransportException"></exception>
        </member>
        <member name="T:NGit.Transport.TrackingRefUpdate">
            <summary>Update of a locally stored tracking branch.</summary>
            <remarks>Update of a locally stored tracking branch.</remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Transport.TrackingRefUpdate.GetRemoteName" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Transport.TrackingRefUpdate.GetLocalName" -->
        <member name="M:NGit.Transport.TrackingRefUpdate.GetNewObjectId">
            <summary>Get the new value the ref will be (or was) updated to.</summary>
            <remarks>Get the new value the ref will be (or was) updated to.</remarks>
            <returns>new value. Null if the caller has not configured it.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Transport.TrackingRefUpdate.GetOldObjectId" -->
        <member name="M:NGit.Transport.TrackingRefUpdate.GetResult">
            <summary>Get the status of this update.</summary>
            <remarks>Get the status of this update.</remarks>
            <returns>the status of the update.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Util.IO.UnionInputStream" -->
        <member name="M:NGit.Util.IO.UnionInputStream.#ctor">
            <summary>Create an empty InputStream that is currently at EOF state.</summary>
            <remarks>Create an empty InputStream that is currently at EOF state.</remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Util.IO.UnionInputStream.#ctor(Sharpen.InputStream[])" -->
        <member name="M:NGit.Util.IO.UnionInputStream.Pop">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Util.IO.UnionInputStream.Add(Sharpen.InputStream)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Util.IO.UnionInputStream.IsEmpty" -->
        <member name="M:NGit.Util.IO.UnionInputStream.Read">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Util.IO.UnionInputStream.Read(System.Byte[],System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Util.IO.UnionInputStream.Available">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Util.IO.UnionInputStream.Skip(System.Int64)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Util.IO.UnionInputStream.Close">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Util.IO.UnionInputStream._InputStream_63.Read">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="T:NGit.Util.IO.TeeInputStream">
            <summary>Input stream that copies data read to another output stream.</summary>
            <remarks>
            Input stream that copies data read to another output stream.
            This stream is primarily useful with a
            <see cref="T:NGit.Util.TemporaryBuffer">NGit.Util.TemporaryBuffer</see>
            , where any
            data read or skipped by the caller is also duplicated into the temporary
            buffer. Later the temporary buffer can then be used instead of the original
            source stream.
            During close this stream copies any remaining data from the source stream
            into the destination stream.
            </remarks>
        </member>
        <member name="M:NGit.Util.IO.TeeInputStream.#ctor(Sharpen.InputStream,Sharpen.OutputStream)">
            <summary>Initialize a tee input stream.</summary>
            <remarks>Initialize a tee input stream.</remarks>
            <param name="src">source stream to consume.</param>
            <param name="dst">
            destination to copy the source to as it is consumed. Typically
            this is a
            <see cref="T:NGit.Util.TemporaryBuffer">NGit.Util.TemporaryBuffer</see>
            .
            </param>
        </member>
        <member name="M:NGit.Util.IO.TeeInputStream.Read">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Util.IO.TeeInputStream.Skip(System.Int64)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Util.IO.TeeInputStream.Read(System.Byte[],System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Util.IO.TeeInputStream.Close">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Util.ChangeIdUtil" -->
        <member name="M:NGit.Util.ChangeIdUtil.ComputeChangeId(NGit.ObjectId,NGit.ObjectId,NGit.PersonIdent,NGit.PersonIdent,System.String)">
            <summary>Compute a Change-Id.</summary>
            <remarks>Compute a Change-Id.</remarks>
            <param name="treeId">The id of the tree that would be committed</param>
            <param name="firstParentId">parent id of previous commit or null</param>
            <param name="author">
            the
            <see cref="T:NGit.PersonIdent">NGit.PersonIdent</see>
            for the presumed author and time
            </param>
            <param name="committer">
            the
            <see cref="T:NGit.PersonIdent">NGit.PersonIdent</see>
            for the presumed committer and time
            </param>
            <param name="message">The commit message</param>
            <returns>
            the change id SHA1 string (without the 'I') or null if the
            message is not complete enough
            </returns>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Util.ChangeIdUtil.InsertId(System.String,NGit.ObjectId)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Util.ChangeIdUtil.InsertId(System.String,NGit.ObjectId,System.Boolean)" -->
        <member name="T:NGit.Util.CachedAuthenticator">
            <summary>Abstract authenticator which remembers prior authentications.</summary>
            <remarks>Abstract authenticator which remembers prior authentications.</remarks>
        </member>
        <member name="M:NGit.Util.CachedAuthenticator.Add(NGit.Util.CachedAuthenticator.CachedAuthentication)">
            <summary>Add a cached authentication for future use.</summary>
            <remarks>Add a cached authentication for future use.</remarks>
            <param name="ca">the information we should remember.</param>
        </member>
        <member name="M:NGit.Util.CachedAuthenticator.PromptPasswordAuthentication">
            <summary>Prompt for and request authentication from the end-user.</summary>
            <remarks>Prompt for and request authentication from the end-user.</remarks>
            <returns>
            the authentication data; null if the user canceled the request
            and does not want to continue.
            </returns>
        </member>
        <member name="T:NGit.Util.CachedAuthenticator.CachedAuthentication">
            <summary>Authentication data to remember and reuse.</summary>
            <remarks>Authentication data to remember and reuse.</remarks>
        </member>
        <member name="M:NGit.Util.CachedAuthenticator.CachedAuthentication.#ctor(System.String,System.Int32,System.String,System.String)">
            <summary>Create a new cached authentication.</summary>
            <remarks>Create a new cached authentication.</remarks>
            <param name="aHost">system this is for.</param>
            <param name="aPort">port number of the service.</param>
            <param name="aUser">username at the service.</param>
            <param name="aPass">password at the service.</param>
        </member>
        <member name="F:NGit.Storage.Pack.DeltaWindowEntry.buffer">
            <summary>Complete contents of this object.</summary>
            <remarks>Complete contents of this object. Lazily loaded.</remarks>
        </member>
        <member name="F:NGit.Storage.Pack.DeltaWindowEntry.index">
            <summary>Index of this object's content, to encode other deltas.</summary>
            <remarks>Index of this object's content, to encode other deltas. Lazily loaded.</remarks>
        </member>
        <member name="M:NGit.Storage.Pack.DeltaWindowEntry.Depth">
            <returns>current delta chain depth of this object.</returns>
        </member>
        <member name="M:NGit.Storage.Pack.DeltaWindowEntry.Type">
            <returns>type of the object in this window entry.</returns>
        </member>
        <member name="M:NGit.Storage.Pack.DeltaWindowEntry.Size">
            <returns>estimated unpacked size of the object, in bytes .</returns>
        </member>
        <member name="M:NGit.Storage.Pack.DeltaWindowEntry.Empty">
            <returns>true if there is no object stored in this entry.</returns>
        </member>
        <member name="M:NGit.Storage.Pack.DeltaTask.Call">
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:NGit.Storage.File.LargePackedDeltaObject.GetCachedBytes">
            <exception cref="T:NGit.Errors.LargeObjectException"></exception>
        </member>
        <member name="M:NGit.Storage.File.LargePackedDeltaObject.OpenStream">
            <exception cref="T:NGit.Errors.MissingObjectException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.LargePackedDeltaObject.Open(NGit.Storage.File.WindowCursor)">
            <exception cref="T:NGit.Errors.MissingObjectException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
            <exception cref="T:NGit.Errors.IncorrectObjectTypeException"></exception>
        </member>
        <member name="M:NGit.Storage.File.LargePackedDeltaObject.GetObjectId">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.LargePackedDeltaObject._Filter_195.Close">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.LargePackedDeltaObject._DeltaStream_223.OpenBase">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.LargePackedDeltaObject._DeltaStream_223.GetBaseSize">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Revwalk.DelayRevQueue" -->
        <member name="M:NGit.Revwalk.DelayRevQueue.Next">
            <exception cref="T:NGit.Errors.MissingObjectException"></exception>
            <exception cref="T:NGit.Errors.IncorrectObjectTypeException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="T:NGit.Revplot.PlotWalk">
            <summary>Specialized RevWalk for visualization of a commit graph.</summary>
            <remarks>Specialized RevWalk for visualization of a commit graph.</remarks>
        </member>
        <member name="M:NGit.Revplot.PlotWalk.#ctor(NGit.Repository)">
            <summary>Create a new revision walker for a given repository.</summary>
            <remarks>Create a new revision walker for a given repository.</remarks>
            <param name="repo">the repository the walker will obtain data from.</param>
        </member>
        <member name="M:NGit.Revplot.PlotWalk.AddAdditionalRefs(Sharpen.Iterable{NGit.Ref})">
            <summary>Add additional refs to the walk</summary>
            <param name="refs">additional refs</param>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:NGit.Revplot.PlotWalk.Next">
            <exception cref="T:NGit.Errors.MissingObjectException"></exception>
            <exception cref="T:NGit.Errors.IncorrectObjectTypeException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Revplot.PlotLane" -->
        <member name="M:NGit.Revplot.PlotLane.GetPosition">
            <summary>Logical location of this lane within the graphing plane.</summary>
            <remarks>Logical location of this lane within the graphing plane.</remarks>
            <returns>location of this lane, 0 through the maximum number of lanes.</returns>
        </member>
        <member name="T:NGit.Fnmatch.FileNameMatcher">
            <summary>This class can be used to match filenames against fnmatch like patterns.
            	</summary>
            <remarks>
            This class can be used to match filenames against fnmatch like patterns. It
            is not thread save.
            <p>
            Supported are the wildcard characters * and ? and groups with:
            <ul>
            <li> characters e.g. [abc]</li>
            <li> ranges e.g. [a-z]</li>
            <li> the following character classes
            <ul>
            <li>[:alnum:]</li>
            <li>[:alpha:]</li>
            <li>[:blank:]</li>
            <li>[:cntrl:]</li>
            <li>[:digit:]</li>
            <li>[:graph:]</li>
            <li>[:lower:]</li>
            <li>[:print:]</li>
            <li>[:punct:]</li>
            <li>[:space:]</li>
            <li>[:upper:]</li>
            <li>[:word:]</li>
            <li>[:xdigit:]</li>
            </ul>
            e. g. [[:xdigit:]] </li>
            </ul>
            </p>
            </remarks>
        </member>
        <member name="F:NGit.Fnmatch.FileNameMatcher.listForLocalUseage">
            <summary>
            {
            <see cref="M:NGit.Fnmatch.FileNameMatcher.ExtendStringToMatchByOneCharacter(System.Char)">ExtendStringToMatchByOneCharacter(char)
            	</see>
            needs a list for the
            new heads, allocating a new array would be bad for the performance, as
            the method gets called very often.
            </summary>
        </member>
        <member name="M:NGit.Fnmatch.FileNameMatcher.#ctor(System.Collections.Generic.IList{NGit.Fnmatch.Head})">
            <param name="headsStartValue">must be a list which will never be modified.</param>
        </member>
        <member name="M:NGit.Fnmatch.FileNameMatcher.#ctor(System.Collections.Generic.IList{NGit.Fnmatch.Head},System.Collections.Generic.IList{NGit.Fnmatch.Head})">
            <param name="headsStartValue">must be a list which will never be modified.</param>
            <param name="heads">
            a list which will be cloned and then used as current head
            list.
            </param>
        </member>
        <member name="M:NGit.Fnmatch.FileNameMatcher.#ctor(System.String,System.Nullable{System.Char})">
            <param name="patternString">must contain a pattern which fnmatch would accept.</param>
            <param name="invalidWildgetCharacter">
            if this parameter isn't null then this character will not
            match at wildcards(* and ? are wildcards).
            </param>
            <exception cref="T:NGit.Errors.InvalidPatternException">if the patternString contains a invalid fnmatch pattern.
            	</exception>
        </member>
        <member name="M:NGit.Fnmatch.FileNameMatcher.#ctor(NGit.Fnmatch.FileNameMatcher)">
            <summary>
            A Copy Constructor which creates a new
            <see cref="T:NGit.Fnmatch.FileNameMatcher">FileNameMatcher</see>
            with the
            same state and reset point like <code>other</code>.
            </summary>
            <param name="other">
            another
            <see cref="T:NGit.Fnmatch.FileNameMatcher">FileNameMatcher</see>
            instance.
            </param>
        </member>
        <member name="M:NGit.Fnmatch.FileNameMatcher.CreateHeadsStartValues(System.String,System.Nullable{System.Char})">
            <exception cref="T:NGit.Errors.InvalidPatternException"></exception>
        </member>
        <member name="M:NGit.Fnmatch.FileNameMatcher.FindGroupEnd(System.Int32,System.String)">
            <exception cref="T:NGit.Errors.InvalidPatternException"></exception>
        </member>
        <member name="M:NGit.Fnmatch.FileNameMatcher.ParseHeads(System.String,System.Nullable{System.Char})">
            <exception cref="T:NGit.Errors.InvalidPatternException"></exception>
        </member>
        <member name="M:NGit.Fnmatch.FileNameMatcher.Append(System.String)">
            <param name="stringToMatch">
            extends the string which is matched against the patterns of
            this class.
            </param>
        </member>
        <member name="M:NGit.Fnmatch.FileNameMatcher.Reset">
            <summary>Resets this matcher to it's state right after construction.</summary>
            <remarks>Resets this matcher to it's state right after construction.</remarks>
        </member>
        <member name="M:NGit.Fnmatch.FileNameMatcher.CreateMatcherForSuffix">
            <returns>
            a
            <see cref="T:NGit.Fnmatch.FileNameMatcher">FileNameMatcher</see>
            instance which uses the same pattern
            like this matcher, but has the current state of this matcher as
            reset and start point.
            </returns>
        </member>
        <member name="M:NGit.Fnmatch.FileNameMatcher.IsMatch">
            <returns>true, if the string currently being matched does match.</returns>
        </member>
        <member name="M:NGit.Fnmatch.FileNameMatcher.CanAppendMatch">
            <returns>
            false, if the string being matched will not match when the string
            gets extended.
            </returns>
        </member>
        <member name="T:NGit.Events.RefsChangedListener">
            <summary>
            Receives
            <see cref="T:NGit.Events.RefsChangedEvent">RefsChangedEvent</see>
            s.
            </summary>
        </member>
        <member name="M:NGit.Events.RefsChangedListener.OnRefsChanged(NGit.Events.RefsChangedEvent)">
            <summary>Invoked when any reference changes.</summary>
            <remarks>Invoked when any reference changes.</remarks>
            <param name="event">information about the changes.</param>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Diff.Edit" -->
        <member name="M:NGit.Diff.Edit.#ctor(System.Int32,System.Int32)">
            <summary>Create a new empty edit.</summary>
            <remarks>Create a new empty edit.</remarks>
            <param name="as">beginA: start and end of region in sequence A; 0 based.</param>
            <param name="bs">beginB: start and end of region in sequence B; 0 based.</param>
        </member>
        <member name="M:NGit.Diff.Edit.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>Create a new edit.</summary>
            <remarks>Create a new edit.</remarks>
            <param name="as">beginA: start of region in sequence A; 0 based.</param>
            <param name="ae">endA: end of region in sequence A; must be &gt;= as.</param>
            <param name="bs">beginB: start of region in sequence B; 0 based.</param>
            <param name="be">endB: end of region in sequence B; must be &gt;= bs.</param>
        </member>
        <member name="M:NGit.Diff.Edit.GetType">
            <returns>the type of this region</returns>
        </member>
        <member name="M:NGit.Diff.Edit.IsEmpty">
            <returns>true if the edit is empty (lengths of both a and b is zero).</returns>
        </member>
        <member name="M:NGit.Diff.Edit.GetBeginA">
            <returns>start point in sequence A.</returns>
        </member>
        <member name="M:NGit.Diff.Edit.GetEndA">
            <returns>end point in sequence A.</returns>
        </member>
        <member name="M:NGit.Diff.Edit.GetBeginB">
            <returns>start point in sequence B.</returns>
        </member>
        <member name="M:NGit.Diff.Edit.GetEndB">
            <returns>end point in sequence B.</returns>
        </member>
        <member name="M:NGit.Diff.Edit.GetLengthA">
            <returns>length of the region in A.</returns>
        </member>
        <member name="M:NGit.Diff.Edit.GetLengthB">
            <returns>length of the region in B.</returns>
        </member>
        <member name="M:NGit.Diff.Edit.Before(NGit.Diff.Edit)">
            <summary>Construct a new edit representing the region before cut.</summary>
            <remarks>Construct a new edit representing the region before cut.</remarks>
            <param name="cut">
            the cut point. The beginning A and B points are used as the
            end points of the returned edit.
            </param>
            <returns>
            an edit representing the slice of
            <code>this</code>
            edit that occurs
            before
            <code>cut</code>
            starts.
            </returns>
        </member>
        <member name="M:NGit.Diff.Edit.After(NGit.Diff.Edit)">
            <summary>Construct a new edit representing the region after cut.</summary>
            <remarks>Construct a new edit representing the region after cut.</remarks>
            <param name="cut">
            the cut point. The ending A and B points are used as the
            starting points of the returned edit.
            </param>
            <returns>
            an edit representing the slice of
            <code>this</code>
            edit that occurs
            after
            <code>cut</code>
            ends.
            </returns>
        </member>
        <member name="M:NGit.Diff.Edit.ExtendA">
            <summary>
            Increase
            <see cref="M:NGit.Diff.Edit.GetEndA">GetEndA()</see>
            by 1.
            </summary>
        </member>
        <member name="M:NGit.Diff.Edit.ExtendB">
            <summary>
            Increase
            <see cref="M:NGit.Diff.Edit.GetEndB">GetEndB()</see>
            by 1.
            </summary>
        </member>
        <member name="M:NGit.Diff.Edit.Swap">
            <summary>Swap A and B, so the edit goes the other direction.</summary>
            <remarks>Swap A and B, so the edit goes the other direction.</remarks>
        </member>
        <member name="T:NGit.Diff.Edit.Type">
            <summary>Type of edit</summary>
        </member>
        <member name="T:NGit.InflaterCache">
            <summary>Creates zlib based inflaters as necessary for object decompression.</summary>
            <remarks>Creates zlib based inflaters as necessary for object decompression.</remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.InflaterCache.Get" -->
        <member name="M:NGit.InflaterCache.Release(ICSharpCode.SharpZipLib.Zip.Compression.Inflater)">
            <summary>Release an inflater previously obtained from this cache.</summary>
            <remarks>Release an inflater previously obtained from this cache.</remarks>
            <param name="i">
            the inflater to return. May be null, in which case this method
            does nothing.
            </param>
        </member>
        <member name="T:NGit.BranchConfig">
            <summary>Branch section of a Git configuration file.</summary>
            <remarks>Branch section of a Git configuration file.</remarks>
        </member>
        <member name="M:NGit.BranchConfig.#ctor(NGit.Config,System.String)">
            <summary>
            Create a new branch config, which will read configuration from config
            about specified branch.
            </summary>
            <remarks>
            Create a new branch config, which will read configuration from config
            about specified branch.
            </remarks>
            <param name="config">the config to read from</param>
            <param name="branchName">the short branch name of the section to read</param>
        </member>
        <member name="M:NGit.BranchConfig.GetRemoteTrackingBranch">
            <returns>
            the full remote-tracking branch name or <code>null</code> if it
            could not be determined
            </returns>
        </member>
        <member name="T:NGit.Errors.NotSupportedException">
            <summary>JGit encountered a case that it knows it cannot yet handle.</summary>
            <remarks>JGit encountered a case that it knows it cannot yet handle.</remarks>
        </member>
        <member name="M:NGit.Errors.NotSupportedException.#ctor(System.String)">
            <summary>
            Construct a NotSupportedException for some issue JGit cannot
            yet handle.
            </summary>
            <remarks>
            Construct a NotSupportedException for some issue JGit cannot
            yet handle.
            </remarks>
            <param name="s">message describing the issue</param>
        </member>
        <member name="M:NGit.Errors.NotSupportedException.#ctor(System.String,System.Exception)">
            <summary>Construct a NotSupportedException for some issue JGit cannot yet handle.
            	</summary>
            <remarks>Construct a NotSupportedException for some issue JGit cannot yet handle.
            	</remarks>
            <param name="s">message describing the issue</param>
            <param name="why">a lower level implementation specific issue.</param>
        </member>
        <member name="T:NGit.Errors.LockFailedException">
            <summary>An exception occurring when a file cannot be locked</summary>
        </member>
        <member name="M:NGit.Errors.LockFailedException.#ctor(Sharpen.FilePath,System.String)">
            <summary>Construct a CannotLockException for the given file and message</summary>
            <param name="file">file that could not be locked</param>
            <param name="message">exception message</param>
        </member>
        <member name="M:NGit.Errors.LockFailedException.#ctor(Sharpen.FilePath)">
            <summary>Construct a CannotLockException for the given file</summary>
            <param name="file">file that could not be locked</param>
        </member>
        <member name="M:NGit.Errors.LockFailedException.GetFile">
            <summary>Get the file that could not be locked</summary>
            <returns>file</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Api.DeleteTagCommand" -->
        <member name="M:NGit.Api.DeleteTagCommand.#ctor(NGit.Repository)">
            <param name="repo"></param>
        </member>
        <member name="M:NGit.Api.DeleteTagCommand.Call">
            <returns>the list with the full names of the deleted tags</returns>
            <exception cref="T:NGit.Api.Errors.GitAPIException"></exception>
        </member>
        <member name="M:NGit.Api.DeleteTagCommand.SetTags(System.String[])">
            <param name="tags">
            the names of the tags to delete; if not set, this will do
            nothing; invalid tag names will simply be ignored
            </param>
            <returns>this instance</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Api.StatusCommand" -->
        <member name="M:NGit.Api.StatusCommand.#ctor(NGit.Repository)">
            <param name="repo"></param>
        </member>
        <member name="M:NGit.Api.StatusCommand.Call">
            <summary>
            Executes the
            <code>Status</code>
            command with all the options and parameters
            collected by the setter methods of this class. Each instance of this
            class should only be used for one invocation of the command. Don't call
            this method twice on an instance.
            </summary>
            <returns>
            a
            <see cref="T:NGit.Api.Status">Status</see>
            object telling about each path where working
            tree, index or HEAD differ from each other.
            </returns>
            <exception cref="T:NGit.Api.Errors.GitAPIException"></exception>
            <exception cref="T:NGit.Errors.NoWorkTreeException"></exception>
        </member>
        <member name="M:NGit.Api.StatusCommand.SetWorkingTreeIt(NGit.Treewalk.WorkingTreeIterator)">
            <summary>
            To set the
            <see cref="T:NGit.Treewalk.WorkingTreeIterator">NGit.Treewalk.WorkingTreeIterator</see>
            which should be used. If this
            method is not called a standard
            <see cref="T:NGit.Treewalk.FileTreeIterator">NGit.Treewalk.FileTreeIterator</see>
            is used.
            </summary>
            <param name="workingTreeIt">a working tree iterator</param>
            <returns>
            
            <code>this</code>
            </returns>
        </member>
        <member name="M:NGit.Storage.Pack.BaseSearch.AddBase(System.Int32,System.Byte[],System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.Pack.BaseSearch.ReadTree(NGit.AnyObjectId)">
            <exception cref="T:NGit.Errors.MissingObjectException"></exception>
            <exception cref="T:NGit.Errors.IncorrectObjectTypeException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="T:NGit.Transport.TransferConfig">
            <summary>The standard "transfer", "fetch" and "receive" configuration parameters.
            	</summary>
            <remarks>The standard "transfer", "fetch" and "receive" configuration parameters.
            	</remarks>
        </member>
        <member name="F:NGit.Transport.TransferConfig.KEY">
            <summary>
            Key for
            <see cref="M:NGit.Config.Get``1(NGit.Config.SectionParser{``0})">NGit.Config.Get&lt;T&gt;(NGit.Config.SectionParser&lt;T&gt;)
            	</see>
            .
            </summary>
        </member>
        <member name="M:NGit.Transport.TransferConfig.IsFsckObjects">
            <returns>strictly verify received objects?</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Api.CherryPickCommand" -->
        <member name="M:NGit.Api.CherryPickCommand.#ctor(NGit.Repository)">
            <param name="repo"></param>
        </member>
        <member name="M:NGit.Api.CherryPickCommand.Call">
            <summary>
            Executes the
            <code>Cherry-Pick</code>
            command with all the options and
            parameters collected by the setter methods (e.g.
            <see cref="M:NGit.Api.CherryPickCommand.Include(NGit.Ref)">Include(NGit.Ref)</see>
            of
            this class. Each instance of this class should only be used for one
            invocation of the command. Don't call this method twice on an instance.
            </summary>
            <returns>the result of the cherry-pick</returns>
            <exception cref="T:NGit.Api.Errors.GitAPIException">NGit.Api.Errors.GitAPIException
            	</exception>
            <exception cref="T:NGit.Api.Errors.WrongRepositoryStateException">NGit.Api.Errors.WrongRepositoryStateException
            	</exception>
            <exception cref="T:NGit.Api.Errors.ConcurrentRefUpdateException">NGit.Api.Errors.ConcurrentRefUpdateException
            	</exception>
            <exception cref="T:NGit.Api.Errors.UnmergedPathsException">NGit.Api.Errors.UnmergedPathsException
            	</exception>
            <exception cref="T:NGit.Api.Errors.NoMessageException">NGit.Api.Errors.NoMessageException
            	</exception>
            <exception cref="T:NGit.Api.Errors.NoHeadException">NGit.Api.Errors.NoHeadException
            	</exception>
        </member>
        <member name="M:NGit.Api.CherryPickCommand.Include(NGit.Ref)">
            <param name="commit">
            a reference to a commit which is cherry-picked to the current
            head
            </param>
            <returns>
            
            <code>this</code>
            </returns>
        </member>
        <member name="M:NGit.Api.CherryPickCommand.Include(NGit.AnyObjectId)">
            <param name="commit">the Id of a commit which is cherry-picked to the current head
            	</param>
            <returns>
            
            <code>this</code>
            </returns>
        </member>
        <member name="M:NGit.Api.CherryPickCommand.Include(System.String,NGit.AnyObjectId)">
            <param name="name">a name given to the commit</param>
            <param name="commit">the Id of a commit which is cherry-picked to the current head
            	</param>
            <returns>
            
            <code>this</code>
            </returns>
        </member>
        <member name="T:NGit.Api.Errors.RefNotFoundException">
            <summary>Thrown when a Ref can not be resolved</summary>
        </member>
        <member name="M:NGit.Api.Errors.RefNotFoundException.#ctor(System.String)">
            <param name="message"></param>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Api.RenameBranchCommand" -->
        <member name="M:NGit.Api.RenameBranchCommand.#ctor(NGit.Repository)">
            <param name="repo"></param>
        </member>
        <member name="M:NGit.Api.RenameBranchCommand.Call">
            <exception cref="T:NGit.Api.Errors.RefNotFoundException">
            if the old branch can not be found (branch with provided old
            name does not exist or old name resolves to a tag)
            </exception>
            <exception cref="T:NGit.Api.Errors.InvalidRefNameException">
            if the provided new name is <code>null</code> or otherwise
            invalid
            </exception>
            <exception cref="T:NGit.Api.Errors.RefAlreadyExistsException">if a branch with the new name already exists
            	</exception>
            <exception cref="T:NGit.Api.Errors.DetachedHeadException">
            if rename is tried without specifying the old name and HEAD
            is detached
            </exception>
            <exception cref="T:NGit.Api.Errors.GitAPIException"></exception>
        </member>
        <member name="M:NGit.Api.RenameBranchCommand.SetNewName(System.String)">
            <param name="newName">the new name</param>
            <returns>this instance</returns>
        </member>
        <member name="M:NGit.Api.RenameBranchCommand.SetOldName(System.String)">
            <param name="oldName">
            the name of the branch to rename; if not set, the currently
            checked out branch (if any) will be renamed
            </param>
            <returns>this instance</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Api.PushCommand" -->
        <member name="M:NGit.Api.PushCommand.#ctor(NGit.Repository)">
            <param name="repo"></param>
        </member>
        <member name="M:NGit.Api.PushCommand.Call">
            <summary>
            Executes the
            <code>push</code>
            command with all the options and parameters
            collected by the setter methods of this class. Each instance of this
            class should only be used for one invocation of the command (means: one
            call to
            <see cref="M:NGit.Api.PushCommand.Call">Call()</see>
            )
            </summary>
            <returns>
            an iteration over
            <see cref="T:NGit.Transport.PushResult">NGit.Transport.PushResult</see>
            objects
            </returns>
            <exception cref="T:NGit.Api.Errors.InvalidRemoteException">when called with an invalid remote uri
            	</exception>
            <exception cref="T:NGit.Api.Errors.TransportException">when an error occurs with the transport
            </exception>
            <exception cref="T:NGit.Api.Errors.GitAPIException">NGit.Api.Errors.GitAPIException
            	</exception>
        </member>
        <member name="M:NGit.Api.PushCommand.SetRemote(System.String)">
            <summary>The remote (uri or name) used for the push operation.</summary>
            <remarks>
            The remote (uri or name) used for the push operation. If no remote is
            set, the default value of <code>Constants.DEFAULT_REMOTE_NAME</code> will
            be used.
            </remarks>
            <seealso cref="F:NGit.Constants.DEFAULT_REMOTE_NAME">NGit.Constants.DEFAULT_REMOTE_NAME
            	</seealso>
            <param name="remote"></param>
            <returns>
            
            <code>this</code>
            </returns>
        </member>
        <member name="M:NGit.Api.PushCommand.GetRemote">
            <returns>the remote used for the remote operation</returns>
        </member>
        <member name="M:NGit.Api.PushCommand.SetReceivePack(System.String)">
            <summary>The remote executable providing receive-pack service for pack transports.
            	</summary>
            <remarks>
            The remote executable providing receive-pack service for pack transports.
            If no receive-pack is set, the default value of
            <code>RemoteConfig.DEFAULT_RECEIVE_PACK</code> will be used.
            </remarks>
            <seealso cref="F:NGit.Transport.RemoteConfig.DEFAULT_RECEIVE_PACK">NGit.Transport.RemoteConfig.DEFAULT_RECEIVE_PACK
            	</seealso>
            <param name="receivePack"></param>
            <returns>
            
            <code>this</code>
            </returns>
        </member>
        <member name="M:NGit.Api.PushCommand.GetReceivePack">
            <returns>the receive-pack used for the remote operation</returns>
        </member>
        <member name="M:NGit.Api.PushCommand.GetTimeout">
            <returns>the timeout used for the push operation</returns>
        </member>
        <member name="M:NGit.Api.PushCommand.GetProgressMonitor">
            <returns>the progress monitor for the push operation</returns>
        </member>
        <member name="M:NGit.Api.PushCommand.SetProgressMonitor(NGit.ProgressMonitor)">
            <summary>The progress monitor associated with the push operation.</summary>
            <remarks>
            The progress monitor associated with the push operation. By default, this
            is set to <code>NullProgressMonitor</code>
            </remarks>
            <seealso cref="T:NGit.NullProgressMonitor">NGit.NullProgressMonitor</seealso>
            <param name="monitor"></param>
            <returns>
            
            <code>this</code>
            </returns>
        </member>
        <member name="M:NGit.Api.PushCommand.GetRefSpecs">
            <returns>the ref specs</returns>
        </member>
        <member name="M:NGit.Api.PushCommand.SetRefSpecs(NGit.Transport.RefSpec[])">
            <summary>The ref specs to be used in the push operation</summary>
            <param name="specs"></param>
            <returns>
            
            <code>this</code>
            </returns>
        </member>
        <member name="M:NGit.Api.PushCommand.SetRefSpecs(System.Collections.Generic.IList{NGit.Transport.RefSpec})">
            <summary>The ref specs to be used in the push operation</summary>
            <param name="specs"></param>
            <returns>
            
            <code>this</code>
            </returns>
        </member>
        <member name="M:NGit.Api.PushCommand.SetPushAll">
            <summary>Push all branches under refs/heads/*.</summary>
            <remarks>Push all branches under refs/heads/*.</remarks>
            <returns>{code this}</returns>
        </member>
        <member name="M:NGit.Api.PushCommand.SetPushTags">
            <summary>Push all tags under refs/tags/*.</summary>
            <remarks>Push all tags under refs/tags/*.</remarks>
            <returns>{code this}</returns>
        </member>
        <member name="M:NGit.Api.PushCommand.Add(NGit.Ref)">
            <summary>Add a reference to push.</summary>
            <remarks>Add a reference to push.</remarks>
            <param name="ref">the source reference. The remote name will match.</param>
            <returns>
            
            <code>this</code>
            .
            </returns>
        </member>
        <member name="M:NGit.Api.PushCommand.Add(System.String)">
            <summary>Add a reference to push.</summary>
            <remarks>Add a reference to push.</remarks>
            <param name="nameOrSpec">any reference name, or a reference specification.</param>
            <returns>
            
            <code>this</code>
            .
            </returns>
            <exception cref="T:NGit.Api.Errors.JGitInternalException">the reference name cannot be resolved.
            	</exception>
        </member>
        <member name="M:NGit.Api.PushCommand.IsDryRun">
            <returns>the dry run preference for the push operation</returns>
        </member>
        <member name="M:NGit.Api.PushCommand.SetDryRun(System.Boolean)">
            <summary>Sets whether the push operation should be a dry run</summary>
            <param name="dryRun"></param>
            <returns>
            
            <code>this</code>
            </returns>
        </member>
        <member name="M:NGit.Api.PushCommand.IsThin">
            <returns>the thin-pack preference for push operation</returns>
        </member>
        <member name="M:NGit.Api.PushCommand.SetThin(System.Boolean)">
            <summary>Sets the thin-pack preference for push operation.</summary>
            <remarks>
            Sets the thin-pack preference for push operation.
            Default setting is Transport.DEFAULT_PUSH_THIN
            </remarks>
            <param name="thin"></param>
            <returns>
            
            <code>this</code>
            </returns>
        </member>
        <member name="M:NGit.Api.PushCommand.IsForce">
            <returns>the force preference for push operation</returns>
        </member>
        <member name="M:NGit.Api.PushCommand.SetForce(System.Boolean)">
            <summary>Sets the force preference for push operation.</summary>
            <remarks>Sets the force preference for push operation.</remarks>
            <param name="force"></param>
            <returns>
            
            <code>this</code>
            </returns>
        </member>
        <member name="T:NGit.Api.Errors.InvalidRemoteException">
            <summary>Exception thrown when a fetch command was called with an invalid remote</summary>
        </member>
        <member name="M:NGit.Api.Errors.InvalidRemoteException.#ctor(System.String)">
            <param name="msg">message describing the invalid remote.</param>
        </member>
        <member name="M:NGit.Api.Errors.InvalidRemoteException.#ctor(System.String,System.Exception)">
            <param name="msg">message describing the invalid remote.</param>
            <param name="cause">why the remote is invalid.</param>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Diff.HashedSequencePair`1" -->
        <member name="M:NGit.Diff.HashedSequencePair`1.#ctor(NGit.Diff.SequenceComparator{`0},`0,`0)">
            <summary>Construct a pair to provide fast hash codes.</summary>
            <remarks>Construct a pair to provide fast hash codes.</remarks>
            <param name="cmp">the base comparator for the sequence elements.</param>
            <param name="a">the A sequence.</param>
            <param name="b">the B sequence.</param>
        </member>
        <member name="M:NGit.Diff.HashedSequencePair`1.GetComparator">
            <returns>obtain a comparator that uses the cached hash codes.</returns>
        </member>
        <member name="M:NGit.Diff.HashedSequencePair`1.GetA">
            <returns>wrapper around A that includes cached hash codes.</returns>
        </member>
        <member name="M:NGit.Diff.HashedSequencePair`1.GetB">
            <returns>wrapper around B that includes cached hash codes.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Transport.TransportBundleStream" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Transport.TransportBundleStream.#ctor(NGit.Repository,NGit.Transport.URIish,Sharpen.InputStream)" -->
        <member name="M:NGit.Transport.TransportBundleStream.OpenFetch">
            <exception cref="T:NGit.Errors.TransportException"></exception>
        </member>
        <member name="M:NGit.Transport.TransportBundleStream.OpenPush">
            <exception cref="T:System.NotSupportedException"></exception>
        </member>
        <member name="T:NGit.Transport.ReceivePack">
            <summary>Implements the server side of a push connection, receiving objects.</summary>
            <remarks>Implements the server side of a push connection, receiving objects.</remarks>
        </member>
        <member name="F:NGit.Transport.ReceivePack.preReceive">
            <summary>Hook to validate the update commands before execution.</summary>
            <remarks>Hook to validate the update commands before execution.</remarks>
        </member>
        <member name="F:NGit.Transport.ReceivePack.postReceive">
            <summary>Hook to report on the commands after execution.</summary>
            <remarks>Hook to report on the commands after execution.</remarks>
        </member>
        <member name="M:NGit.Transport.ReceivePack.#ctor(NGit.Repository)">
            <summary>Create a new pack receive for an open repository.</summary>
            <remarks>Create a new pack receive for an open repository.</remarks>
            <param name="into">the destination repository.</param>
        </member>
        <member name="M:NGit.Transport.ReceivePack.GetPreReceiveHook">
            <returns>the hook invoked before updates occur.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Transport.ReceivePack.SetPreReceiveHook(NGit.Transport.PreReceiveHook)" -->
        <member name="M:NGit.Transport.ReceivePack.GetPostReceiveHook">
            <returns>the hook invoked after updates occur.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Transport.ReceivePack.SetPostReceiveHook(NGit.Transport.PostReceiveHook)" -->
        <member name="M:NGit.Transport.ReceivePack.Receive(Sharpen.InputStream,Sharpen.OutputStream,Sharpen.OutputStream)">
            <summary>Execute the receive task on the socket.</summary>
            <remarks>Execute the receive task on the socket.</remarks>
            <param name="input">
            raw input to read client commands and pack data from. Caller
            must ensure the input is buffered, otherwise read performance
            may suffer.
            </param>
            <param name="output">
            response back to the Git network client. Caller must ensure
            the output is buffered, otherwise write performance may
            suffer.
            </param>
            <param name="messages">
            secondary "notice" channel to send additional messages out
            through. When run over SSH this should be tied back to the
            standard error channel of the command execution. For most
            other network connections this should be null.
            </param>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:NGit.Transport.ReceivePack.Service">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Transport.ReceivePack._Reporter_185.SendString(System.String)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Transport.ReceivePack._Reporter_192.SendString(System.String)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="T:NGit.Transport.HttpTransport">
            <summary>The base class for transports that use HTTP as underlying protocol.</summary>
            <remarks>
            The base class for transports that use HTTP as underlying protocol. This class
            allows customizing HTTP connection settings.
            </remarks>
        </member>
        <member name="M:NGit.Transport.HttpTransport.#ctor(NGit.Repository,NGit.Transport.URIish)">
            <summary>Create a new transport instance.</summary>
            <remarks>Create a new transport instance.</remarks>
            <param name="local">
            the repository this instance will fetch into, or push out of.
            This must be the repository passed to
            <see cref="M:NGit.Transport.Transport.Open(NGit.Repository,NGit.Transport.URIish)">Transport.Open(NGit.Repository, URIish)
            	</see>
            .
            </param>
            <param name="uri">
            the URI used to access the remote repository. This must be the
            URI passed to
            <see cref="M:NGit.Transport.Transport.Open(NGit.Repository,NGit.Transport.URIish)">Transport.Open(NGit.Repository, URIish)
            	</see>
            .
            </param>
        </member>
        <member name="M:NGit.Transport.HttpTransport.#ctor(NGit.Transport.URIish)">
            <summary>Create a minimal HTTP transport instance not tied to a single repository.
            	</summary>
            <remarks>Create a minimal HTTP transport instance not tied to a single repository.
            	</remarks>
            <param name="uri"></param>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Transport.SideBandInputStream" -->
        <member name="M:NGit.Transport.SideBandInputStream.Read">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Transport.SideBandInputStream.Read(System.Byte[],System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Transport.SideBandInputStream.NeedDataPacket">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Transport.SideBandInputStream.Progress(System.String)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Transport.SideBandInputStream.DoProgressLine(System.String)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Transport.SideBandInputStream.ReadString(System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Util.RefListBuilder`1" -->
        <member name="M:NGit.Util.RefListBuilder`1.#ctor">
            <summary>Create an empty list ready for items to be added.</summary>
            <remarks>Create an empty list ready for items to be added.</remarks>
        </member>
        <member name="M:NGit.Util.RefListBuilder`1.#ctor(System.Int32)">
            <summary>Create an empty list with at least the specified capacity.</summary>
            <remarks>Create an empty list with at least the specified capacity.</remarks>
            <param name="capacity">the new capacity.</param>
        </member>
        <member name="M:NGit.Util.RefListBuilder`1.Size">
            <returns>number of items in this builder's internal collection.</returns>
        </member>
        <member name="M:NGit.Util.RefListBuilder`1.Get(System.Int32)">
            <summary>Get the reference at a particular index.</summary>
            <remarks>Get the reference at a particular index.</remarks>
            <param name="idx">
            the index to obtain. Must be
            <code>0 &lt;= idx &lt; size()</code>
            .
            </param>
            <returns>the reference value, never null.</returns>
        </member>
        <member name="M:NGit.Util.RefListBuilder`1.Remove(System.Int32)">
            <summary>Remove an item at a specific index.</summary>
            <remarks>Remove an item at a specific index.</remarks>
            <param name="idx">position to remove the item from.</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Util.RefListBuilder`1.Add(`0)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Util.RefListBuilder`1.AddAll(NGit.Ref[],System.Int32,System.Int32)" -->
        <member name="M:NGit.Util.RefListBuilder`1.Set(System.Int32,`0)">
            <summary>Replace a single existing element.</summary>
            <remarks>Replace a single existing element.</remarks>
            <param name="idx">index, must have already been added previously.</param>
            <param name="ref">the new reference.</param>
        </member>
        <member name="M:NGit.Util.RefListBuilder`1.Sort">
            <summary>Sort the list's backing array in-place.</summary>
            <remarks>Sort the list's backing array in-place.</remarks>
        </member>
        <member name="M:NGit.Util.RefListBuilder`1.ToRefList">
            <returns>an unmodifiable list using this collection's backing array.</returns>
        </member>
        <member name="T:NGit.Util.QuotedString">
            <summary>Utility functions related to quoted string handling.</summary>
            <remarks>Utility functions related to quoted string handling.</remarks>
        </member>
        <member name="F:NGit.Util.QuotedString.GIT_PATH">
            <summary>Quoting style that obeys the rules Git applies to file names</summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:NGit.Util.QuotedString.BOURNE" -->
        <member name="F:NGit.Util.QuotedString.BOURNE_USER_PATH">
            <summary>Bourne style, but permits <code>~user</code> at the start of the string.
            	</summary>
            <remarks>Bourne style, but permits <code>~user</code> at the start of the string.
            	</remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Util.QuotedString.Quote(System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Util.QuotedString.Dequote(System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Util.QuotedString.Dequote(System.Byte[],System.Int32,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "T:NGit.Util.QuotedString.BourneStyle" -->
        <member name="T:NGit.Util.QuotedString.BourneUserPathStyle">
            <summary>Bourne style, but permits <code>~user</code> at the start of the string.
            	</summary>
            <remarks>Bourne style, but permits <code>~user</code> at the start of the string.
            	</remarks>
        </member>
        <member name="T:NGit.Util.QuotedString.GitPathStyle">
            <summary>Quoting style that obeys the rules Git applies to file names</summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Storage.File.PackIndexWriter" -->
        <member name="F:NGit.Storage.File.PackIndexWriter.TOC">
            <summary>Magic constant indicating post-version 1 format.</summary>
            <remarks>Magic constant indicating post-version 1 format.</remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Storage.File.PackIndexWriter.CreateOldestPossible``1(Sharpen.OutputStream,System.Collections.Generic.IList{``0})" -->
        <member name="M:NGit.Storage.File.PackIndexWriter.CreateVersion(Sharpen.OutputStream,System.Int32)">
            <summary>Create a new writer instance for a specific index format version.</summary>
            <remarks>Create a new writer instance for a specific index format version.</remarks>
            <param name="dst">
            the stream the index data will be written to. If not already
            buffered it will be automatically wrapped in a buffered
            stream. Callers are always responsible for closing the stream.
            </param>
            <param name="version">
            index format version number required by the caller. Exactly
            this formatted version will be written.
            </param>
            <returns>
            a new writer to output an index file of the requested format to
            the supplied stream.
            </returns>
            <exception cref="T:System.ArgumentException">
            the version requested is not supported by this
            implementation.
            </exception>
        </member>
        <member name="F:NGit.Storage.File.PackIndexWriter.out">
            <summary>The index data stream we are responsible for creating.</summary>
            <remarks>The index data stream we are responsible for creating.</remarks>
        </member>
        <member name="F:NGit.Storage.File.PackIndexWriter.tmp">
            <summary>A temporary buffer for use during IO to {link #out}.</summary>
            <remarks>A temporary buffer for use during IO to {link #out}.</remarks>
        </member>
        <member name="F:NGit.Storage.File.PackIndexWriter.entries">
            <summary>The entries this writer must pack.</summary>
            <remarks>The entries this writer must pack.</remarks>
        </member>
        <member name="F:NGit.Storage.File.PackIndexWriter.packChecksum">
            <summary>SHA-1 checksum for the entire pack data.</summary>
            <remarks>SHA-1 checksum for the entire pack data.</remarks>
        </member>
        <member name="M:NGit.Storage.File.PackIndexWriter.#ctor(Sharpen.OutputStream)">
            <summary>Create a new writer instance.</summary>
            <remarks>Create a new writer instance.</remarks>
            <param name="dst">
            the stream this instance outputs to. If not already buffered
            it will be automatically wrapped in a buffered stream.
            </param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Storage.File.PackIndexWriter.Write``1(System.Collections.Generic.IList{``0},System.Byte[])" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Storage.File.PackIndexWriter.WriteImpl" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Storage.File.PackIndexWriter.WriteTOC(System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Storage.File.PackIndexWriter.WriteFanOutTable" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Storage.File.PackIndexWriter.WriteChecksumFooter" -->
        <member name="T:NGit.Storage.File.ByteBufferWindow">
            <summary>
            A window for accessing git packs using a
            <see cref="T:Sharpen.ByteBuffer">Sharpen.ByteBuffer</see>
            for storage.
            </summary>
            <seealso cref="T:NGit.Storage.File.ByteWindow">ByteWindow</seealso>
        </member>
        <member name="M:NGit.Storage.File.ByteBufferWindow.Write(NGit.Storage.Pack.PackOutputStream,System.Int64,System.Int32,Sharpen.MessageDigest)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.ByteBufferWindow.SetInput(System.Int32,ICSharpCode.SharpZipLib.Zip.Compression.Inflater)">
            <exception cref="T:ICSharpCode.SharpZipLib.SharpZipBaseException"></exception>
        </member>
        <member name="T:NGit.Revwalk.FooterKey">
            <summary>
            Case insensitive key for a
            <see cref="T:NGit.Revwalk.FooterLine">FooterLine</see>
            .
            </summary>
        </member>
        <member name="F:NGit.Revwalk.FooterKey.SIGNED_OFF_BY">
            <summary>
            Standard
            <code>Signed-off-by</code>
            
            </summary>
        </member>
        <member name="F:NGit.Revwalk.FooterKey.ACKED_BY">
            <summary>
            Standard
            <code>Acked-by</code>
            
            </summary>
        </member>
        <member name="F:NGit.Revwalk.FooterKey.CC">
            <summary>
            Standard
            <code>CC</code>
            
            </summary>
        </member>
        <member name="M:NGit.Revwalk.FooterKey.#ctor(System.String)">
            <summary>Create a key for a specific footer line.</summary>
            <remarks>Create a key for a specific footer line.</remarks>
            <param name="keyName">name of the footer line.</param>
        </member>
        <member name="M:NGit.Revwalk.FooterKey.GetName">
            <returns>name of this footer line.</returns>
        </member>
        <member name="M:NGit.Revwalk.BoundaryGenerator.Next">
            <exception cref="T:NGit.Errors.MissingObjectException"></exception>
            <exception cref="T:NGit.Errors.IncorrectObjectTypeException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Revwalk.BoundaryGenerator.InitialGenerator.Next">
            <exception cref="T:NGit.Errors.MissingObjectException"></exception>
            <exception cref="T:NGit.Errors.IncorrectObjectTypeException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Merge.MergeResult`1" -->
        <member name="M:NGit.Merge.MergeResult`1.#ctor(System.Collections.Generic.IList{`0})">
            <summary>Creates a new empty MergeResult</summary>
            <param name="sequences">
            contains the common predecessor sequence at position 0
            followed by the merged sequences. This list should not be
            modified anymore during the lifetime of this
            <see cref="T:NGit.Merge.MergeResult`1">MergeResult&lt;S&gt;</see>
            .
            </param>
        </member>
        <member name="M:NGit.Merge.MergeResult`1.Add(System.Int32,System.Int32,System.Int32,NGit.Merge.MergeChunk.ConflictState)">
            <summary>
            Adds a new range from one of the merged sequences or from the common
            predecessor.
            </summary>
            <remarks>
            Adds a new range from one of the merged sequences or from the common
            predecessor. This method can add conflicting and non-conflicting ranges
            controlled by the conflictState parameter
            </remarks>
            <param name="srcIdx">
            determines from which sequence this range comes. An index of
            x specifies the x+1 element in the list of sequences
            specified to the constructor
            </param>
            <param name="begin">
            the first element from the specified sequence which should be
            included in the merge result. Indexes start with 0.
            </param>
            <param name="end">
            specifies the end of the range to be added. The element this
            index points to is the first element which not added to the
            merge result. All elements between begin (including begin) and
            this element are added.
            </param>
            <param name="conflictState">
            when set to NO_CONLICT a non-conflicting range is added.
            This will end implicitly all open conflicts added before.
            </param>
        </member>
        <member name="M:NGit.Merge.MergeResult`1.GetSequences">
            <summary>
            Returns the common predecessor sequence and the merged sequence in one
            list.
            </summary>
            <remarks>
            Returns the common predecessor sequence and the merged sequence in one
            list. The common predecessor is is the first element in the list
            </remarks>
            <returns>
            the common predecessor at position 0 followed by the merged
            sequences.
            </returns>
        </member>
        <member name="M:NGit.Merge.MergeResult`1.Iterator">
            <returns>
            an iterator over the MergeChunks. The iterator does not support
            the remove operation
            </returns>
        </member>
        <member name="M:NGit.Merge.MergeResult`1.ContainsConflicts">
            <returns>true if this merge result contains conflicts</returns>
        </member>
        <member name="T:NGit.Errors.NoWorkTreeException">
            <summary>
            Indicates a
            <see cref="T:NGit.Repository">NGit.Repository</see>
            has no working directory, and is thus bare.
            </summary>
        </member>
        <member name="M:NGit.Errors.NoWorkTreeException.#ctor">
            <summary>Creates an exception indicating there is no work tree for a repository.</summary>
            <remarks>Creates an exception indicating there is no work tree for a repository.</remarks>
        </member>
        <member name="T:NGit.Errors.NoClosingBracketException">
            <summary>
            Thrown when a pattern contains a character group which is open to the right
            side or a character class which is open to the right side.
            </summary>
            <remarks>
            Thrown when a pattern contains a character group which is open to the right
            side or a character class which is open to the right side.
            </remarks>
        </member>
        <member name="M:NGit.Errors.NoClosingBracketException.#ctor(System.Int32,System.String,System.String,System.String)">
            <param name="indexOfOpeningBracket">the position of the [ character which has no ] character.
            	</param>
            <param name="openingBracket">the unclosed bracket.</param>
            <param name="closingBracket">the missing closing bracket.</param>
            <param name="pattern">the invalid pattern.</param>
        </member>
        <member name="T:NGit.Errors.IndexWriteException">
            <summary>Cannot write a modified index.</summary>
            <remarks>
            Cannot write a modified index. This is a serious error that users need to be
            made aware of.
            </remarks>
        </member>
        <member name="M:NGit.Errors.IndexWriteException.#ctor">
            <summary>Constructs an IndexWriteException with the default message.</summary>
            <remarks>Constructs an IndexWriteException with the default message.</remarks>
        </member>
        <member name="M:NGit.Errors.IndexWriteException.#ctor(System.String)">
            <summary>Constructs an IndexWriteException with the specified detail message.</summary>
            <remarks>Constructs an IndexWriteException with the specified detail message.</remarks>
            <param name="s">message</param>
        </member>
        <member name="M:NGit.Errors.IndexWriteException.#ctor(System.String,System.Exception)">
            <summary>Constructs an IndexWriteException with the specified detail message.</summary>
            <remarks>Constructs an IndexWriteException with the specified detail message.</remarks>
            <param name="s">message</param>
            <param name="cause">root cause exception</param>
        </member>
        <member name="T:NGit.Errors.IncorrectObjectTypeException">
            <summary>An inconsistency with respect to handling different object types.</summary>
            <remarks>
            An inconsistency with respect to handling different object types.
            This most likely signals a programming error rather than a corrupt
            object database.
            </remarks>
        </member>
        <member name="M:NGit.Errors.IncorrectObjectTypeException.#ctor(NGit.ObjectId,System.String)">
            <summary>Construct and IncorrectObjectTypeException for the specified object id.</summary>
            <remarks>
            Construct and IncorrectObjectTypeException for the specified object id.
            Provide the type to make it easier to track down the problem.
            </remarks>
            <param name="id">SHA-1</param>
            <param name="type">object type</param>
        </member>
        <member name="M:NGit.Errors.IncorrectObjectTypeException.#ctor(NGit.ObjectId,System.Int32)">
            <summary>Construct and IncorrectObjectTypeException for the specified object id.</summary>
            <remarks>
            Construct and IncorrectObjectTypeException for the specified object id.
            Provide the type to make it easier to track down the problem.
            </remarks>
            <param name="id">SHA-1</param>
            <param name="type">object type</param>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Dircache.DirCacheEntry" -->
        <member name="F:NGit.Dircache.DirCacheEntry.STAGE_0">
            <summary>The standard (fully merged) stage for an entry.</summary>
            <remarks>The standard (fully merged) stage for an entry.</remarks>
        </member>
        <member name="F:NGit.Dircache.DirCacheEntry.STAGE_1">
            <summary>The base tree revision for an entry.</summary>
            <remarks>The base tree revision for an entry.</remarks>
        </member>
        <member name="F:NGit.Dircache.DirCacheEntry.STAGE_2">
            <summary>The first tree revision (usually called "ours").</summary>
            <remarks>The first tree revision (usually called "ours").</remarks>
        </member>
        <member name="F:NGit.Dircache.DirCacheEntry.STAGE_3">
            <summary>The second tree revision (usually called "theirs").</summary>
            <remarks>The second tree revision (usually called "theirs").</remarks>
        </member>
        <member name="F:NGit.Dircache.DirCacheEntry.NAME_MASK">
            <summary>
            Mask applied to data in
            <see cref="F:NGit.Dircache.DirCacheEntry.P_FLAGS">P_FLAGS</see>
            to get the name length.
            </summary>
        </member>
        <member name="F:NGit.Dircache.DirCacheEntry.UPDATE_NEEDED">
            <summary>In-core flag signaling that the entry should be considered as modified.</summary>
            <remarks>In-core flag signaling that the entry should be considered as modified.</remarks>
        </member>
        <member name="F:NGit.Dircache.DirCacheEntry.info">
            <summary>(Possibly shared) header information storage.</summary>
            <remarks>(Possibly shared) header information storage.</remarks>
        </member>
        <member name="F:NGit.Dircache.DirCacheEntry.infoOffset">
            <summary>
            First location within
            <see cref="F:NGit.Dircache.DirCacheEntry.info">info</see>
            where our header starts.
            </summary>
        </member>
        <member name="F:NGit.Dircache.DirCacheEntry.path">
            <summary>Our encoded path name, from the root of the repository.</summary>
            <remarks>Our encoded path name, from the root of the repository.</remarks>
        </member>
        <member name="F:NGit.Dircache.DirCacheEntry.inCoreFlags">
            <summary>Flags which are never stored to disk.</summary>
            <remarks>Flags which are never stored to disk.</remarks>
        </member>
        <member name="M:NGit.Dircache.DirCacheEntry.#ctor(System.Byte[],NGit.Util.MutableInteger,Sharpen.InputStream,Sharpen.MessageDigest,System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Dircache.DirCacheEntry.#ctor(System.String)">
            <summary>Create an empty entry at stage 0.</summary>
            <remarks>Create an empty entry at stage 0.</remarks>
            <param name="newPath">name of the cache entry.</param>
            <exception cref="T:System.ArgumentException">
            If the path starts or ends with "/", or contains "//" either
            "\0". These sequences are not permitted in a git tree object
            or DirCache file.
            </exception>
        </member>
        <member name="M:NGit.Dircache.DirCacheEntry.#ctor(System.String,System.Int32)">
            <summary>Create an empty entry at the specified stage.</summary>
            <remarks>Create an empty entry at the specified stage.</remarks>
            <param name="newPath">name of the cache entry.</param>
            <param name="stage">the stage index of the new entry.</param>
            <exception cref="T:System.ArgumentException">
            If the path starts or ends with "/", or contains "//" either
            "\0". These sequences are not permitted in a git tree object
            or DirCache file.  Or if
            <code>stage</code>
            is outside of the
            range 0..3, inclusive.
            </exception>
        </member>
        <member name="M:NGit.Dircache.DirCacheEntry.#ctor(System.Byte[])">
            <summary>Create an empty entry at stage 0.</summary>
            <remarks>Create an empty entry at stage 0.</remarks>
            <param name="newPath">name of the cache entry, in the standard encoding.</param>
            <exception cref="T:System.ArgumentException">
            If the path starts or ends with "/", or contains "//" either
            "\0". These sequences are not permitted in a git tree object
            or DirCache file.
            </exception>
        </member>
        <member name="M:NGit.Dircache.DirCacheEntry.#ctor(System.Byte[],System.Int32)">
            <summary>Create an empty entry at the specified stage.</summary>
            <remarks>Create an empty entry at the specified stage.</remarks>
            <param name="newPath">name of the cache entry, in the standard encoding.</param>
            <param name="stage">the stage index of the new entry.</param>
            <exception cref="T:System.ArgumentException">
            If the path starts or ends with "/", or contains "//" either
            "\0". These sequences are not permitted in a git tree object
            or DirCache file.  Or if
            <code>stage</code>
            is outside of the
            range 0..3, inclusive.
            </exception>
        </member>
        <member name="M:NGit.Dircache.DirCacheEntry.Write(Sharpen.OutputStream)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Dircache.DirCacheEntry.MightBeRacilyClean(System.Int32,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Dircache.DirCacheEntry.SmudgeRacilyClean" -->
        <member name="M:NGit.Dircache.DirCacheEntry.GetCreationTime">
            <summary>Get the cached creation time of this file, in milliseconds.</summary>
            <remarks>Get the cached creation time of this file, in milliseconds.</remarks>
            <returns>
            cached creation time of this file, in milliseconds since the
            Java epoch (midnight Jan 1, 1970 UTC).
            </returns>
        </member>
        <member name="M:NGit.Dircache.DirCacheEntry.SetCreationTime(System.Int64)">
            <summary>Set the cached creation time of this file, using milliseconds.</summary>
            <remarks>Set the cached creation time of this file, using milliseconds.</remarks>
            <param name="when">new cached creation time of the file, in milliseconds.</param>
        </member>
        <member name="M:NGit.Dircache.DirCacheEntry.SetLength(System.Int32)">
            <summary>Set the cached size (in bytes) of this file.</summary>
            <remarks>Set the cached size (in bytes) of this file.</remarks>
            <param name="sz">
            new cached size of the file, as bytes. If the file is larger
            than 2G, cast it to (int) before calling this method.
            </param>
        </member>
        <member name="M:NGit.Dircache.DirCacheEntry.SetLength(System.Int64)">
            <summary>Set the cached size (in bytes) of this file.</summary>
            <remarks>Set the cached size (in bytes) of this file.</remarks>
            <param name="sz">new cached size of the file, as bytes.</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Dircache.DirCacheEntry.GetObjectId" -->
        <member name="M:NGit.Dircache.DirCacheEntry.SetObjectId(NGit.AnyObjectId)">
            <summary>Set the ObjectId for the entry.</summary>
            <remarks>Set the ObjectId for the entry.</remarks>
            <param name="id">
            new object identifier for the entry. May be
            <see cref="P:NGit.ObjectId.ZeroId">NGit.ObjectId.ZeroId()</see>
            to remove the current identifier.
            </param>
        </member>
        <member name="M:NGit.Dircache.DirCacheEntry.SetObjectIdFromRaw(System.Byte[],System.Int32)">
            <summary>Set the ObjectId for the entry from the raw binary representation.</summary>
            <remarks>Set the ObjectId for the entry from the raw binary representation.</remarks>
            <param name="bs">
            the raw byte buffer to read from. At least 20 bytes after p
            must be available within this byte array.
            </param>
            <param name="p">position to read the first byte of data from.</param>
        </member>
        <member name="M:NGit.Dircache.DirCacheEntry.ToString">
            <summary>Use for debugging only !</summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Dircache.DirCacheEntry.CopyMetaData(NGit.Dircache.DirCacheEntry)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Dircache.DirCacheEntry.CopyMetaData(NGit.Dircache.DirCacheEntry,System.Boolean)" -->
        <!-- Badly formed XML comment ignored for member "P:NGit.Dircache.DirCacheEntry.IsSmudged" -->
        <!-- Badly formed XML comment ignored for member "P:NGit.Dircache.DirCacheEntry.IsAssumeValid" -->
        <member name="P:NGit.Dircache.DirCacheEntry.IsUpdateNeeded">
            <returns>true if this entry should be checked for changes</returns>
            <summary>Set whether this entry must be checked for changes</summary>
            <value></value>
        </member>
        <!-- Badly formed XML comment ignored for member "P:NGit.Dircache.DirCacheEntry.Stage" -->
        <member name="P:NGit.Dircache.DirCacheEntry.IsSkipWorkTree">
            <summary>Returns whether this entry should be skipped from the working tree.</summary>
            <remarks>Returns whether this entry should be skipped from the working tree.</remarks>
            <returns>true if this entry should be skipepd.</returns>
        </member>
        <member name="P:NGit.Dircache.DirCacheEntry.IsIntentToAdd">
            <summary>Returns whether this entry is intent to be added to the Index.</summary>
            <remarks>Returns whether this entry is intent to be added to the Index.</remarks>
            <returns>true if this entry is intent to add.</returns>
        </member>
        <member name="P:NGit.Dircache.DirCacheEntry.RawMode">
            <summary>
            Obtain the raw
            <see cref="T:NGit.FileMode">NGit.FileMode</see>
            bits for this entry.
            </summary>
            <returns>mode bits for the entry.</returns>
            <seealso cref="M:NGit.FileMode.FromBits(System.Int32)">NGit.FileMode.FromBits(int)</seealso>
        </member>
        <member name="P:NGit.Dircache.DirCacheEntry.FileMode">
            <summary>
            Obtain the
            <see cref="T:NGit.FileMode">NGit.FileMode</see>
            for this entry.
            </summary>
            <returns>the file mode singleton for this entry.</returns>
            <summary>Set the file mode for this entry.</summary>
            <remarks>Set the file mode for this entry.</remarks>
            <value>the new mode constant.</value>
            <exception cref="T:System.ArgumentException">
            If
            <code>mode</code>
            is
            <see cref="F:NGit.FileMode.MISSING">NGit.FileMode.MISSING</see>
            ,
            <see cref="F:NGit.FileMode.TREE">NGit.FileMode.TREE</see>
            , or any other type code not permitted
            in a tree object.
            </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "P:NGit.Dircache.DirCacheEntry.LastModified" -->
        <!-- Badly formed XML comment ignored for member "P:NGit.Dircache.DirCacheEntry.Length" -->
        <!-- Badly formed XML comment ignored for member "P:NGit.Dircache.DirCacheEntry.PathString" -->
        <member name="P:NGit.Dircache.DirCacheEntry.IsExtended">
            <returns>true if the entry contains extended flags.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Api.LogCommand" -->
        <member name="M:NGit.Api.LogCommand.#ctor(NGit.Repository)">
            <param name="repo"></param>
        </member>
        <member name="M:NGit.Api.LogCommand.Call">
            <summary>
            Executes the
            <code>Log</code>
            command with all the options and parameters
            collected by the setter methods (e.g.
            <see cref="M:NGit.Api.LogCommand.Add(NGit.AnyObjectId)">Add(NGit.AnyObjectId)</see>
            ,
            <see cref="M:NGit.Api.LogCommand.Not(NGit.AnyObjectId)">Not(NGit.AnyObjectId)</see>
            , ..) of this class. Each instance of this class
            should only be used for one invocation of the command. Don't call this
            method twice on an instance.
            </summary>
            <returns>an iteration over RevCommits</returns>
            <exception cref="T:NGit.Api.Errors.NoHeadException">of the references ref cannot be resolved
            	</exception>
            <exception cref="T:NGit.Api.Errors.GitAPIException"></exception>
        </member>
        <member name="M:NGit.Api.LogCommand.Add(NGit.AnyObjectId)">
            <summary>Mark a commit to start graph traversal from.</summary>
            <remarks>Mark a commit to start graph traversal from.</remarks>
            <seealso cref="M:NGit.Revwalk.RevWalk.MarkStart(NGit.Revwalk.RevCommit)">NGit.Revwalk.RevWalk.MarkStart(NGit.Revwalk.RevCommit)
            	</seealso>
            <param name="start"></param>
            <returns>
            
            <code>this</code>
            </returns>
            <exception cref="T:NGit.Errors.MissingObjectException">
            the commit supplied is not available from the object
            database. This usually indicates the supplied commit is
            invalid, but the reference was constructed during an earlier
            invocation to
            <see cref="M:NGit.Revwalk.RevWalk.LookupCommit(NGit.AnyObjectId)">NGit.Revwalk.RevWalk.LookupCommit(NGit.AnyObjectId)
            	</see>
            .
            </exception>
            <exception cref="T:NGit.Errors.IncorrectObjectTypeException">
            the object was not parsed yet and it was discovered during
            parsing that it is not actually a commit. This usually
            indicates the caller supplied a non-commit SHA-1 to
            <see cref="M:NGit.Revwalk.RevWalk.LookupCommit(NGit.AnyObjectId)">NGit.Revwalk.RevWalk.LookupCommit(NGit.AnyObjectId)
            	</see>
            .
            </exception>
            <exception cref="T:NGit.Api.Errors.JGitInternalException">
            a low-level exception of JGit has occurred. The original
            exception can be retrieved by calling
            <see cref="P:System.Exception.InnerException">System.Exception.InnerException()</see>
            . Expect only
            <code>IOException's</code>
            to be wrapped. Subclasses of
            <see cref="T:System.IO.IOException">System.IO.IOException</see>
            (e.g.
            <see cref="T:NGit.Errors.MissingObjectException">NGit.Errors.MissingObjectException
            	</see>
            ) are
            typically not wrapped here but thrown as original exception
            </exception>
        </member>
        <member name="M:NGit.Api.LogCommand.Not(NGit.AnyObjectId)">
            <summary>
            Same as
            <code>--not start</code>
            , or
            <code>^start</code>
            </summary>
            <param name="start"></param>
            <returns>
            
            <code>this</code>
            </returns>
            <exception cref="T:NGit.Errors.MissingObjectException">
            the commit supplied is not available from the object
            database. This usually indicates the supplied commit is
            invalid, but the reference was constructed during an earlier
            invocation to
            <see cref="M:NGit.Revwalk.RevWalk.LookupCommit(NGit.AnyObjectId)">NGit.Revwalk.RevWalk.LookupCommit(NGit.AnyObjectId)
            	</see>
            .
            </exception>
            <exception cref="T:NGit.Errors.IncorrectObjectTypeException">
            the object was not parsed yet and it was discovered during
            parsing that it is not actually a commit. This usually
            indicates the caller supplied a non-commit SHA-1 to
            <see cref="M:NGit.Revwalk.RevWalk.LookupCommit(NGit.AnyObjectId)">NGit.Revwalk.RevWalk.LookupCommit(NGit.AnyObjectId)
            	</see>
            .
            </exception>
            <exception cref="T:NGit.Api.Errors.JGitInternalException">
            a low-level exception of JGit has occurred. The original
            exception can be retrieved by calling
            <see cref="P:System.Exception.InnerException">System.Exception.InnerException()</see>
            . Expect only
            <code>IOException's</code>
            to be wrapped. Subclasses of
            <see cref="T:System.IO.IOException">System.IO.IOException</see>
            (e.g.
            <see cref="T:NGit.Errors.MissingObjectException">NGit.Errors.MissingObjectException
            	</see>
            ) are
            typically not wrapped here but thrown as original exception
            </exception>
        </member>
        <member name="M:NGit.Api.LogCommand.AddRange(NGit.AnyObjectId,NGit.AnyObjectId)">
            <summary>
            Adds the range
            <code>since..until</code>
            </summary>
            <param name="since"></param>
            <param name="until"></param>
            <returns>
            
            <code>this</code>
            </returns>
            <exception cref="T:NGit.Errors.MissingObjectException">
            the commit supplied is not available from the object
            database. This usually indicates the supplied commit is
            invalid, but the reference was constructed during an earlier
            invocation to
            <see cref="M:NGit.Revwalk.RevWalk.LookupCommit(NGit.AnyObjectId)">NGit.Revwalk.RevWalk.LookupCommit(NGit.AnyObjectId)
            	</see>
            .
            </exception>
            <exception cref="T:NGit.Errors.IncorrectObjectTypeException">
            the object was not parsed yet and it was discovered during
            parsing that it is not actually a commit. This usually
            indicates the caller supplied a non-commit SHA-1 to
            <see cref="M:NGit.Revwalk.RevWalk.LookupCommit(NGit.AnyObjectId)">NGit.Revwalk.RevWalk.LookupCommit(NGit.AnyObjectId)
            	</see>
            .
            </exception>
            <exception cref="T:NGit.Api.Errors.JGitInternalException">
            a low-level exception of JGit has occurred. The original
            exception can be retrieved by calling
            <see cref="P:System.Exception.InnerException">System.Exception.InnerException()</see>
            . Expect only
            <code>IOException's</code>
            to be wrapped. Subclasses of
            <see cref="T:System.IO.IOException">System.IO.IOException</see>
            (e.g.
            <see cref="T:NGit.Errors.MissingObjectException">NGit.Errors.MissingObjectException
            	</see>
            ) are
            typically not wrapped here but thrown as original exception
            </exception>
        </member>
        <member name="M:NGit.Api.LogCommand.All">
            <summary>Add all refs as commits to start the graph traversal from.</summary>
            <remarks>Add all refs as commits to start the graph traversal from.</remarks>
            <seealso cref="M:NGit.Api.LogCommand.Add(NGit.AnyObjectId)">Add(NGit.AnyObjectId)</seealso>
            <returns>
            
            <code>this</code>
            </returns>
            <exception cref="T:System.IO.IOException">the references could not be accessed</exception>
        </member>
        <member name="M:NGit.Api.LogCommand.AddPath(System.String)">
            <summary>Show only commits that affect any of the specified paths.</summary>
            <remarks>
            Show only commits that affect any of the specified paths. The path must
            either name a file or a directory exactly. Note that regex expressions or
            wildcards are not supported.
            </remarks>
            <param name="path">a path is relative to the top level of the repository</param>
            <returns>
            
            <code>this</code>
            </returns>
        </member>
        <member name="M:NGit.Api.LogCommand.SetSkip(System.Int32)">
            <summary>Skip the number of commits before starting to show the commit output.</summary>
            <remarks>Skip the number of commits before starting to show the commit output.</remarks>
            <param name="skip">the number of commits to skip</param>
            <returns>
            
            <code>this</code>
            </returns>
        </member>
        <member name="M:NGit.Api.LogCommand.SetMaxCount(System.Int32)">
            <summary>Limit the number of commits to output.</summary>
            <remarks>Limit the number of commits to output.</remarks>
            <param name="maxCount">the limit</param>
            <returns>
            
            <code>this</code>
            </returns>
        </member>
        <member name="M:NGit.Api.LogCommand.Add(System.Boolean,NGit.AnyObjectId)">
            <exception cref="T:NGit.Errors.MissingObjectException"></exception>
            <exception cref="T:NGit.Errors.IncorrectObjectTypeException"></exception>
            <exception cref="T:NGit.Api.Errors.JGitInternalException"></exception>
        </member>
        <member name="T:NGit.TagBuilder">
            <summary>Mutable builder to construct an annotated tag recording a project state.
            	</summary>
            <remarks>
            Mutable builder to construct an annotated tag recording a project state.
            Applications should use this object when they need to manually construct a
            tag and want precise control over its fields.
            To read a tag object, construct a
            <see cref="T:NGit.Revwalk.RevWalk">NGit.Revwalk.RevWalk</see>
            and obtain a
            <see cref="T:NGit.Revwalk.RevTag">NGit.Revwalk.RevTag</see>
            instance by calling
            <see cref="M:NGit.Revwalk.RevWalk.ParseTag(NGit.AnyObjectId)">NGit.Revwalk.RevWalk.ParseTag(AnyObjectId)
            	</see>
            .
            </remarks>
        </member>
        <member name="M:NGit.TagBuilder.GetObjectType">
            <returns>the type of object this tag refers to.</returns>
        </member>
        <member name="M:NGit.TagBuilder.GetObjectId">
            <returns>the object this tag refers to.</returns>
        </member>
        <member name="M:NGit.TagBuilder.SetObjectId(NGit.AnyObjectId,System.Int32)">
            <summary>Set the object this tag refers to, and its type.</summary>
            <remarks>Set the object this tag refers to, and its type.</remarks>
            <param name="obj">the object.</param>
            <param name="objType">
            the type of
            <code>obj</code>
            . Must be a valid type code.
            </param>
        </member>
        <member name="M:NGit.TagBuilder.SetObjectId(NGit.Revwalk.RevObject)">
            <summary>Set the object this tag refers to, and infer its type.</summary>
            <remarks>Set the object this tag refers to, and infer its type.</remarks>
            <param name="obj">the object the tag will refer to.</param>
        </member>
        <member name="M:NGit.TagBuilder.GetTag">
            <returns>
            short name of the tag (no
            <code>refs/tags/</code>
            prefix).
            </returns>
        </member>
        <member name="M:NGit.TagBuilder.SetTag(System.String)">
            <summary>Set the name of this tag.</summary>
            <remarks>Set the name of this tag.</remarks>
            <param name="shortName">
            new short name of the tag. This short name should not start
            with
            <code>refs/</code>
            as typically a tag is stored under the
            reference derived from
            <code>"refs/tags/" + getTag()</code>
            .
            </param>
        </member>
        <member name="M:NGit.TagBuilder.GetTagger">
            <returns>creator of this tag. May be null.</returns>
        </member>
        <member name="M:NGit.TagBuilder.SetTagger(NGit.PersonIdent)">
            <summary>Set the creator of this tag.</summary>
            <remarks>Set the creator of this tag.</remarks>
            <param name="taggerIdent">the creator. May be null.</param>
        </member>
        <member name="M:NGit.TagBuilder.GetMessage">
            <returns>the complete commit message.</returns>
        </member>
        <member name="M:NGit.TagBuilder.SetMessage(System.String)">
            <summary>Set the tag's message.</summary>
            <remarks>Set the tag's message.</remarks>
            <param name="newMessage">the tag's message.</param>
        </member>
        <member name="M:NGit.TagBuilder.Build">
            <summary>Format this builder's state as an annotated tag object.</summary>
            <remarks>Format this builder's state as an annotated tag object.</remarks>
            <returns>
            this object in the canonical annotated tag format, suitable for
            storage in a repository.
            </returns>
        </member>
        <member name="M:NGit.TagBuilder.ToByteArray">
            <summary>Format this builder's state as an annotated tag object.</summary>
            <remarks>Format this builder's state as an annotated tag object.</remarks>
            <returns>
            this object in the canonical annotated tag format, suitable for
            storage in a repository.
            </returns>
        </member>
        <member name="T:NGit.RepositoryState">
            <summary>
            Important state of the repository that affects what can and cannot bed
            done.
            </summary>
            <remarks>
            Important state of the repository that affects what can and cannot bed
            done. This is things like unhandled conflicted merges and unfinished rebase.
            The granularity and set of states are somewhat arbitrary. The methods
            on the state are the only supported means of deciding what to do.
            </remarks>
        </member>
        <member name="F:NGit.RepositoryState.BARE">
            <summary>Has no work tree and cannot be used for normal editing.</summary>
            <remarks>Has no work tree and cannot be used for normal editing.</remarks>
        </member>
        <member name="F:NGit.RepositoryState.SAFE">
            <summary>A safe state for working normally</summary>
        </member>
        <member name="F:NGit.RepositoryState.MERGING">
            <summary>An unfinished merge.</summary>
            <remarks>An unfinished merge. Must resolve or reset before continuing normally</remarks>
        </member>
        <member name="F:NGit.RepositoryState.MERGING_RESOLVED">
            <summary>An merge where all conflicts have been resolved.</summary>
            <remarks>
            An merge where all conflicts have been resolved. The index does not
            contain any unmerged paths.
            </remarks>
        </member>
        <member name="F:NGit.RepositoryState.CHERRY_PICKING">
            <summary>An unfinished cherry-pick.</summary>
            <remarks>An unfinished cherry-pick. Must resolve or reset before continuing normally
            	</remarks>
        </member>
        <member name="F:NGit.RepositoryState.CHERRY_PICKING_RESOLVED">
            <summary>A cherry-pick where all conflicts have been resolved.</summary>
            <remarks>
            A cherry-pick where all conflicts have been resolved. The index does not
            contain any unmerged paths.
            </remarks>
        </member>
        <member name="F:NGit.RepositoryState.REBASING">
            <summary>An unfinished rebase or am.</summary>
            <remarks>An unfinished rebase or am. Must resolve, skip or abort before normal work can take place
            	</remarks>
        </member>
        <member name="F:NGit.RepositoryState.REBASING_REBASING">
            <summary>An unfinished rebase.</summary>
            <remarks>An unfinished rebase. Must resolve, skip or abort before normal work can take place
            	</remarks>
        </member>
        <member name="F:NGit.RepositoryState.APPLY">
            <summary>An unfinished apply.</summary>
            <remarks>An unfinished apply. Must resolve, skip or abort before normal work can take place
            	</remarks>
        </member>
        <member name="F:NGit.RepositoryState.REBASING_MERGE">
            <summary>An unfinished rebase with merge.</summary>
            <remarks>An unfinished rebase with merge. Must resolve, skip or abort before normal work can take place
            	</remarks>
        </member>
        <member name="F:NGit.RepositoryState.REBASING_INTERACTIVE">
            <summary>An unfinished interactive rebase.</summary>
            <remarks>An unfinished interactive rebase. Must resolve, skip or abort before normal work can take place
            	</remarks>
        </member>
        <member name="F:NGit.RepositoryState.BISECTING">
            <summary>Bisecting being done.</summary>
            <remarks>Bisecting being done. Normal work may continue but is discouraged</remarks>
        </member>
        <member name="M:NGit.RepositoryState.CanCheckout">
            <returns>true if changing HEAD is sane.</returns>
        </member>
        <member name="M:NGit.RepositoryState.CanCommit">
            <returns>true if we can commit</returns>
        </member>
        <member name="M:NGit.RepositoryState.CanResetHead">
            <returns>true if reset to another HEAD is considered SAFE</returns>
        </member>
        <member name="M:NGit.RepositoryState.CanAmend">
            <returns>true if amending is considered SAFE</returns>
        </member>
        <member name="M:NGit.RepositoryState.GetDescription">
            <returns>a human readable description of the state.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.BatchRefUpdate" -->
        <member name="F:NGit.BatchRefUpdate.commands">
            <summary>Commands to apply during this batch.</summary>
            <remarks>Commands to apply during this batch.</remarks>
        </member>
        <member name="F:NGit.BatchRefUpdate.allowNonFastForwards">
            <summary>Does the caller permit a forced update on a reference?</summary>
        </member>
        <member name="F:NGit.BatchRefUpdate.refLogIdent">
            <summary>Identity to record action as within the reflog.</summary>
            <remarks>Identity to record action as within the reflog.</remarks>
        </member>
        <member name="F:NGit.BatchRefUpdate.refLogMessage">
            <summary>Message the caller wants included in the reflog.</summary>
            <remarks>Message the caller wants included in the reflog.</remarks>
        </member>
        <member name="F:NGit.BatchRefUpdate.refLogIncludeResult">
            <summary>
            Should the result value be appended to
            <see cref="F:NGit.BatchRefUpdate.refLogMessage">refLogMessage</see>
            .
            </summary>
        </member>
        <member name="M:NGit.BatchRefUpdate.#ctor(NGit.RefDatabase)">
            <summary>Initialize a new batch update.</summary>
            <remarks>Initialize a new batch update.</remarks>
            <param name="refdb">the reference database of the repository to be updated.</param>
        </member>
        <member name="M:NGit.BatchRefUpdate.IsAllowNonFastForwards">
            <returns>
            true if the batch update will permit a non-fast-forward update to
            an existing reference.
            </returns>
        </member>
        <member name="M:NGit.BatchRefUpdate.SetAllowNonFastForwards(System.Boolean)">
            <summary>Set if this update wants to permit a forced update.</summary>
            <remarks>Set if this update wants to permit a forced update.</remarks>
            <param name="allow">true if this update batch should ignore merge tests.</param>
            <returns>
            
            <code>this</code>
            .
            </returns>
        </member>
        <member name="M:NGit.BatchRefUpdate.GetRefLogIdent">
            <returns>identity of the user making the change in the reflog.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.BatchRefUpdate.SetRefLogIdent(NGit.PersonIdent)" -->
        <member name="M:NGit.BatchRefUpdate.GetRefLogMessage">
            <summary>Get the message to include in the reflog.</summary>
            <remarks>Get the message to include in the reflog.</remarks>
            <returns>
            message the caller wants to include in the reflog; null if the
            update should not be logged.
            </returns>
        </member>
        <member name="M:NGit.BatchRefUpdate.IsRefLogIncludingResult">
            <returns>
            
            <code>true</code>
            if the ref log message should show the result.
            </returns>
        </member>
        <member name="M:NGit.BatchRefUpdate.SetRefLogMessage(System.String,System.Boolean)">
            <summary>Set the message to include in the reflog.</summary>
            <remarks>Set the message to include in the reflog.</remarks>
            <param name="msg">
            the message to describe this change. It may be null if
            appendStatus is null in order not to append to the reflog
            </param>
            <param name="appendStatus">
            true if the status of the ref change (fast-forward or
            forced-update) should be appended to the user supplied
            message.
            </param>
            <returns>
            
            <code>this</code>
            .
            </returns>
        </member>
        <member name="M:NGit.BatchRefUpdate.DisableRefLog">
            <summary>Don't record this update in the ref's associated reflog.</summary>
            <remarks>Don't record this update in the ref's associated reflog.</remarks>
            <returns>
            
            <code>this</code>
            .
            </returns>
        </member>
        <member name="M:NGit.BatchRefUpdate.IsRefLogDisabled">
            <returns>
            true if log has been disabled by
            <see cref="M:NGit.BatchRefUpdate.DisableRefLog">DisableRefLog()</see>
            .
            </returns>
        </member>
        <member name="M:NGit.BatchRefUpdate.GetCommands">
            <returns>commands this update will process.</returns>
        </member>
        <member name="M:NGit.BatchRefUpdate.AddCommand(NGit.Transport.ReceiveCommand)">
            <summary>Add a single command to this batch update.</summary>
            <remarks>Add a single command to this batch update.</remarks>
            <param name="cmd">the command to add, must not be null.</param>
            <returns>
            
            <code>this</code>
            .
            </returns>
        </member>
        <member name="M:NGit.BatchRefUpdate.AddCommand(NGit.Transport.ReceiveCommand[])">
            <summary>Add commands to this batch update.</summary>
            <remarks>Add commands to this batch update.</remarks>
            <param name="cmd">the commands to add, must not be null.</param>
            <returns>
            
            <code>this</code>
            .
            </returns>
        </member>
        <member name="M:NGit.BatchRefUpdate.AddCommand(System.Collections.Generic.ICollection{NGit.Transport.ReceiveCommand})">
            <summary>Add commands to this batch update.</summary>
            <remarks>Add commands to this batch update.</remarks>
            <param name="cmd">the commands to add, must not be null.</param>
            <returns>
            
            <code>this</code>
            .
            </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.BatchRefUpdate.Execute(NGit.Revwalk.RevWalk,NGit.ProgressMonitor)" -->
        <member name="M:NGit.BatchRefUpdate.NewUpdate(NGit.Transport.ReceiveCommand)">
            <summary>Create a new RefUpdate copying the batch settings.</summary>
            <remarks>Create a new RefUpdate copying the batch settings.</remarks>
            <param name="cmd">specific command the update should be created to copy.</param>
            <returns>a single reference update command.</returns>
            <exception cref="T:System.IO.IOException">
            the reference database cannot make a new update object for
            the given reference.
            </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Util.GitDateFormatter" -->
        <member name="M:NGit.Util.GitDateFormatter.#ctor(NGit.Util.GitDateFormatter.Format)">
            <summary>Create a new Git oriented date formatter</summary>
            <param name="format"></param>
        </member>
        <member name="M:NGit.Util.GitDateFormatter.FormatDate(NGit.PersonIdent)">
            <summary>
            Format committer, author or tagger ident according to this formatter's
            specification.
            </summary>
            <remarks>
            Format committer, author or tagger ident according to this formatter's
            specification.
            </remarks>
            <param name="ident"></param>
            <returns>formatted version of date, time and time zone</returns>
        </member>
        <member name="T:NGit.Util.GitDateFormatter.Format">
            <summary>Git and JGit formats</summary>
        </member>
        <member name="T:NGit.Errors.TooLargeObjectInPackException">
            <summary>Thrown when PackParser finds an object larger than a predefined limit</summary>
        </member>
        <member name="M:NGit.Errors.TooLargeObjectInPackException.#ctor(System.Int64)">
            <summary>
            Construct a too large object in pack exception when the exact size of the
            too large object is not available.
            </summary>
            <remarks>
            Construct a too large object in pack exception when the exact size of the
            too large object is not available. This will be used when we find out
            that a delta sequence is already larger than the maxObjectSizeLimit but
            don't want to inflate the delta just to find out the exact size of the
            resulting object.
            </remarks>
            <param name="maxObjectSizeLimit">the maximum object size limit</param>
        </member>
        <member name="M:NGit.Errors.TooLargeObjectInPackException.#ctor(System.Int64,System.Int64)">
            <summary>
            Construct a too large object in pack exception when the exact size of the
            too large object is known.
            </summary>
            <remarks>
            Construct a too large object in pack exception when the exact size of the
            too large object is known.
            </remarks>
            <param name="objectSize"></param>
            <param name="maxObjectSizeLimit"></param>
        </member>
        <member name="T:NGit.Revwalk.DepthWalk">
            <summary>Interface for revision walkers that perform depth filtering.</summary>
            <remarks>Interface for revision walkers that perform depth filtering.</remarks>
        </member>
        <member name="M:NGit.Revwalk.DepthWalk.GetDepth">
            <returns>Depth to filter to.</returns>
        </member>
        <member name="M:NGit.Revwalk.DepthWalk.GetUnshallowFlag">
            <returns>flag marking commits that should become unshallow.</returns>
        </member>
        <member name="M:NGit.Revwalk.DepthWalk.GetReinterestingFlag">
            <returns>flag marking commits that are interesting again.</returns>
        </member>
        <member name="T:NGit.Revwalk.Depthwalk.Commit">
            <summary>RevCommit with a depth (in commits) from a root.</summary>
            <remarks>RevCommit with a depth (in commits) from a root.</remarks>
        </member>
        <member name="F:NGit.Revwalk.Depthwalk.Commit.depth">
            <summary>Depth of this commit in the graph, via shortest path.</summary>
            <remarks>Depth of this commit in the graph, via shortest path.</remarks>
        </member>
        <member name="M:NGit.Revwalk.Depthwalk.Commit.GetDepth">
            <returns>depth of this commit, as found by the shortest path.</returns>
        </member>
        <member name="M:NGit.Revwalk.Depthwalk.Commit.#ctor(NGit.AnyObjectId)">
            <summary>Initialize a new commit.</summary>
            <remarks>Initialize a new commit.</remarks>
            <param name="id">object name for the commit.</param>
        </member>
        <member name="T:NGit.Revwalk.Depthwalk.RevWalk">
            <summary>Subclass of RevWalk that performs depth filtering.</summary>
            <remarks>Subclass of RevWalk that performs depth filtering.</remarks>
        </member>
        <member name="M:NGit.Revwalk.Depthwalk.RevWalk.#ctor(NGit.Repository,System.Int32)">
            <param name="repo">Repository to walk</param>
            <param name="depth">Maximum depth to return</param>
        </member>
        <member name="M:NGit.Revwalk.Depthwalk.RevWalk.#ctor(NGit.ObjectReader,System.Int32)">
            <param name="or">ObjectReader to use</param>
            <param name="depth">Maximum depth to return</param>
        </member>
        <member name="M:NGit.Revwalk.Depthwalk.RevWalk.MarkRoot(NGit.Revwalk.RevCommit)">
            <summary>Mark a root commit (i.e., one whose depth should be considered 0.)</summary>
            <param name="c">Commit to mark</param>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
            <exception cref="T:NGit.Errors.IncorrectObjectTypeException">NGit.Errors.IncorrectObjectTypeException
            	</exception>
            <exception cref="T:NGit.Errors.MissingObjectException">NGit.Errors.MissingObjectException
            	</exception>
        </member>
        <member name="T:NGit.Revwalk.Depthwalk.ObjectWalk">
            <summary>Subclass of ObjectWalk that performs depth filtering.</summary>
            <remarks>Subclass of ObjectWalk that performs depth filtering.</remarks>
        </member>
        <member name="M:NGit.Revwalk.Depthwalk.ObjectWalk.#ctor(NGit.Repository,System.Int32)">
            <param name="repo">Repository to walk</param>
            <param name="depth">Maximum depth to return</param>
        </member>
        <member name="M:NGit.Revwalk.Depthwalk.ObjectWalk.#ctor(NGit.ObjectReader,System.Int32)">
            <param name="or">Object Reader</param>
            <param name="depth">Maximum depth to return</param>
        </member>
        <member name="M:NGit.Revwalk.Depthwalk.ObjectWalk.MarkRoot(NGit.Revwalk.RevObject)">
            <summary>Mark a root commit (i.e., one whose depth should be considered 0.)</summary>
            <param name="o">Commit to mark</param>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
            <exception cref="T:NGit.Errors.IncorrectObjectTypeException">NGit.Errors.IncorrectObjectTypeException
            	</exception>
            <exception cref="T:NGit.Errors.MissingObjectException">NGit.Errors.MissingObjectException
            	</exception>
        </member>
        <member name="M:NGit.Revwalk.Depthwalk.ObjectWalk.MarkUnshallow(NGit.Revwalk.RevObject)">
            <summary>
            Mark an element which used to be shallow in the client, but which
            should now be considered a full commit.
            </summary>
            <remarks>
            Mark an element which used to be shallow in the client, but which
            should now be considered a full commit. Any ancestors of this commit
            should be included in the walk, even if they are the ancestor of an
            uninteresting commit.
            </remarks>
            <param name="c">Commit to mark</param>
            <exception cref="T:NGit.Errors.MissingObjectException">NGit.Errors.MissingObjectException
            	</exception>
            <exception cref="T:NGit.Errors.IncorrectObjectTypeException">NGit.Errors.IncorrectObjectTypeException
            	</exception>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Api.TransportConfigCallback" -->
        <member name="M:NGit.Api.TransportConfigCallback.Configure(NGit.Transport.Transport)">
            <summary>Add any additional transport-specific configuration required.</summary>
            <remarks>Add any additional transport-specific configuration required.</remarks>
            <param name="transport"></param>
        </member>
        <member name="T:NGit.Util.RelativeDateFormatter">
            <summary>
            Formatter to format timestamps relative to the current time using time units
            in the format defined by
            <code>git log --relative-date</code>
            .
            </summary>
        </member>
        <member name="M:NGit.Util.RelativeDateFormatter.Format(System.DateTime)">
            <param name="when">
            <see cref="T:System.DateTime">System.DateTime</see>
            to format
            </param>
            <returns>
            age of given
            <see cref="T:System.DateTime">System.DateTime</see>
            compared to now formatted in the same
            relative format as returned by
            <code>git log --relative-date</code>
            </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Api.RebaseCommand" -->
        <member name="F:NGit.Api.RebaseCommand.REBASE_MERGE">
            <summary>The name of the "rebase-merge" folder</summary>
        </member>
        <member name="F:NGit.Api.RebaseCommand.STOPPED_SHA">
            <summary>The name of the "stopped-sha" file</summary>
        </member>
        <member name="M:NGit.Api.RebaseCommand.#ctor(NGit.Repository)">
            <param name="repo"></param>
        </member>
        <member name="M:NGit.Api.RebaseCommand.Call">
            <summary>
            Executes the
            <code>Rebase</code>
            command with all the options and parameters
            collected by the setter methods of this class. Each instance of this
            class should only be used for one invocation of the command. Don't call
            this method twice on an instance.
            </summary>
            <returns>an object describing the result of this command</returns>
            <exception cref="T:NGit.Api.Errors.GitAPIException">NGit.Api.Errors.GitAPIException
            	</exception>
            <exception cref="T:NGit.Api.Errors.WrongRepositoryStateException">NGit.Api.Errors.WrongRepositoryStateException
            	</exception>
            <exception cref="T:NGit.Api.Errors.NoHeadException">NGit.Api.Errors.NoHeadException
            	</exception>
            <exception cref="T:NGit.Api.Errors.RefNotFoundException">NGit.Api.Errors.RefNotFoundException
            	</exception>
        </member>
        <member name="M:NGit.Api.RebaseCommand.UpdateHead(System.String,NGit.Revwalk.RevCommit)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Api.RebaseCommand.CheckoutCurrentHead">
            <exception cref="T:System.IO.IOException"></exception>
            <exception cref="T:NGit.Api.Errors.NoHeadException"></exception>
        </member>
        <member name="M:NGit.Api.RebaseCommand.ContinueRebase">
            <returns>the commit if we had to do a commit, otherwise null</returns>
            <exception cref="T:NGit.Api.Errors.GitAPIException">NGit.Api.Errors.GitAPIException
            	</exception>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:NGit.Api.RebaseCommand.ParseAuthor">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Api.RebaseCommand.Stop(NGit.Revwalk.RevCommit)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Api.RebaseCommand.PopSteps(System.Int32)">
            <summary>
            Removes the number of lines given in the parameter from the
            <code>git-rebase-todo</code> file but preserves comments and other lines
            that can not be parsed as steps
            </summary>
            <param name="numSteps"></param>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:NGit.Api.RebaseCommand.InitFilesAndRewind">
            <exception cref="T:System.IO.IOException"></exception>
            <exception cref="T:NGit.Api.Errors.GitAPIException"></exception>
        </member>
        <member name="M:NGit.Api.RebaseCommand.TryFastForward(NGit.Revwalk.RevCommit)">
            <summary>checks if we can fast-forward and returns the new head if it is possible
            	</summary>
            <param name="newCommit"></param>
            <returns>the new head, or null</returns>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
            <exception cref="T:NGit.Api.Errors.GitAPIException">NGit.Api.Errors.GitAPIException
            	</exception>
        </member>
        <member name="M:NGit.Api.RebaseCommand.TryFastForward(System.String,NGit.Revwalk.RevCommit,NGit.Revwalk.RevCommit)">
            <exception cref="T:System.IO.IOException"></exception>
            <exception cref="T:NGit.Api.Errors.GitAPIException"></exception>
        </member>
        <member name="M:NGit.Api.RebaseCommand.CheckParameters">
            <exception cref="T:NGit.Api.Errors.WrongRepositoryStateException"></exception>
        </member>
        <member name="M:NGit.Api.RebaseCommand.CreateFile(Sharpen.FilePath,System.String,System.String)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Api.RebaseCommand.Abort(NGit.Api.RebaseResult)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Api.RebaseCommand.ReadFile(Sharpen.FilePath,System.String)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Api.RebaseCommand.CheckoutCommit(NGit.Revwalk.RevCommit)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Api.RebaseCommand.LoadSteps">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Api.RebaseCommand.SetUpstream(NGit.Revwalk.RevCommit)">
            <param name="upstream">the upstream commit</param>
            <returns>
            
            <code>this</code>
            </returns>
        </member>
        <member name="M:NGit.Api.RebaseCommand.SetUpstream(NGit.AnyObjectId)">
            <param name="upstream">id of the upstream commit</param>
            <returns>
            
            <code>this</code>
            </returns>
        </member>
        <member name="M:NGit.Api.RebaseCommand.SetUpstream(System.String)">
            <param name="upstream">the upstream branch</param>
            <returns>
            
            <code>this</code>
            </returns>
            <exception cref="T:NGit.Api.Errors.RefNotFoundException">NGit.Api.Errors.RefNotFoundException
            	</exception>
        </member>
        <member name="M:NGit.Api.RebaseCommand.SetOperation(NGit.Api.RebaseCommand.Operation)">
            <param name="operation">the operation to perform</param>
            <returns>
            
            <code>this</code>
            </returns>
        </member>
        <member name="M:NGit.Api.RebaseCommand.SetProgressMonitor(NGit.ProgressMonitor)">
            <param name="monitor">a progress monitor</param>
            <returns>this instance</returns>
        </member>
        <member name="T:NGit.Api.RebaseCommand.Operation">
            <summary>The available operations</summary>
        </member>
        <member name="T:NGit.Notes.NonNoteEntry">
            <summary>A tree entry found in a note branch that isn't a valid note.</summary>
            <remarks>A tree entry found in a note branch that isn't a valid note.</remarks>
        </member>
        <member name="F:NGit.Notes.NonNoteEntry.name">
            <summary>Name of the entry in the tree, in raw format.</summary>
            <remarks>Name of the entry in the tree, in raw format.</remarks>
        </member>
        <member name="F:NGit.Notes.NonNoteEntry.mode">
            <summary>Mode of the entry as parsed from the tree.</summary>
            <remarks>Mode of the entry as parsed from the tree.</remarks>
        </member>
        <member name="F:NGit.Notes.NonNoteEntry.next">
            <summary>The next non-note entry in the same tree, as defined by tree order.</summary>
            <remarks>The next non-note entry in the same tree, as defined by tree order.</remarks>
        </member>
        <member name="T:NGit.TreeFormatter">
            <summary>Mutable formatter to construct a single tree object.</summary>
            <remarks>
            Mutable formatter to construct a single tree object.
            This formatter does not process subtrees. Callers must handle creating each
            subtree on their own.
            To maintain good performance for bulk operations, this formatter does not
            validate its input. Callers are responsible for ensuring the resulting tree
            object is correctly well formed by writing entries in the correct order.
            </remarks>
        </member>
        <member name="M:NGit.TreeFormatter.EntrySize(NGit.FileMode,System.Int32)">
            <summary>Compute the size of a tree entry record.</summary>
            <remarks>
            Compute the size of a tree entry record.
            This method can be used to estimate the correct size of a tree prior to
            allocating a formatter. Getting the size correct at allocation time
            ensures the internal buffer is sized correctly, reducing copying.
            </remarks>
            <param name="mode">the mode the entry will have.</param>
            <param name="nameLen">the length of the name, in bytes.</param>
            <returns>the length of the record.</returns>
        </member>
        <member name="M:NGit.TreeFormatter.#ctor">
            <summary>Create an empty formatter with a default buffer size.</summary>
            <remarks>Create an empty formatter with a default buffer size.</remarks>
        </member>
        <member name="M:NGit.TreeFormatter.#ctor(System.Int32)">
            <summary>Create an empty formatter with the specified buffer size.</summary>
            <remarks>Create an empty formatter with the specified buffer size.</remarks>
            <param name="size">
            estimated size of the tree, in bytes. Callers can use
            <see cref="M:NGit.TreeFormatter.EntrySize(NGit.FileMode,System.Int32)">EntrySize(FileMode, int)</see>
            to estimate the size of each
            entry in advance of allocating the formatter.
            </param>
        </member>
        <member name="M:NGit.TreeFormatter.Append(System.String,NGit.Revwalk.RevCommit)">
            <summary>
            Add a link to a submodule commit, mode is
            <see cref="F:NGit.FileMode.GITLINK">FileMode.GITLINK</see>
            .
            </summary>
            <param name="name">name of the entry.</param>
            <param name="commit">the ObjectId to store in this entry.</param>
        </member>
        <member name="M:NGit.TreeFormatter.Append(System.String,NGit.Revwalk.RevTree)">
            <summary>
            Add a subtree, mode is
            <see cref="F:NGit.FileMode.TREE">FileMode.TREE</see>
            .
            </summary>
            <param name="name">name of the entry.</param>
            <param name="tree">the ObjectId to store in this entry.</param>
        </member>
        <member name="M:NGit.TreeFormatter.Append(System.String,NGit.Revwalk.RevBlob)">
            <summary>
            Add a regular file, mode is
            <see cref="F:NGit.FileMode.REGULAR_FILE">FileMode.REGULAR_FILE</see>
            .
            </summary>
            <param name="name">name of the entry.</param>
            <param name="blob">the ObjectId to store in this entry.</param>
        </member>
        <member name="M:NGit.TreeFormatter.Append(System.String,NGit.FileMode,NGit.AnyObjectId)">
            <summary>Append any entry to the tree.</summary>
            <remarks>Append any entry to the tree.</remarks>
            <param name="name">name of the entry.</param>
            <param name="mode">
            mode describing the treatment of
            <code>id</code>
            .
            </param>
            <param name="id">the ObjectId to store in this entry.</param>
        </member>
        <member name="M:NGit.TreeFormatter.Append(System.Byte[],NGit.FileMode,NGit.AnyObjectId)">
            <summary>Append any entry to the tree.</summary>
            <remarks>Append any entry to the tree.</remarks>
            <param name="name">
            name of the entry. The name should be UTF-8 encoded, but file
            name encoding is not a well defined concept in Git.
            </param>
            <param name="mode">
            mode describing the treatment of
            <code>id</code>
            .
            </param>
            <param name="id">the ObjectId to store in this entry.</param>
        </member>
        <member name="M:NGit.TreeFormatter.Append(System.Byte[],System.Int32,System.Int32,NGit.FileMode,NGit.AnyObjectId)">
            <summary>Append any entry to the tree.</summary>
            <remarks>Append any entry to the tree.</remarks>
            <param name="nameBuf">
            buffer holding the name of the entry. The name should be UTF-8
            encoded, but file name encoding is not a well defined concept
            in Git.
            </param>
            <param name="namePos">
            first position within
            <code>nameBuf</code>
            of the name data.
            </param>
            <param name="nameLen">
            number of bytes from
            <code>nameBuf</code>
            to use as the name.
            </param>
            <param name="mode">
            mode describing the treatment of
            <code>id</code>
            .
            </param>
            <param name="id">the ObjectId to store in this entry.</param>
        </member>
        <member name="M:NGit.TreeFormatter.Append(System.Byte[],System.Int32,System.Int32,NGit.FileMode,System.Byte[],System.Int32)">
            <summary>Append any entry to the tree.</summary>
            <remarks>Append any entry to the tree.</remarks>
            <param name="nameBuf">
            buffer holding the name of the entry. The name should be UTF-8
            encoded, but file name encoding is not a well defined concept
            in Git.
            </param>
            <param name="namePos">
            first position within
            <code>nameBuf</code>
            of the name data.
            </param>
            <param name="nameLen">
            number of bytes from
            <code>nameBuf</code>
            to use as the name.
            </param>
            <param name="mode">
            mode describing the treatment of
            <code>id</code>
            .
            </param>
            <param name="idBuf">buffer holding the raw ObjectId of the entry.</param>
            <param name="idPos">
            first position within
            <code>idBuf</code>
            to copy the id from.
            </param>
        </member>
        <member name="M:NGit.TreeFormatter.FmtOverflowBuffer(System.Byte[],System.Int32,System.Int32,NGit.FileMode)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.TreeFormatter.InsertTo(NGit.ObjectInserter)">
            <summary>Insert this tree and obtain its ObjectId.</summary>
            <remarks>Insert this tree and obtain its ObjectId.</remarks>
            <param name="ins">the inserter to store the tree.</param>
            <returns>computed ObjectId of the tree</returns>
            <exception cref="T:System.IO.IOException">the tree could not be stored.</exception>
        </member>
        <member name="M:NGit.TreeFormatter.ComputeId(NGit.ObjectInserter)">
            <summary>Compute the ObjectId for this tree</summary>
            <param name="ins"></param>
            <returns>ObjectId for this tree</returns>
        </member>
        <member name="M:NGit.TreeFormatter.ToByteArray">
            <summary>Copy this formatter's buffer into a byte array.</summary>
            <remarks>
            Copy this formatter's buffer into a byte array.
            This method is not efficient, as it needs to create a copy of the
            internal buffer in order to supply an array of the correct size to the
            caller. If the buffer is just to pass to an ObjectInserter, consider
            using
            <see cref="M:NGit.ObjectInserter.Insert(NGit.TreeFormatter)">ObjectInserter.Insert(TreeFormatter)
            	</see>
            instead.
            </remarks>
            <returns>a copy of this formatter's buffer.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Api.DeleteBranchCommand" -->
        <member name="M:NGit.Api.DeleteBranchCommand.#ctor(NGit.Repository)">
            <param name="repo"></param>
        </member>
        <member name="M:NGit.Api.DeleteBranchCommand.Call">
            <exception cref="T:NGit.Api.Errors.NotMergedException">
            when trying to delete a branch which has not been merged into
            the currently checked out branch without force
            </exception>
            <exception cref="T:NGit.Api.Errors.CannotDeleteCurrentBranchException">NGit.Api.Errors.CannotDeleteCurrentBranchException
            	</exception>
            <returns>the list with the (full) names of the deleted branches</returns>
            <exception cref="T:NGit.Api.Errors.GitAPIException"></exception>
        </member>
        <member name="M:NGit.Api.DeleteBranchCommand.SetBranchNames(System.String[])">
            <param name="branchnames">
            the names of the branches to delete; if not set, this will do
            nothing; invalid branch names will simply be ignored
            </param>
            <returns>this instance</returns>
        </member>
        <member name="M:NGit.Api.DeleteBranchCommand.SetForce(System.Boolean)">
            <param name="force">
            <code>true</code> corresponds to the -D option,
            <code>false</code> to the -d option (default) <br />
            if <code>false</code> a check will be performed whether the
            branch to be deleted is already merged into the current branch
            and deletion will be refused in this case
            </param>
            <returns>this instance</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Transport.TransportHttp" -->
        <member name="M:NGit.Transport.TransportHttp.#ctor(NGit.Repository,NGit.Transport.URIish)">
            <exception cref="T:System.NotSupportedException"></exception>
        </member>
        <member name="M:NGit.Transport.TransportHttp.#ctor(NGit.Transport.URIish)">
            <summary>Create a minimal HTTP transport with default configuration values.</summary>
            <remarks>Create a minimal HTTP transport with default configuration values.</remarks>
            <param name="uri"></param>
            <exception cref="T:System.NotSupportedException">System.NotSupportedException</exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Transport.TransportHttp.SetUseSmartHttp(System.Boolean)" -->
        <member name="M:NGit.Transport.TransportHttp.OpenFetch">
            <exception cref="T:NGit.Errors.TransportException"></exception>
            <exception cref="T:System.NotSupportedException"></exception>
        </member>
        <member name="M:NGit.Transport.TransportHttp.NewDumbConnection(Sharpen.InputStream)">
            <exception cref="T:System.IO.IOException"></exception>
            <exception cref="T:NGit.Errors.PackProtocolException"></exception>
        </member>
        <member name="M:NGit.Transport.TransportHttp.OpenPush">
            <exception cref="T:System.NotSupportedException"></exception>
            <exception cref="T:NGit.Errors.TransportException"></exception>
        </member>
        <member name="M:NGit.Transport.TransportHttp.Connect(System.String)">
            <exception cref="T:NGit.Errors.TransportException"></exception>
            <exception cref="T:System.NotSupportedException"></exception>
        </member>
        <member name="M:NGit.Transport.TransportHttp.HttpOpen(System.Uri)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Transport.TransportHttp.HttpOpen(System.String,System.Uri)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Transport.TransportHttp.DisableSslVerify(Sharpen.URLConnection)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Transport.TransportHttp.OpenInputStream(Sharpen.HttpURLConnection)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Transport.TransportHttp.ReadSmartHeaders(Sharpen.InputStream,System.String)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Transport.TransportHttp._TransportProtocol_137.Open(NGit.Transport.URIish,NGit.Repository,System.String)">
            <exception cref="T:System.NotSupportedException"></exception>
        </member>
        <member name="M:NGit.Transport.TransportHttp._TransportProtocol_137.Open(NGit.Transport.URIish)">
            <exception cref="T:System.NotSupportedException"></exception>
        </member>
        <member name="M:NGit.Transport.TransportHttp._TransportProtocol_176.Open(NGit.Transport.URIish,NGit.Repository,System.String)">
            <exception cref="T:System.NotSupportedException"></exception>
        </member>
        <member name="M:NGit.Transport.TransportHttp.HttpObjectDB.GetAlternates">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Transport.TransportHttp.HttpObjectDB.OpenAlternate(System.String)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Transport.TransportHttp.HttpObjectDB.GetPackNames">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Transport.TransportHttp.HttpObjectDB.Open(System.String)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Transport.TransportHttp.HttpObjectDB.ReadAdvertisedImpl(Sharpen.BufferedReader)">
            <exception cref="T:System.IO.IOException"></exception>
            <exception cref="T:NGit.Errors.PackProtocolException"></exception>
        </member>
        <member name="M:NGit.Transport.TransportHttp.SmartHttpFetchConnection.#ctor(NGit.Transport.TransportHttp,Sharpen.InputStream)">
            <exception cref="T:NGit.Errors.TransportException"></exception>
        </member>
        <member name="M:NGit.Transport.TransportHttp.SmartHttpFetchConnection.DoFetch(NGit.ProgressMonitor,System.Collections.Generic.ICollection{NGit.Ref},System.Collections.Generic.ICollection{NGit.ObjectId})">
            <exception cref="T:NGit.Errors.TransportException"></exception>
        </member>
        <member name="M:NGit.Transport.TransportHttp.SmartHttpPushConnection.#ctor(NGit.Transport.TransportHttp,Sharpen.InputStream)">
            <exception cref="T:NGit.Errors.TransportException"></exception>
        </member>
        <member name="M:NGit.Transport.TransportHttp.SmartHttpPushConnection.DoPush(NGit.ProgressMonitor,System.Collections.Generic.IDictionary{System.String,NGit.Transport.RemoteRefUpdate})">
            <exception cref="T:NGit.Errors.TransportException"></exception>
        </member>
        <member name="T:NGit.Transport.TransportHttp.Service">
            <summary>Basic service for sending and receiving HTTP requests.</summary>
            <remarks>Basic service for sending and receiving HTTP requests.</remarks>
        </member>
        <member name="M:NGit.Transport.TransportHttp.Service.OpenStream">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Transport.TransportHttp.Service.SendRequest">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Transport.TransportHttp.Service.OpenResponse">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Transport.TransportHttp.Service.Execute">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Transport.TransportHttp.Service.HttpExecuteStream.Read">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Transport.TransportHttp.Service.HttpExecuteStream.Read(System.Byte[],System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Transport.TransportHttp.Service.HttpExecuteStream.Skip(System.Int64)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Util.TemporaryBuffer" -->
        <member name="F:NGit.Util.TemporaryBuffer.DEFAULT_IN_CORE_LIMIT">
            <summary>Default limit for in-core storage.</summary>
            <remarks>Default limit for in-core storage.</remarks>
        </member>
        <member name="F:NGit.Util.TemporaryBuffer.blocks">
            <summary>Chain of data, if we are still completely in-core; otherwise null.</summary>
            <remarks>Chain of data, if we are still completely in-core; otherwise null.</remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "F:NGit.Util.TemporaryBuffer.inCoreLimit" -->
        <member name="F:NGit.Util.TemporaryBuffer.overflow">
            <summary>
            If
            <see cref="F:NGit.Util.TemporaryBuffer.inCoreLimit">inCoreLimit</see>
            has been reached, remainder goes here.
            </summary>
        </member>
        <member name="M:NGit.Util.TemporaryBuffer.#ctor(System.Int32)">
            <summary>Create a new empty temporary buffer.</summary>
            <remarks>Create a new empty temporary buffer.</remarks>
            <param name="limit">
            maximum number of bytes to store in memory before entering the
            overflow output path.
            </param>
        </member>
        <member name="M:NGit.Util.TemporaryBuffer.Write(System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Util.TemporaryBuffer.Write(System.Byte[],System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Util.TemporaryBuffer.DoFlush">
            <summary>Dumps the entire buffer into the overflow stream, and flushes it.</summary>
            <remarks>Dumps the entire buffer into the overflow stream, and flushes it.</remarks>
            <exception cref="T:System.IO.IOException">
            the overflow stream cannot be started, or the buffer contents
            cannot be written to it, or it failed to flush.
            </exception>
        </member>
        <member name="M:NGit.Util.TemporaryBuffer.Copy(Sharpen.InputStream)">
            <summary>Copy all bytes remaining on the input stream into this buffer.</summary>
            <remarks>Copy all bytes remaining on the input stream into this buffer.</remarks>
            <param name="in">the stream to read from, until EOF is reached.</param>
            <exception cref="T:System.IO.IOException">
            an error occurred reading from the input stream, or while
            writing to a local temporary file.
            </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Util.TemporaryBuffer.Length" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Util.TemporaryBuffer.ToByteArray" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Util.TemporaryBuffer.WriteTo(Sharpen.OutputStream,NGit.ProgressMonitor)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Util.TemporaryBuffer.OpenInputStream" -->
        <member name="M:NGit.Util.TemporaryBuffer.Reset">
            <summary>Reset this buffer for reuse, purging all buffered content.</summary>
            <remarks>Reset this buffer for reuse, purging all buffered content.</remarks>
        </member>
        <member name="M:NGit.Util.TemporaryBuffer.Overflow">
            <summary>Open the overflow output stream, so the remaining output can be stored.</summary>
            <remarks>Open the overflow output stream, so the remaining output can be stored.</remarks>
            <returns>
            the output stream to receive the buffered content, followed by
            the remaining output.
            </returns>
            <exception cref="T:System.IO.IOException">the buffer cannot create the overflow stream.
            	</exception>
        </member>
        <member name="M:NGit.Util.TemporaryBuffer.ReachedInCoreLimit">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Util.TemporaryBuffer.SwitchToOverflow">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Util.TemporaryBuffer.Close">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Util.TemporaryBuffer.Destroy">
            <summary>Clear this buffer so it has no data, and cannot be used again.</summary>
            <remarks>Clear this buffer so it has no data, and cannot be used again.</remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Util.TemporaryBuffer.LocalFile" -->
        <member name="F:NGit.Util.TemporaryBuffer.LocalFile.directory">
            <summary>Directory to store the temporary file under.</summary>
            <remarks>Directory to store the temporary file under.</remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "F:NGit.Util.TemporaryBuffer.LocalFile.onDiskFile" -->
        <member name="M:NGit.Util.TemporaryBuffer.LocalFile.#ctor">
            <summary>Create a new temporary buffer.</summary>
            <remarks>Create a new temporary buffer.</remarks>
        </member>
        <member name="M:NGit.Util.TemporaryBuffer.LocalFile.#ctor(System.Int32)">
            <summary>Create a new temporary buffer, limiting memory usage.</summary>
            <remarks>Create a new temporary buffer, limiting memory usage.</remarks>
            <param name="inCoreLimit">
            maximum number of bytes to store in memory. Storage beyond
            this limit will use the local file.
            </param>
        </member>
        <member name="M:NGit.Util.TemporaryBuffer.LocalFile.#ctor(Sharpen.FilePath)">
            <summary>Create a new temporary buffer, limiting memory usage.</summary>
            <remarks>Create a new temporary buffer, limiting memory usage.</remarks>
            <param name="directory">
            if the buffer has to spill over into a temporary file, the
            directory where the file should be saved. If null the
            system default temporary directory (for example /tmp) will
            be used instead.
            </param>
        </member>
        <member name="M:NGit.Util.TemporaryBuffer.LocalFile.#ctor(Sharpen.FilePath,System.Int32)">
            <summary>Create a new temporary buffer, limiting memory usage.</summary>
            <remarks>Create a new temporary buffer, limiting memory usage.</remarks>
            <param name="directory">
            if the buffer has to spill over into a temporary file, the
            directory where the file should be saved. If null the
            system default temporary directory (for example /tmp) will
            be used instead.
            </param>
            <param name="inCoreLimit">
            maximum number of bytes to store in memory. Storage beyond
            this limit will use the local file.
            </param>
        </member>
        <member name="M:NGit.Util.TemporaryBuffer.LocalFile.Overflow">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Util.TemporaryBuffer.LocalFile.ToByteArray">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Util.TemporaryBuffer.LocalFile.WriteTo(Sharpen.OutputStream,NGit.ProgressMonitor)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Util.TemporaryBuffer.LocalFile.OpenInputStream">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Util.TemporaryBuffer.Heap" -->
        <member name="M:NGit.Util.TemporaryBuffer.Heap.#ctor(System.Int32)">
            <summary>Create a new heap buffer with a maximum storage limit.</summary>
            <remarks>Create a new heap buffer with a maximum storage limit.</remarks>
            <param name="limit">
            maximum number of bytes that can be stored in this buffer.
            Storing beyond this many will cause an IOException to be
            thrown during write.
            </param>
        </member>
        <member name="M:NGit.Util.TemporaryBuffer.Heap.Overflow">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Util.TemporaryBuffer.BlockInputStream.Read">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Util.TemporaryBuffer.BlockInputStream.Skip(System.Int64)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Util.TemporaryBuffer.BlockInputStream.Read(System.Byte[],System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Transport.TransportHttp.Service.HttpOutputStream.Overflow">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Transport.TransportHttp.MultiRequestService" -->
        <member name="M:NGit.Transport.TransportHttp.MultiRequestService.Execute">
            <summary>Keep opening send-receive pairs to the given URI.</summary>
            <remarks>Keep opening send-receive pairs to the given URI.</remarks>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="T:NGit.Transport.TransportHttp.LongPollService">
            <summary>Service for maintaining a single long-poll connection.</summary>
            <remarks>Service for maintaining a single long-poll connection.</remarks>
        </member>
        <member name="M:NGit.Transport.TransportHttp.LongPollService.#ctor(NGit.Transport.TransportHttp,System.String)">
            <param name="serviceName"></param>
        </member>
        <member name="M:NGit.Transport.TransportHttp.LongPollService.Execute">
            <summary>Only open one send-receive request.</summary>
            <remarks>Only open one send-receive request.</remarks>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="T:NGit.Transport.RefAdvertiser">
            <summary>
            Support for the start of
            <see cref="T:NGit.Transport.UploadPack">UploadPack</see>
            and
            <see cref="T:NGit.Transport.ReceivePack">ReceivePack</see>
            .
            </summary>
        </member>
        <member name="M:NGit.Transport.RefAdvertiser.Init(NGit.Repository)">
            <summary>Initialize this advertiser with a repository for peeling tags.</summary>
            <remarks>Initialize this advertiser with a repository for peeling tags.</remarks>
            <param name="src">the repository to read from.</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Transport.RefAdvertiser.SetDerefTags(System.Boolean)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Transport.RefAdvertiser.AdvertiseCapability(System.String)" -->
        <member name="M:NGit.Transport.RefAdvertiser.Send(System.Collections.Generic.IDictionary{System.String,NGit.Ref})">
            <summary>Format an advertisement for the supplied refs.</summary>
            <remarks>Format an advertisement for the supplied refs.</remarks>
            <param name="refs">
            zero or more refs to format for the client. The collection is
            sorted before display if necessary, and therefore may appear
            in any order.
            </param>
            <returns>set of ObjectIds that were advertised to the client.</returns>
            <exception cref="T:System.IO.IOException">
            the underlying output stream failed to write out an
            advertisement record.
            </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Transport.RefAdvertiser.AdvertiseHave(NGit.AnyObjectId)" -->
        <member name="M:NGit.Transport.RefAdvertiser.IsEmpty">
            <returns>true if no advertisements have been sent yet.</returns>
        </member>
        <member name="M:NGit.Transport.RefAdvertiser.AdvertiseAnyOnce(NGit.AnyObjectId,System.String)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Transport.RefAdvertiser.AdvertiseAny(NGit.AnyObjectId,System.String)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Transport.RefAdvertiser.AdvertiseId(NGit.AnyObjectId,System.String)" -->
        <member name="M:NGit.Transport.RefAdvertiser.WriteOne(Sharpen.CharSequence)">
            <summary>Write a single advertisement line.</summary>
            <remarks>Write a single advertisement line.</remarks>
            <param name="line">
            the advertisement line to be written. The line always ends
            with LF. Never null or the empty string.
            </param>
            <exception cref="T:System.IO.IOException">
            the underlying output stream failed to write out an
            advertisement record.
            </exception>
        </member>
        <member name="M:NGit.Transport.RefAdvertiser.End">
            <summary>Mark the end of the advertisements.</summary>
            <remarks>Mark the end of the advertisements.</remarks>
            <exception cref="T:System.IO.IOException">
            the underlying output stream failed to write out an
            advertisement record.
            </exception>
        </member>
        <member name="T:NGit.Transport.RefAdvertiser.PacketLineOutRefAdvertiser">
            <summary>
            Advertiser which frames lines in a
            <see cref="T:NGit.Transport.PacketLineOut">PacketLineOut</see>
            format.
            </summary>
        </member>
        <member name="M:NGit.Transport.RefAdvertiser.PacketLineOutRefAdvertiser.#ctor(NGit.Transport.PacketLineOut)">
            <summary>Create a new advertiser for the supplied stream.</summary>
            <remarks>Create a new advertiser for the supplied stream.</remarks>
            <param name="out">the output stream.</param>
        </member>
        <member name="M:NGit.Transport.RefAdvertiser.PacketLineOutRefAdvertiser.WriteOne(Sharpen.CharSequence)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Transport.RefAdvertiser.PacketLineOutRefAdvertiser.End">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="T:NGit.Transport.BundleFetchConnection">
            <summary>Fetch connection for bundle based classes.</summary>
            <remarks>
            Fetch connection for bundle based classes. It used by
            instances of
            <see cref="T:NGit.Transport.TransportBundle">TransportBundle</see>
            </remarks>
        </member>
        <member name="M:NGit.Transport.BundleFetchConnection.#ctor(NGit.Transport.Transport,Sharpen.InputStream)">
            <exception cref="T:NGit.Errors.TransportException"></exception>
        </member>
        <member name="M:NGit.Transport.BundleFetchConnection.ReadSignature">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Transport.BundleFetchConnection.ReadBundleV2">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Transport.BundleFetchConnection.ReadLine(System.Byte[])">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Transport.BundleFetchConnection.DoFetch(NGit.ProgressMonitor,System.Collections.Generic.ICollection{NGit.Ref},System.Collections.Generic.ICollection{NGit.ObjectId})">
            <exception cref="T:NGit.Errors.TransportException"></exception>
        </member>
        <member name="M:NGit.Transport.BundleFetchConnection.VerifyPrerequisites">
            <exception cref="T:NGit.Errors.TransportException"></exception>
        </member>
        <member name="T:NGit.Transport.RemoteRefUpdate">
            <summary>Represent request and status of a remote ref update.</summary>
            <remarks>
            Represent request and status of a remote ref update. Specification is
            provided by client, while status is handled by
            <see cref="T:NGit.Transport.PushProcess">PushProcess</see>
            class,
            being read-only for client.
            <p>
            Client can create instances of this class directly, basing on user
            specification and advertised refs (
            <see cref="T:NGit.Transport.Connection">Connection</see>
            or through
            <see cref="T:NGit.Transport.Transport">Transport</see>
            helper methods. Apply this specification on remote
            repository using
            <see cref="!:Transport.Push(NGit.ProgressMonitor, System.Collections.Generic.ICollection&lt;E&gt;)&#xA;            	">Transport.Push(NGit.ProgressMonitor, System.Collections.Generic.ICollection&lt;E&gt;)
            	</see>
            method.
            </p>
            </remarks>
        </member>
        <member name="M:NGit.Transport.RemoteRefUpdate.#ctor(NGit.Repository,System.String,System.String,System.Boolean,System.String,NGit.ObjectId)">
            <summary>Construct remote ref update request by providing an update specification.
            	</summary>
            <remarks>
            Construct remote ref update request by providing an update specification.
            Object is created with default
            <see cref="F:NGit.Transport.RemoteRefUpdate.Status.NOT_ATTEMPTED">Status.NOT_ATTEMPTED</see>
            status and no
            message.
            </remarks>
            <param name="localDb">local repository to push from.</param>
            <param name="srcRef">
            source revision - any string resolvable by
            <see cref="M:NGit.Repository.Resolve(System.String)">NGit.Repository.Resolve(string)</see>
            . This resolves to the new
            object that the caller want remote ref to be after update. Use
            null or
            <see cref="P:NGit.ObjectId.ZeroId">NGit.ObjectId.ZeroId()</see>
            string for delete request.
            </param>
            <param name="remoteName">
            full name of a remote ref to update, e.g. "refs/heads/master"
            (no wildcard, no short name).
            </param>
            <param name="forceUpdate">
            true when caller want remote ref to be updated regardless
            whether it is fast-forward update (old object is ancestor of
            new object).
            </param>
            <param name="localName">
            optional full name of a local stored tracking branch, to
            update after push, e.g. "refs/remotes/zawir/dirty" (no
            wildcard, no short name); null if no local tracking branch
            should be updated.
            </param>
            <param name="expectedOldObjectId">
            optional object id that caller is expecting, requiring to be
            advertised by remote side before update; update will take
            place ONLY if remote side advertise exactly this expected id;
            null if caller doesn't care what object id remote side
            advertise. Use
            <see cref="P:NGit.ObjectId.ZeroId">NGit.ObjectId.ZeroId()</see>
            when expecting no
            remote ref with this name.
            </param>
            <exception cref="T:System.IO.IOException">
            when I/O error occurred during creating
            <see cref="T:NGit.Transport.TrackingRefUpdate">TrackingRefUpdate</see>
            for local tracking branch or srcRef
            can't be resolved to any object.
            </exception>
            <exception cref="T:System.ArgumentException">if some required parameter was null</exception>
        </member>
        <member name="M:NGit.Transport.RemoteRefUpdate.#ctor(NGit.Repository,NGit.Ref,System.String,System.Boolean,System.String,NGit.ObjectId)">
            <summary>Construct remote ref update request by providing an update specification.
            	</summary>
            <remarks>
            Construct remote ref update request by providing an update specification.
            Object is created with default
            <see cref="F:NGit.Transport.RemoteRefUpdate.Status.NOT_ATTEMPTED">Status.NOT_ATTEMPTED</see>
            status and no
            message.
            </remarks>
            <param name="localDb">local repository to push from.</param>
            <param name="srcRef">source revision. Use null to delete.</param>
            <param name="remoteName">
            full name of a remote ref to update, e.g. "refs/heads/master"
            (no wildcard, no short name).
            </param>
            <param name="forceUpdate">
            true when caller want remote ref to be updated regardless
            whether it is fast-forward update (old object is ancestor of
            new object).
            </param>
            <param name="localName">
            optional full name of a local stored tracking branch, to
            update after push, e.g. "refs/remotes/zawir/dirty" (no
            wildcard, no short name); null if no local tracking branch
            should be updated.
            </param>
            <param name="expectedOldObjectId">
            optional object id that caller is expecting, requiring to be
            advertised by remote side before update; update will take
            place ONLY if remote side advertise exactly this expected id;
            null if caller doesn't care what object id remote side
            advertise. Use
            <see cref="P:NGit.ObjectId.ZeroId">NGit.ObjectId.ZeroId()</see>
            when expecting no
            remote ref with this name.
            </param>
            <exception cref="T:System.IO.IOException">
            when I/O error occurred during creating
            <see cref="T:NGit.Transport.TrackingRefUpdate">TrackingRefUpdate</see>
            for local tracking branch or srcRef
            can't be resolved to any object.
            </exception>
            <exception cref="T:System.ArgumentException">if some required parameter was null</exception>
        </member>
        <member name="M:NGit.Transport.RemoteRefUpdate.#ctor(NGit.Repository,System.String,NGit.ObjectId,System.String,System.Boolean,System.String,NGit.ObjectId)">
            <summary>Construct remote ref update request by providing an update specification.
            	</summary>
            <remarks>
            Construct remote ref update request by providing an update specification.
            Object is created with default
            <see cref="F:NGit.Transport.RemoteRefUpdate.Status.NOT_ATTEMPTED">Status.NOT_ATTEMPTED</see>
            status and no
            message.
            </remarks>
            <param name="localDb">local repository to push from.</param>
            <param name="srcRef">
            source revision to label srcId with. If null srcId.name() will
            be used instead.
            </param>
            <param name="srcId">
            The new object that the caller wants remote ref to be after
            update. Use null or
            <see cref="P:NGit.ObjectId.ZeroId">NGit.ObjectId.ZeroId()</see>
            for delete
            request.
            </param>
            <param name="remoteName">
            full name of a remote ref to update, e.g. "refs/heads/master"
            (no wildcard, no short name).
            </param>
            <param name="forceUpdate">
            true when caller want remote ref to be updated regardless
            whether it is fast-forward update (old object is ancestor of
            new object).
            </param>
            <param name="localName">
            optional full name of a local stored tracking branch, to
            update after push, e.g. "refs/remotes/zawir/dirty" (no
            wildcard, no short name); null if no local tracking branch
            should be updated.
            </param>
            <param name="expectedOldObjectId">
            optional object id that caller is expecting, requiring to be
            advertised by remote side before update; update will take
            place ONLY if remote side advertise exactly this expected id;
            null if caller doesn't care what object id remote side
            advertise. Use
            <see cref="P:NGit.ObjectId.ZeroId">NGit.ObjectId.ZeroId()</see>
            when expecting no
            remote ref with this name.
            </param>
            <exception cref="T:System.IO.IOException">
            when I/O error occurred during creating
            <see cref="T:NGit.Transport.TrackingRefUpdate">TrackingRefUpdate</see>
            for local tracking branch or srcRef
            can't be resolved to any object.
            </exception>
            <exception cref="T:System.ArgumentException">if some required parameter was null</exception>
        </member>
        <member name="M:NGit.Transport.RemoteRefUpdate.#ctor(NGit.Transport.RemoteRefUpdate,NGit.ObjectId)">
            <summary>
            Create a new instance of this object basing on existing instance for
            configuration.
            </summary>
            <remarks>
            Create a new instance of this object basing on existing instance for
            configuration. State (like
            <see cref="M:NGit.Transport.RemoteRefUpdate.GetMessage">GetMessage()</see>
            ,
            <see cref="M:NGit.Transport.RemoteRefUpdate.GetStatus">GetStatus()</see>
            )
            of base object is not shared. Expected old object id is set up from
            scratch, as this constructor may be used for 2-stage push: first one
            being dry run, second one being actual push.
            </remarks>
            <param name="base">configuration base.</param>
            <param name="newExpectedOldObjectId">new expected object id value.</param>
            <exception cref="T:System.IO.IOException">
            when I/O error occurred during creating
            <see cref="T:NGit.Transport.TrackingRefUpdate">TrackingRefUpdate</see>
            for local tracking branch or srcRef
            of base object no longer can be resolved to any object.
            </exception>
        </member>
        <member name="M:NGit.Transport.RemoteRefUpdate.GetExpectedOldObjectId">
            <returns>
            expectedOldObjectId required to be advertised by remote side, as
            set in constructor; may be null.
            </returns>
        </member>
        <member name="M:NGit.Transport.RemoteRefUpdate.IsExpectingOldObjectId">
            <returns>
            true if some object is required to be advertised by remote side,
            as set in constructor; false otherwise.
            </returns>
        </member>
        <member name="M:NGit.Transport.RemoteRefUpdate.GetNewObjectId">
            <returns>newObjectId for remote ref, as set in constructor.</returns>
        </member>
        <member name="M:NGit.Transport.RemoteRefUpdate.IsDelete">
            <returns>true if this update is deleting update; false otherwise.</returns>
        </member>
        <member name="M:NGit.Transport.RemoteRefUpdate.GetRemoteName">
            <returns>name of remote ref to update, as set in constructor.</returns>
        </member>
        <member name="M:NGit.Transport.RemoteRefUpdate.GetTrackingRefUpdate">
            <returns>local tracking branch update if localName was set in constructor.</returns>
        </member>
        <member name="M:NGit.Transport.RemoteRefUpdate.GetSrcRef">
            <returns>
            source revision as specified by user (in constructor), could be
            any string parseable by
            <see cref="M:NGit.Repository.Resolve(System.String)">NGit.Repository.Resolve(string)</see>
            ; can
            be null if specified that way in constructor - this stands for
            delete request.
            </returns>
        </member>
        <member name="M:NGit.Transport.RemoteRefUpdate.HasTrackingRefUpdate">
            <returns>
            true if user specified a local tracking branch for remote update;
            false otherwise.
            </returns>
        </member>
        <member name="M:NGit.Transport.RemoteRefUpdate.IsForceUpdate">
            <returns>
            true if this update is forced regardless of old remote ref
            object; false otherwise.
            </returns>
        </member>
        <member name="M:NGit.Transport.RemoteRefUpdate.GetStatus">
            <returns>status of remote ref update operation.</returns>
        </member>
        <member name="M:NGit.Transport.RemoteRefUpdate.IsFastForward">
            <summary>Check whether update was fast-forward.</summary>
            <remarks>
            Check whether update was fast-forward. Note that this result is
            meaningful only after successful update (when status is
            <see cref="F:NGit.Transport.RemoteRefUpdate.Status.OK">Status.OK</see>
            ).
            </remarks>
            <returns>true if update was fast-forward; false otherwise.</returns>
        </member>
        <member name="M:NGit.Transport.RemoteRefUpdate.GetMessage">
            <returns>
            message describing reasons of status when needed/possible; may be
            null.
            </returns>
        </member>
        <member name="M:NGit.Transport.RemoteRefUpdate.UpdateTrackingRef(NGit.Revwalk.RevWalk)">
            <summary>Update locally stored tracking branch with the new object.</summary>
            <remarks>Update locally stored tracking branch with the new object.</remarks>
            <param name="walk">walker used for checking update properties.</param>
            <exception cref="T:System.IO.IOException">when I/O error occurred during update</exception>
        </member>
        <member name="T:NGit.Transport.RemoteRefUpdate.Status">
            <summary>Represent current status of a remote ref update.</summary>
            <remarks>Represent current status of a remote ref update.</remarks>
        </member>
        <member name="T:NGit.Transport.TagOpt">
            <summary>Specification of annotated tag behavior during fetch.</summary>
            <remarks>Specification of annotated tag behavior during fetch.</remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "F:NGit.Transport.TagOpt.AUTO_FOLLOW" -->
        <!-- Badly formed XML comment ignored for member "F:NGit.Transport.TagOpt.NO_TAGS" -->
        <!-- Badly formed XML comment ignored for member "F:NGit.Transport.TagOpt.FETCH_TAGS" -->
        <member name="M:NGit.Transport.TagOpt.Option">
            <summary>Get the command line/configuration file text for this value.</summary>
            <remarks>Get the command line/configuration file text for this value.</remarks>
            <returns>text that appears in the configuration file to activate this.</returns>
        </member>
        <member name="M:NGit.Transport.TagOpt.FromOption(System.String)">
            <summary>Convert a command line/configuration file text into a value instance.</summary>
            <remarks>Convert a command line/configuration file text into a value instance.</remarks>
            <param name="o">the configuration file text value.</param>
            <returns>the option that matches the passed parameter.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Transport.RefSpec" -->
        <member name="F:NGit.Transport.RefSpec.WILDCARD_SUFFIX">
            <summary>
            Suffix for wildcard ref spec component, that indicate matching all refs
            with specified prefix.
            </summary>
            <remarks>
            Suffix for wildcard ref spec component, that indicate matching all refs
            with specified prefix.
            </remarks>
        </member>
        <member name="M:NGit.Transport.RefSpec.IsWildcard(System.String)">
            <summary>Check whether provided string is a wildcard ref spec component.</summary>
            <remarks>Check whether provided string is a wildcard ref spec component.</remarks>
            <param name="s">ref spec component - string to test. Can be null.</param>
            <returns>true if provided string is a wildcard ref spec component.</returns>
        </member>
        <member name="F:NGit.Transport.RefSpec.force">
            <summary>Does this specification ask for forced updated (rewind/reset)?</summary>
        </member>
        <member name="F:NGit.Transport.RefSpec.wildcard">
            <summary>Is this specification actually a wildcard match?</summary>
        </member>
        <member name="F:NGit.Transport.RefSpec.srcName">
            <summary>Name of the ref(s) we would copy from.</summary>
            <remarks>Name of the ref(s) we would copy from.</remarks>
        </member>
        <member name="F:NGit.Transport.RefSpec.dstName">
            <summary>Name of the ref(s) we would copy into.</summary>
            <remarks>Name of the ref(s) we would copy into.</remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Transport.RefSpec.#ctor" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Transport.RefSpec.#ctor(System.String)" -->
        <member name="M:NGit.Transport.RefSpec.IsForceUpdate">
            <summary>Check if this specification wants to forcefully update the destination.</summary>
            <remarks>Check if this specification wants to forcefully update the destination.</remarks>
            <returns>true if this specification asks for updates without merge tests.</returns>
        </member>
        <member name="M:NGit.Transport.RefSpec.SetForceUpdate(System.Boolean)">
            <summary>Create a new RefSpec with a different force update setting.</summary>
            <remarks>Create a new RefSpec with a different force update setting.</remarks>
            <param name="forceUpdate">new value for force update in the returned instance.</param>
            <returns>a new RefSpec with force update as specified.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Transport.RefSpec.IsWildcard" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Transport.RefSpec.GetSource" -->
        <member name="M:NGit.Transport.RefSpec.SetSource(System.String)">
            <summary>Create a new RefSpec with a different source name setting.</summary>
            <remarks>Create a new RefSpec with a different source name setting.</remarks>
            <param name="source">new value for source in the returned instance.</param>
            <returns>a new RefSpec with source as specified.</returns>
            <exception cref="T:System.InvalidOperationException">
            There is already a destination configured, and the wildcard
            status of the existing destination disagrees with the
            wildcard status of the new source.
            </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Transport.RefSpec.GetDestination" -->
        <member name="M:NGit.Transport.RefSpec.SetDestination(System.String)">
            <summary>Create a new RefSpec with a different destination name setting.</summary>
            <remarks>Create a new RefSpec with a different destination name setting.</remarks>
            <param name="destination">new value for destination in the returned instance.</param>
            <returns>a new RefSpec with destination as specified.</returns>
            <exception cref="T:System.InvalidOperationException">
            There is already a source configured, and the wildcard status
            of the existing source disagrees with the wildcard status of
            the new destination.
            </exception>
        </member>
        <member name="M:NGit.Transport.RefSpec.SetSourceDestination(System.String,System.String)">
            <summary>Create a new RefSpec with a different source/destination name setting.</summary>
            <remarks>Create a new RefSpec with a different source/destination name setting.</remarks>
            <param name="source">new value for source in the returned instance.</param>
            <param name="destination">new value for destination in the returned instance.</param>
            <returns>a new RefSpec with destination as specified.</returns>
            <exception cref="T:System.ArgumentException">
            The wildcard status of the new source disagrees with the
            wildcard status of the new destination.
            </exception>
        </member>
        <member name="M:NGit.Transport.RefSpec.MatchSource(System.String)">
            <summary>Does this specification's source description match the ref name?</summary>
            <param name="r">ref name that should be tested.</param>
            <returns>true if the names match; false otherwise.</returns>
        </member>
        <member name="M:NGit.Transport.RefSpec.MatchSource(NGit.Ref)">
            <summary>Does this specification's source description match the ref?</summary>
            <param name="r">ref whose name should be tested.</param>
            <returns>true if the names match; false otherwise.</returns>
        </member>
        <member name="M:NGit.Transport.RefSpec.MatchDestination(System.String)">
            <summary>Does this specification's destination description match the ref name?</summary>
            <param name="r">ref name that should be tested.</param>
            <returns>true if the names match; false otherwise.</returns>
        </member>
        <member name="M:NGit.Transport.RefSpec.MatchDestination(NGit.Ref)">
            <summary>Does this specification's destination description match the ref?</summary>
            <param name="r">ref whose name should be tested.</param>
            <returns>true if the names match; false otherwise.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Transport.RefSpec.ExpandFromSource(System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Transport.RefSpec.ExpandFromSource(NGit.Ref)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Transport.RefSpec.ExpandFromDestination(System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Transport.RefSpec.ExpandFromDestination(NGit.Ref)" -->
        <member name="T:NGit.Util.IOUtil">
            <summary>Input/Output utilities</summary>
        </member>
        <member name="M:NGit.Util.IOUtil.ReadFully(Sharpen.FilePath)">
            <summary>Read an entire local file into memory as a byte array.</summary>
            <remarks>Read an entire local file into memory as a byte array.</remarks>
            <param name="path">location of the file to read.</param>
            <returns>complete contents of the requested local file.</returns>
            <exception cref="T:System.IO.FileNotFoundException">the file does not exist.</exception>
            <exception cref="T:System.IO.IOException">the file exists, but its contents cannot be read.
            	</exception>
        </member>
        <member name="M:NGit.Util.IOUtil.ReadSome(Sharpen.FilePath,System.Int32)">
            <summary>Read at most limit bytes from the local file into memory as a byte array.
            	</summary>
            <remarks>Read at most limit bytes from the local file into memory as a byte array.
            	</remarks>
            <param name="path">location of the file to read.</param>
            <param name="limit">
            maximum number of bytes to read, if the file is larger than
            only the first limit number of bytes are returned
            </param>
            <returns>
            complete contents of the requested local file. If the contents
            exceeds the limit, then only the limit is returned.
            </returns>
            <exception cref="T:System.IO.FileNotFoundException">the file does not exist.</exception>
            <exception cref="T:System.IO.IOException">the file exists, but its contents cannot be read.
            	</exception>
        </member>
        <member name="M:NGit.Util.IOUtil.ReadFully(Sharpen.FilePath,System.Int32)">
            <summary>Read an entire local file into memory as a byte array.</summary>
            <remarks>Read an entire local file into memory as a byte array.</remarks>
            <param name="path">location of the file to read.</param>
            <param name="max">
            maximum number of bytes to read, if the file is larger than
            this limit an IOException is thrown.
            </param>
            <returns>complete contents of the requested local file.</returns>
            <exception cref="T:System.IO.FileNotFoundException">the file does not exist.</exception>
            <exception cref="T:System.IO.IOException">the file exists, but its contents cannot be read.
            	</exception>
        </member>
        <member name="M:NGit.Util.IOUtil.ReadWholeStream(Sharpen.InputStream,System.Int32)">
            <summary>Read an entire input stream into memory as a ByteBuffer.</summary>
            <remarks>
            Read an entire input stream into memory as a ByteBuffer.
            Note: The stream is read to its end and is not usable after calling this
            method. The caller is responsible for closing the stream.
            </remarks>
            <param name="in">input stream to be read.</param>
            <param name="sizeHint">
            a hint on the approximate number of bytes contained in the
            stream, used to allocate temporary buffers more efficiently
            </param>
            <returns>
            complete contents of the input stream. The ByteBuffer always has
            a writable backing array, with
            <code>position() == 0</code>
            and
            <code>limit()</code>
            equal to the actual length read. Callers may rely
            on obtaining the underlying array for efficient data access. If
            <code>sizeHint</code>
            was too large, the array may be over-allocated,
            resulting in
            <code>limit() &lt; array().length</code>
            .
            </returns>
            <exception cref="T:System.IO.IOException">there was an error reading from the stream.
            	</exception>
        </member>
        <member name="M:NGit.Util.IOUtil.ReadFully(Sharpen.InputStream,System.Byte[],System.Int32,System.Int32)">
            <summary>Read the entire byte array into memory, or throw an exception.</summary>
            <remarks>Read the entire byte array into memory, or throw an exception.</remarks>
            <param name="fd">input stream to read the data from.</param>
            <param name="dst">buffer that must be fully populated, [off, off+len).</param>
            <param name="off">position within the buffer to start writing to.</param>
            <param name="len">number of bytes that must be read.</param>
            <exception cref="T:Sharpen.EOFException">the stream ended before dst was fully populated.
            	</exception>
            <exception cref="T:System.IO.IOException">there was an error reading from the stream.
            	</exception>
        </member>
        <member name="M:NGit.Util.IOUtil.ReadFully(Sharpen.InputStream,System.Byte[],System.Int32)">
            <summary>Read the entire byte array into memory, unless input is shorter</summary>
            <param name="fd">input stream to read the data from.</param>
            <param name="dst">buffer that must be fully populated, [off, off+len).</param>
            <param name="off">position within the buffer to start writing to.</param>
            <returns>number of bytes in buffer or stream, whichever is shortest</returns>
            <exception cref="T:System.IO.IOException">there was an error reading from the stream.
            	</exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Util.IOUtil.SkipFully(Sharpen.InputStream,System.Int64)" -->
        <member name="M:NGit.Util.IOUtil.ReadLines(System.String)">
            <summary>Divides the given string into lines.</summary>
            <remarks>Divides the given string into lines.</remarks>
            <param name="s">the string to read</param>
            <returns>the string divided into lines</returns>
            <since>2.0</since>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Treewalk.Filter.AndTreeFilter" -->
        <member name="M:NGit.Treewalk.Filter.AndTreeFilter.Create(NGit.Treewalk.Filter.TreeFilter,NGit.Treewalk.Filter.TreeFilter)">
            <summary>Create a filter with two filters, both of which must match.</summary>
            <remarks>Create a filter with two filters, both of which must match.</remarks>
            <param name="a">first filter to test.</param>
            <param name="b">second filter to test.</param>
            <returns>a filter that must match both input filters.</returns>
        </member>
        <member name="M:NGit.Treewalk.Filter.AndTreeFilter.Create(NGit.Treewalk.Filter.TreeFilter[])">
            <summary>Create a filter around many filters, all of which must match.</summary>
            <remarks>Create a filter around many filters, all of which must match.</remarks>
            <param name="list">
            list of filters to match against. Must contain at least 2
            filters.
            </param>
            <returns>a filter that must match all input filters.</returns>
        </member>
        <member name="M:NGit.Treewalk.Filter.AndTreeFilter.Create(System.Collections.Generic.ICollection{NGit.Treewalk.Filter.TreeFilter})">
            <summary>Create a filter around many filters, all of which must match.</summary>
            <remarks>Create a filter around many filters, all of which must match.</remarks>
            <param name="list">
            list of filters to match against. Must contain at least 2
            filters.
            </param>
            <returns>a filter that must match all input filters.</returns>
        </member>
        <member name="M:NGit.Treewalk.Filter.AndTreeFilter.Binary.Include(NGit.Treewalk.TreeWalk)">
            <exception cref="T:NGit.Errors.MissingObjectException"></exception>
            <exception cref="T:NGit.Errors.IncorrectObjectTypeException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Treewalk.Filter.AndTreeFilter.List.Include(NGit.Treewalk.TreeWalk)">
            <exception cref="T:NGit.Errors.MissingObjectException"></exception>
            <exception cref="T:NGit.Errors.IncorrectObjectTypeException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Storage.Pack.DeltaIndex" -->
        <member name="F:NGit.Storage.Pack.DeltaIndex.BLKSZ">
            <summary>Number of bytes in a block.</summary>
            <remarks>Number of bytes in a block.</remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "F:NGit.Storage.Pack.DeltaIndex.MAX_CHAIN_LENGTH" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Storage.Pack.DeltaIndex.EstimateIndexSize(System.Int32)" -->
        <member name="F:NGit.Storage.Pack.DeltaIndex.src">
            <summary>Original source file that we indexed.</summary>
            <remarks>Original source file that we indexed.</remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "F:NGit.Storage.Pack.DeltaIndex.table" -->
        <!-- Badly formed XML comment ignored for member "F:NGit.Storage.Pack.DeltaIndex.entries" -->
        <member name="F:NGit.Storage.Pack.DeltaIndex.tableMask">
            <summary>
            Mask to make block hashes into an array index for
            <see cref="F:NGit.Storage.Pack.DeltaIndex.table">table</see>
            .
            </summary>
        </member>
        <member name="M:NGit.Storage.Pack.DeltaIndex.#ctor(System.Byte[])">
            <summary>Construct an index from the source file.</summary>
            <remarks>Construct an index from the source file.</remarks>
            <param name="sourceBuffer">
            the source file's raw contents. The buffer will be held by the
            index instance to facilitate matching, and therefore must not
            be modified by the caller.
            </param>
        </member>
        <member name="M:NGit.Storage.Pack.DeltaIndex.GetSourceSize">
            <returns>size of the source buffer this index has scanned.</returns>
        </member>
        <member name="M:NGit.Storage.Pack.DeltaIndex.GetIndexSize">
            <summary>Get an estimate of the memory required by this index.</summary>
            <remarks>Get an estimate of the memory required by this index.</remarks>
            <returns>
            an approximation of the number of bytes used by this index in
            memory. The size includes the cached source buffer size from
            <see cref="M:NGit.Storage.Pack.DeltaIndex.GetSourceSize">GetSourceSize()</see>
            , as well as a rough approximation of JVM
            object overheads.
            </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Storage.Pack.DeltaIndex.Encode(Sharpen.OutputStream,System.Byte[])" -->
        <member name="M:NGit.Storage.Pack.DeltaIndex.Encode(Sharpen.OutputStream,System.Byte[],System.Int32)">
            <summary>Generate a delta sequence to recreate the result buffer.</summary>
            <remarks>Generate a delta sequence to recreate the result buffer.</remarks>
            <param name="out">
            stream to receive the delta instructions that can transform
            this index's source buffer into
            <code>res</code>
            . This stream
            should be buffered, as instructions are written directly to it
            in small bursts. If the caller might need to discard the
            instructions (such as when deltaSizeLimit would be exceeded)
            the caller is responsible for discarding or rewinding the
            stream when this method returns false.
            </param>
            <param name="res">
            the desired result buffer. The generated instructions will
            recreate this buffer when applied to the source buffer stored
            within this index.
            </param>
            <param name="deltaSizeLimit">
            maximum number of bytes that the delta instructions can
            occupy. If the generated instructions would be longer than
            this amount, this method returns false. If 0, there is no
            limit on the length of delta created.
            </param>
            <returns>
            true if the delta is smaller than deltaSizeLimit; false if the
            encoder aborted because the encoded delta instructions would be
            longer than deltaSizeLimit bytes.
            </returns>
            <exception cref="T:System.IO.IOException">the output stream refused to write the instructions.
            	</exception>
        </member>
        <member name="M:NGit.Storage.Pack.DeltaIndex.NewEncoder(Sharpen.OutputStream,System.Int64,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Storage.File.LockFile" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Storage.File.LockFile.Unlock(Sharpen.FilePath)" -->
        <member name="M:NGit.Storage.File.LockFile.GetLockFile(Sharpen.FilePath)">
            <summary>Get the lock file corresponding to the given file.</summary>
            <remarks>Get the lock file corresponding to the given file.</remarks>
            <param name="file"></param>
            <returns>lock file</returns>
        </member>
        <member name="F:NGit.Storage.File.LockFile.FILTER">
            <summary>Filter to skip over active lock files when listing a directory.</summary>
            <remarks>Filter to skip over active lock files when listing a directory.</remarks>
        </member>
        <member name="M:NGit.Storage.File.LockFile.#ctor(Sharpen.FilePath,NGit.Util.FS)">
            <summary>Create a new lock for any file.</summary>
            <remarks>Create a new lock for any file.</remarks>
            <param name="f">the file that will be locked.</param>
            <param name="fs">
            the file system abstraction which will be necessary to perform
            certain file system operations.
            </param>
        </member>
        <member name="M:NGit.Storage.File.LockFile.Lock">
            <summary>Try to establish the lock.</summary>
            <remarks>Try to establish the lock.</remarks>
            <returns>
            true if the lock is now held by the caller; false if it is held
            by someone else.
            </returns>
            <exception cref="T:System.IO.IOException">
            the temporary output file could not be created. The caller
            does not hold the lock.
            </exception>
        </member>
        <member name="M:NGit.Storage.File.LockFile.LockForAppend">
            <summary>Try to establish the lock for appending.</summary>
            <remarks>Try to establish the lock for appending.</remarks>
            <returns>
            true if the lock is now held by the caller; false if it is held
            by someone else.
            </returns>
            <exception cref="T:System.IO.IOException">
            the temporary output file could not be created. The caller
            does not hold the lock.
            </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Storage.File.LockFile.CopyCurrentContent" -->
        <member name="M:NGit.Storage.File.LockFile.Write(NGit.ObjectId)">
            <summary>Write an ObjectId and LF to the temporary file.</summary>
            <remarks>Write an ObjectId and LF to the temporary file.</remarks>
            <param name="id">
            the id to store in the file. The id will be written in hex,
            followed by a sole LF.
            </param>
            <exception cref="T:System.IO.IOException">
            the temporary file could not be written. The lock is released
            before throwing the underlying IO exception to the caller.
            </exception>
            <exception cref="T:Sharpen.RuntimeException">
            the temporary file could not be written. The lock is released
            before throwing the underlying exception to the caller.
            </exception>
        </member>
        <member name="M:NGit.Storage.File.LockFile.Write(System.Byte[])">
            <summary>Write arbitrary data to the temporary file.</summary>
            <remarks>Write arbitrary data to the temporary file.</remarks>
            <param name="content">
            the bytes to store in the temporary file. No additional bytes
            are added, so if the file must end with an LF it must appear
            at the end of the byte array.
            </param>
            <exception cref="T:System.IO.IOException">
            the temporary file could not be written. The lock is released
            before throwing the underlying IO exception to the caller.
            </exception>
            <exception cref="T:Sharpen.RuntimeException">
            the temporary file could not be written. The lock is released
            before throwing the underlying exception to the caller.
            </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Storage.File.LockFile.GetOutputStream" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Storage.File.LockFile.SetNeedStatInformation(System.Boolean)" -->
        <member name="M:NGit.Storage.File.LockFile.SetNeedSnapshot(System.Boolean)">
            <summary>
            Request that
            <see cref="M:NGit.Storage.File.LockFile.Commit">Commit()</see>
            remember the
            <see cref="T:NGit.Storage.File.FileSnapshot">FileSnapshot</see>
            .
            </summary>
            <param name="on">true if the commit method must remember the FileSnapshot.</param>
        </member>
        <member name="M:NGit.Storage.File.LockFile.SetFSync(System.Boolean)">
            <summary>
            Request that
            <see cref="M:NGit.Storage.File.LockFile.Commit">Commit()</see>
            force dirty data to the drive.
            </summary>
            <param name="on">true if dirty data should be forced to the drive.</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Storage.File.LockFile.WaitForStatChange" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Storage.File.LockFile.Commit" -->
        <member name="M:NGit.Storage.File.LockFile.GetCommitLastModified">
            <summary>Get the modification time of the output file when it was committed.</summary>
            <remarks>Get the modification time of the output file when it was committed.</remarks>
            <returns>modification time of the lock file right before we committed it.</returns>
        </member>
        <member name="M:NGit.Storage.File.LockFile.GetCommitSnapshot">
            <returns>
            get the
            <see cref="T:NGit.Storage.File.FileSnapshot">FileSnapshot</see>
            just before commit.
            </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Storage.File.LockFile.CreateCommitSnapshot" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Storage.File.LockFile.Unlock" -->
        <member name="M:NGit.Storage.File.LockFile._OutputStream_323.Write(System.Byte[],System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.LockFile._OutputStream_323.Write(System.Byte[])">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.LockFile._OutputStream_323.Write(System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.LockFile._OutputStream_323.Close">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="T:NGit.Revwalk.DateRevQueue">
            <summary>A queue of commits sorted by commit time order.</summary>
            <remarks>A queue of commits sorted by commit time order.</remarks>
        </member>
        <member name="M:NGit.Revwalk.DateRevQueue.#ctor">
            <summary>Create an empty date queue.</summary>
            <remarks>Create an empty date queue.</remarks>
        </member>
        <member name="M:NGit.Revwalk.DateRevQueue.#ctor(NGit.Revwalk.Generator)">
            <exception cref="T:NGit.Errors.MissingObjectException"></exception>
            <exception cref="T:NGit.Errors.IncorrectObjectTypeException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Revwalk.DateRevQueue.Peek">
            <summary>Peek at the next commit, without removing it.</summary>
            <remarks>Peek at the next commit, without removing it.</remarks>
            <returns>the next available commit; null if there are no commits left.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Revplot.AbstractPlotRenderer`2" -->
        <member name="M:NGit.Revplot.AbstractPlotRenderer`2.PaintCommit(NGit.Revplot.PlotCommit{`0},System.Int32)">
            <summary>Paint one commit using the underlying graphics library.</summary>
            <remarks>Paint one commit using the underlying graphics library.</remarks>
            <param name="commit">the commit to render in this cell. Must not be null.</param>
            <param name="h">total height (in pixels) of this cell.</param>
        </member>
        <member name="M:NGit.Revplot.AbstractPlotRenderer`2.DrawLabel(System.Int32,System.Int32,NGit.Ref)">
            <summary>Draw a decoration for the Ref ref at x,y</summary>
            <param name="x">left</param>
            <param name="y">top</param>
            <param name="ref">A peeled ref</param>
            <returns>width of label in pixels</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Revplot.AbstractPlotRenderer`2.LaneColor(`0)" -->
        <member name="M:NGit.Revplot.AbstractPlotRenderer`2.DrawLine(`1,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>Draw a single line within this cell.</summary>
            <remarks>Draw a single line within this cell.</remarks>
            <param name="color">the color to use while drawing the line.</param>
            <param name="x1">starting X coordinate, 0 based.</param>
            <param name="y1">starting Y coordinate, 0 based.</param>
            <param name="x2">ending X coordinate, 0 based.</param>
            <param name="y2">ending Y coordinate, 0 based.</param>
            <param name="width">number of pixels wide for the line. Always at least 1.</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Revplot.AbstractPlotRenderer`2.DrawCommitDot(System.Int32,System.Int32,System.Int32,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Revplot.AbstractPlotRenderer`2.DrawBoundaryDot(System.Int32,System.Int32,System.Int32,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Revplot.AbstractPlotRenderer`2.DrawText(System.String,System.Int32,System.Int32)" -->
        <member name="T:NGit.Patch.Patch">
            <summary>
            A parsed collection of
            <see cref="T:NGit.Patch.FileHeader">FileHeader</see>
            s from a unified diff patch file
            </summary>
        </member>
        <member name="F:NGit.Patch.Patch.files">
            <summary>The files, in the order they were parsed out of the input.</summary>
            <remarks>The files, in the order they were parsed out of the input.</remarks>
        </member>
        <member name="F:NGit.Patch.Patch.errors">
            <summary>Formatting errors, if any were identified.</summary>
            <remarks>Formatting errors, if any were identified.</remarks>
        </member>
        <member name="M:NGit.Patch.Patch.#ctor">
            <summary>Create an empty patch.</summary>
            <remarks>Create an empty patch.</remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Patch.Patch.AddFile(NGit.Patch.FileHeader)" -->
        <member name="M:NGit.Patch.Patch.GetFiles">
            <returns>list of files described in the patch, in occurrence order.</returns>
        </member>
        <member name="M:NGit.Patch.Patch.AddError(NGit.Patch.FormatError)">
            <summary>Add a formatting error to this patch script.</summary>
            <remarks>Add a formatting error to this patch script.</remarks>
            <param name="err">the error description.</param>
        </member>
        <member name="M:NGit.Patch.Patch.GetErrors">
            <returns>collection of formatting errors, if any.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Patch.Patch.Parse(Sharpen.InputStream)" -->
        <member name="M:NGit.Patch.Patch.ReadFully(Sharpen.InputStream)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Patch.Patch.Parse(System.Byte[],System.Int32,System.Int32)" -->
        <member name="M:NGit.Fnmatch.LastHead.#ctor">
            <summary>
            Don't call this constructor, use
            <see cref="F:NGit.Fnmatch.LastHead.INSTANCE">INSTANCE</see>
            </summary>
        </member>
        <member name="T:NGit.Errors.LargeObjectException">
            <summary>An object is too big to load into memory as a single byte array.</summary>
            <remarks>An object is too big to load into memory as a single byte array.</remarks>
        </member>
        <member name="M:NGit.Errors.LargeObjectException.#ctor">
            <summary>Create a large object exception, where the object isn't known.</summary>
            <remarks>Create a large object exception, where the object isn't known.</remarks>
        </member>
        <member name="M:NGit.Errors.LargeObjectException.#ctor(NGit.AnyObjectId)">
            <summary>Create a large object exception, naming the object that is too big.</summary>
            <remarks>Create a large object exception, naming the object that is too big.</remarks>
            <param name="id">
            identity of the object that is too big to be loaded as a byte
            array in this JVM.
            </param>
        </member>
        <member name="M:NGit.Errors.LargeObjectException.GetObjectId">
            <returns>identity of the object that is too large; may be null.</returns>
        </member>
        <member name="M:NGit.Errors.LargeObjectException.GetObjectName">
            <returns>either the hex encoded name of the object, or 'unknown object'.</returns>
        </member>
        <member name="M:NGit.Errors.LargeObjectException.SetObjectId(NGit.AnyObjectId)">
            <summary>Set the identity of the object, if its not already set.</summary>
            <remarks>Set the identity of the object, if its not already set.</remarks>
            <param name="id">the id of the object that is too large to process.</param>
        </member>
        <member name="T:NGit.Errors.LargeObjectException.OutOfMemory">
            <summary>An error caused by the JVM being out of heap space.</summary>
            <remarks>An error caused by the JVM being out of heap space.</remarks>
        </member>
        <member name="M:NGit.Errors.LargeObjectException.OutOfMemory.#ctor(System.OutOfMemoryException)">
            <summary>Construct a wrapper around the original OutOfMemoryError.</summary>
            <remarks>Construct a wrapper around the original OutOfMemoryError.</remarks>
            <param name="cause">the original root cause.</param>
        </member>
        <member name="T:NGit.Errors.LargeObjectException.ExceedsByteArrayLimit">
            <summary>Object size exceeds JVM limit of 2 GiB per byte array.</summary>
            <remarks>Object size exceeds JVM limit of 2 GiB per byte array.</remarks>
        </member>
        <member name="T:NGit.Errors.LargeObjectException.ExceedsLimit">
            <summary>Object size exceeds the caller's upper limit.</summary>
            <remarks>Object size exceeds the caller's upper limit.</remarks>
        </member>
        <member name="M:NGit.Errors.LargeObjectException.ExceedsLimit.#ctor(System.Int64,System.Int64)">
            <summary>Construct an exception for a particular size being exceeded.</summary>
            <remarks>Construct an exception for a particular size being exceeded.</remarks>
            <param name="limit">the limit the caller imposed on the object.</param>
            <param name="size">the actual size of the object.</param>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Dircache.DirCacheBuilder" -->
        <member name="M:NGit.Dircache.DirCacheBuilder.#ctor(NGit.Dircache.DirCache,System.Int32)">
            <summary>Construct a new builder.</summary>
            <remarks>Construct a new builder.</remarks>
            <param name="dc">the cache this builder will eventually update.</param>
            <param name="ecnt">
            estimated number of entries the builder will have upon
            completion. This sizes the initial entry table.
            </param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Dircache.DirCacheBuilder.Add(NGit.Dircache.DirCacheEntry)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Dircache.DirCacheBuilder.Keep(System.Int32,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Dircache.DirCacheBuilder.AddTree(System.Byte[],System.Int32,NGit.ObjectReader,NGit.AnyObjectId)" -->
        <member name="T:NGit.Api.Errors.NoHeadException">
            <summary>
            Exception thrown when a command expected the
            <code>HEAD</code>
            reference to exist
            but couldn't find such a reference
            </summary>
        </member>
        <member name="M:NGit.Api.Errors.NoHeadException.#ctor(System.String,System.Exception)">
            <param name="message"></param>
            <param name="cause"></param>
        </member>
        <member name="M:NGit.Api.Errors.NoHeadException.#ctor(System.String)">
            <param name="message"></param>
        </member>
        <member name="T:NGit.SymlinkTreeEntry">
            <summary>A tree entry representing a symbolic link.</summary>
            <remarks>
            A tree entry representing a symbolic link.
            Note. Java cannot really handle these as file system objects.
            </remarks>
        </member>
        <member name="M:NGit.SymlinkTreeEntry.#ctor(NGit.Tree,NGit.ObjectId,System.Byte[])">
            <summary>
            Construct a
            <see cref="T:NGit.SymlinkTreeEntry">SymlinkTreeEntry</see>
            with the specified name and SHA-1 in
            the specified parent
            </summary>
            <param name="parent"></param>
            <param name="id"></param>
            <param name="nameUTF8"></param>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.ObjectIdSubclassMap`1" -->
        <member name="M:NGit.ObjectIdSubclassMap`1.#ctor">
            <summary>Create an empty map.</summary>
            <remarks>Create an empty map.</remarks>
        </member>
        <member name="M:NGit.ObjectIdSubclassMap`1.Clear">
            <summary>Remove all entries from this map.</summary>
            <remarks>Remove all entries from this map.</remarks>
        </member>
        <member name="M:NGit.ObjectIdSubclassMap`1.Get(NGit.AnyObjectId)">
            <summary>Lookup an existing mapping.</summary>
            <remarks>Lookup an existing mapping.</remarks>
            <param name="toFind">the object identifier to find.</param>
            <returns>the instance mapped to toFind, or null if no mapping exists.</returns>
        </member>
        <member name="M:NGit.ObjectIdSubclassMap`1.Contains(NGit.AnyObjectId)">
            <summary>Returns true if this map contains the specified object.</summary>
            <remarks>Returns true if this map contains the specified object.</remarks>
            <param name="toFind">object to find.</param>
            <returns>true if the mapping exists for this object; false otherwise.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.ObjectIdSubclassMap`1.Add``1(``0)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.ObjectIdSubclassMap`1.AddIfAbsent``1(``0)" -->
        <member name="M:NGit.ObjectIdSubclassMap`1.Size">
            <returns>number of objects in map</returns>
        </member>
        <member name="M:NGit.ObjectIdSubclassMap`1.IsEmpty">
            <returns>
            true if
            <see cref="M:NGit.ObjectIdSubclassMap`1.Size">ObjectIdSubclassMap&lt;V&gt;.Size()</see>
            is 0.
            </returns>
        </member>
        <member name="T:NGit.IndexDiff">
            <summary>
            Compares the index, a tree, and the working directory Ignored files are not
            taken into account.
            </summary>
            <remarks>
            Compares the index, a tree, and the working directory Ignored files are not
            taken into account. The following information is retrieved:
            <ul>
            <li>added files</li>
            <li>changed files</li>
            <li>removed files</li>
            <li>missing files</li>
            <li>modified files</li>
            <li>conflicting files</li>
            <li>untracked files</li>
            <li>files with assume-unchanged flag</li>
            </ul>
            </remarks>
        </member>
        <member name="M:NGit.IndexDiff.#ctor(NGit.Repository,System.String,NGit.Treewalk.WorkingTreeIterator)">
            <summary>Construct an IndexDiff</summary>
            <param name="repository"></param>
            <param name="revstr">
            symbolic name e.g. HEAD
            An EmptyTreeIterator is used if <code>revstr</code> cannot be resolved.
            </param>
            <param name="workingTreeIterator">iterator for working directory</param>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:NGit.IndexDiff.#ctor(NGit.Repository,NGit.ObjectId,NGit.Treewalk.WorkingTreeIterator)">
            <summary>Construct an Indexdiff</summary>
            <param name="repository"></param>
            <param name="objectId">tree id. If null, an EmptyTreeIterator is used.</param>
            <param name="workingTreeIterator">iterator for working directory</param>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:NGit.IndexDiff.SetFilter(NGit.Treewalk.Filter.TreeFilter)">
            <summary>Sets a filter.</summary>
            <remarks>
            Sets a filter. Can be used e.g. for restricting the tree walk to a set of
            files.
            </remarks>
            <param name="filter"></param>
        </member>
        <member name="M:NGit.IndexDiff.Diff">
            <summary>Run the diff operation.</summary>
            <remarks>
            Run the diff operation. Until this is called, all lists will be empty.
            Use
            <see cref="M:NGit.IndexDiff.Diff(NGit.ProgressMonitor,System.Int32,System.Int32,System.String)">Diff(ProgressMonitor, int, int, string)
            	</see>
            if a progress
            monitor is required.
            </remarks>
            <returns>if anything is different between index, tree, and workdir</returns>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.IndexDiff.Diff(NGit.ProgressMonitor,System.Int32,System.Int32,System.String)" -->
        <member name="M:NGit.IndexDiff.GetAdded">
            <returns>list of files added to the index, not in the tree</returns>
        </member>
        <member name="M:NGit.IndexDiff.GetChanged">
            <returns>list of files changed from tree to index</returns>
        </member>
        <member name="M:NGit.IndexDiff.GetRemoved">
            <returns>list of files removed from index, but in tree</returns>
        </member>
        <member name="M:NGit.IndexDiff.GetMissing">
            <returns>list of files in index, but not filesystem</returns>
        </member>
        <member name="M:NGit.IndexDiff.GetModified">
            <returns>list of files modified on disk relative to the index</returns>
        </member>
        <member name="M:NGit.IndexDiff.GetUntracked">
            <returns>list of files that are not ignored, and not in the index.</returns>
        </member>
        <member name="M:NGit.IndexDiff.GetConflicting">
            <returns>list of files that are in conflict</returns>
        </member>
        <member name="M:NGit.IndexDiff.GetIgnoredNotInIndex">
            <summary>The method returns the list of ignored files and folders.</summary>
            <remarks>
            The method returns the list of ignored files and folders. Only the root
            folder of an ignored folder hierarchy is reported. If a/b/c is listed in
            the .gitignore then you should not expect a/b/c/d/e/f to be reported
            here. Only a/b/c will be reported. Furthermore only ignored files /
            folders are returned that are NOT in the index.
            </remarks>
            <returns>list of files / folders that are ignored</returns>
        </member>
        <member name="M:NGit.IndexDiff.GetAssumeUnchanged">
            <returns>list of files with the flag assume-unchanged</returns>
        </member>
        <member name="M:NGit.IndexDiff.GetUntrackedFolders">
            <returns>list of folders containing only untracked files/folders</returns>
        </member>
        <member name="M:NGit.IndexDiff.GetIndexMode(System.String)">
            <summary>Get the file mode of the given path in the index</summary>
            <param name="path"></param>
            <returns>file mode</returns>
        </member>
        <member name="M:NGit.IndexDiff.ProgressReportingFilter.Include(NGit.Treewalk.TreeWalk)">
            <exception cref="T:NGit.Errors.MissingObjectException"></exception>
            <exception cref="T:NGit.Errors.IncorrectObjectTypeException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="T:NGit.FileTreeEntry">
            <summary>
            A representation of a file (blob) object in a
            <see cref="T:NGit.Tree">Tree</see>
            .
            </summary>
        </member>
        <member name="M:NGit.FileTreeEntry.#ctor(NGit.Tree,NGit.ObjectId,System.Byte[],System.Boolean)">
            <summary>Constructor for a File (blob) object.</summary>
            <remarks>Constructor for a File (blob) object.</remarks>
            <param name="parent">
            The
            <see cref="T:NGit.Tree">Tree</see>
            holding this object (or null)
            </param>
            <param name="id">the SHA-1 of the blob (or null for a yet unhashed file)</param>
            <param name="nameUTF8">raw object name in the parent tree</param>
            <param name="execute">true if the executable flag is set</param>
        </member>
        <member name="M:NGit.FileTreeEntry.IsExecutable">
            <returns>true if this file is executable</returns>
        </member>
        <member name="M:NGit.FileTreeEntry.SetExecutable(System.Boolean)">
            <param name="execute">set/reset the executable flag</param>
        </member>
        <member name="M:NGit.FileTreeEntry.OpenReader">
            <returns>
            an
            <see cref="T:NGit.ObjectLoader">ObjectLoader</see>
            that will return the data
            </returns>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="T:NGit.CommitBuilder">
            <summary>Mutable builder to construct a commit recording the state of a project.</summary>
            <remarks>
            Mutable builder to construct a commit recording the state of a project.
            Applications should use this object when they need to manually construct a
            commit and want precise control over its fields. For a higher level interface
            see
            <see cref="T:NGit.Api.CommitCommand">NGit.Api.CommitCommand</see>
            .
            To read a commit object, construct a
            <see cref="T:NGit.Revwalk.RevWalk">NGit.Revwalk.RevWalk</see>
            and obtain a
            <see cref="T:NGit.Revwalk.RevCommit">NGit.Revwalk.RevCommit</see>
            instance by calling
            <see cref="M:NGit.Revwalk.RevWalk.ParseCommit(NGit.AnyObjectId)">NGit.Revwalk.RevWalk.ParseCommit(AnyObjectId)
            	</see>
            .
            </remarks>
        </member>
        <member name="M:NGit.CommitBuilder.#ctor">
            <summary>Initialize an empty commit.</summary>
            <remarks>Initialize an empty commit.</remarks>
        </member>
        <member name="M:NGit.CommitBuilder.SetParentId(NGit.AnyObjectId)">
            <summary>Set the parent of this commit.</summary>
            <remarks>Set the parent of this commit.</remarks>
            <param name="newParent">the single parent for the commit.</param>
        </member>
        <member name="M:NGit.CommitBuilder.SetParentIds(NGit.AnyObjectId,NGit.AnyObjectId)">
            <summary>Set the parents of this commit.</summary>
            <remarks>Set the parents of this commit.</remarks>
            <param name="parent1">
            the first parent of this commit. Typically this is the current
            value of the
            <code>HEAD</code>
            reference and is thus the current
            branch's position in history.
            </param>
            <param name="parent2">
            the second parent of this merge commit. Usually this is the
            branch being merged into the current branch.
            </param>
        </member>
        <member name="M:NGit.CommitBuilder.SetParentIds(NGit.ObjectId[])">
            <summary>Set the parents of this commit.</summary>
            <remarks>Set the parents of this commit.</remarks>
            <param name="newParents">the entire list of parents for this commit.</param>
        </member>
        <member name="M:NGit.CommitBuilder.SetParentIds``1(System.Collections.Generic.IList{``0})">
            <summary>Set the parents of this commit.</summary>
            <remarks>Set the parents of this commit.</remarks>
            <param name="newParents">the entire list of parents for this commit.</param>
        </member>
        <member name="M:NGit.CommitBuilder.AddParentId(NGit.AnyObjectId)">
            <summary>Add a parent onto the end of the parent list.</summary>
            <remarks>Add a parent onto the end of the parent list.</remarks>
            <param name="additionalParent">new parent to add onto the end of the current parent list.
            	</param>
        </member>
        <member name="M:NGit.CommitBuilder.SetEncoding(System.String)">
            <summary>Set the encoding for the commit information</summary>
            <param name="encodingName">
            the encoding name. See
            <see cref="M:Sharpen.Extensions.GetEncoding(System.String)">Sharpen.Extensions.GetEncoding(string)
            	</see>
            .
            </param>
        </member>
        <member name="M:NGit.CommitBuilder.SetEncoding(System.Text.Encoding)">
            <summary>Set the encoding for the commit information</summary>
            <param name="enc">the encoding to use.</param>
        </member>
        <member name="M:NGit.CommitBuilder.Build">
            <summary>Format this builder's state as a commit object.</summary>
            <remarks>Format this builder's state as a commit object.</remarks>
            <returns>
            this object in the canonical commit format, suitable for storage
            in a repository.
            </returns>
            <exception cref="T:Sharpen.UnsupportedEncodingException">
            the encoding specified by
            <see cref="P:NGit.CommitBuilder.Encoding">Encoding()</see>
            is not
            supported by this Java runtime.
            </exception>
        </member>
        <member name="M:NGit.CommitBuilder.ToByteArray">
            <summary>Format this builder's state as a commit object.</summary>
            <remarks>Format this builder's state as a commit object.</remarks>
            <returns>
            this object in the canonical commit format, suitable for storage
            in a repository.
            </returns>
            <exception cref="T:Sharpen.UnsupportedEncodingException">
            the encoding specified by
            <see cref="P:NGit.CommitBuilder.Encoding">Encoding()</see>
            is not
            supported by this Java runtime.
            </exception>
        </member>
        <member name="P:NGit.CommitBuilder.TreeId">
            <returns>id of the root tree listing this commit's snapshot.</returns>
            <summary>Set the tree id for this commit object</summary>
            <value>the tree identity.</value>
        </member>
        <member name="P:NGit.CommitBuilder.Author">
            <returns>the author of this commit (who wrote it).</returns>
            <summary>Set the author (name, email address, and date) of who wrote the commit.</summary>
            <remarks>Set the author (name, email address, and date) of who wrote the commit.</remarks>
            <value>the new author. Should not be null.</value>
        </member>
        <member name="P:NGit.CommitBuilder.Committer">
            <returns>the committer and commit time for this object.</returns>
            <summary>Set the committer and commit time for this object</summary>
            <value>the committer information. Should not be null.</value>
        </member>
        <member name="P:NGit.CommitBuilder.ParentIds">
            <returns>the ancestors of this commit. Never null.</returns>
        </member>
        <member name="P:NGit.CommitBuilder.Message">
            <returns>the complete commit message.</returns>
            <summary>Set the commit message.</summary>
            <remarks>Set the commit message.</remarks>
            <value>the commit message. Should not be null.</value>
        </member>
        <member name="P:NGit.CommitBuilder.Encoding">
            <returns>the encoding that should be used for the commit message text.</returns>
        </member>
        <member name="T:NGit.Api.Errors.PatchFormatException">
            <summary>Exception thrown when applying a patch fails due to an invalid format</summary>
            <since>2.0</since>
        </member>
        <member name="M:NGit.Api.Errors.PatchFormatException.#ctor(System.Collections.Generic.IList{NGit.Patch.FormatError})">
            <param name="errors"></param>
        </member>
        <member name="M:NGit.Api.Errors.PatchFormatException.GetErrors">
            <returns>all the errors where unresolved conflicts have been detected</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Api.ApplyCommand" -->
        <member name="M:NGit.Api.ApplyCommand.#ctor(NGit.Repository)">
            <summary>Constructs the command if the patch is to be applied to the index.</summary>
            <remarks>Constructs the command if the patch is to be applied to the index.</remarks>
            <param name="repo"></param>
        </member>
        <member name="M:NGit.Api.ApplyCommand.SetPatch(Sharpen.InputStream)">
            <param name="in">the patch to apply</param>
            <returns>this instance</returns>
        </member>
        <member name="M:NGit.Api.ApplyCommand.Call">
            <summary>
            Executes the
            <code>ApplyCommand</code>
            command with all the options and
            parameters collected by the setter methods (e.g.
            <see cref="M:NGit.Api.ApplyCommand.SetPatch(Sharpen.InputStream)">SetPatch(Sharpen.InputStream)</see>
            of this class. Each instance of this class
            should only be used for one invocation of the command. Don't call this
            method twice on an instance.
            </summary>
            <returns>
            an
            <see cref="T:NGit.Api.ApplyResult">ApplyResult</see>
            object representing the command result
            </returns>
            <exception cref="T:NGit.Api.Errors.GitAPIException">NGit.Api.Errors.GitAPIException
            	</exception>
            <exception cref="T:NGit.Api.Errors.PatchFormatException">NGit.Api.Errors.PatchFormatException
            	</exception>
            <exception cref="T:NGit.Api.Errors.PatchApplyException">NGit.Api.Errors.PatchApplyException
            	</exception>
        </member>
        <member name="M:NGit.Api.ApplyCommand.GetFile(System.String,System.Boolean)">
            <exception cref="T:NGit.Api.Errors.PatchApplyException"></exception>
        </member>
        <member name="M:NGit.Api.ApplyCommand.Apply(Sharpen.FilePath,NGit.Patch.FileHeader)">
            <param name="f"></param>
            <param name="fh"></param>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
            <exception cref="T:NGit.Api.Errors.PatchApplyException">NGit.Api.Errors.PatchApplyException
            	</exception>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Util.IO.AutoCRLFOutputStream" -->
        <member name="M:NGit.Util.IO.AutoCRLFOutputStream.#ctor(Sharpen.OutputStream)">
            <param name="out"></param>
        </member>
        <member name="M:NGit.Util.IO.AutoCRLFOutputStream.Write(System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Util.IO.AutoCRLFOutputStream.Write(System.Byte[])">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Util.IO.AutoCRLFOutputStream.Write(System.Byte[],System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Util.IO.AutoCRLFOutputStream.Buffer(System.Byte)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Util.IO.AutoCRLFOutputStream.Buffer(System.Byte[],System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Util.IO.AutoCRLFOutputStream.DecideMode">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Util.IO.AutoCRLFOutputStream.Flush">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Util.IO.AutoCRLFOutputStream.Close">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Api.SubmoduleStatusCommand" -->
        <member name="M:NGit.Api.SubmoduleStatusCommand.#ctor(NGit.Repository)">
            <param name="repo"></param>
        </member>
        <member name="M:NGit.Api.SubmoduleStatusCommand.AddPath(System.String)">
            <summary>Add repository-relative submodule path to limit status reporting to</summary>
            <param name="path"></param>
            <returns>this command</returns>
        </member>
        <member name="M:NGit.Api.SubmoduleStatusCommand.Call">
            <exception cref="T:NGit.Api.Errors.GitAPIException"></exception>
        </member>
        <member name="M:NGit.Api.SubmoduleStatusCommand.GetStatus(NGit.Submodule.SubmoduleWalk)">
            <exception cref="T:System.IO.IOException"></exception>
            <exception cref="T:NGit.Errors.ConfigInvalidException"></exception>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Api.ReflogCommand" -->
        <member name="M:NGit.Api.ReflogCommand.#ctor(NGit.Repository)">
            <param name="repo"></param>
        </member>
        <member name="M:NGit.Api.ReflogCommand.SetRef(System.String)">
            <summary>The ref used for the reflog operation.</summary>
            <remarks>
            The ref used for the reflog operation. If no ref is set, the default
            value of HEAD will be used.
            </remarks>
            <param name="ref"></param>
            <returns>
            
            <code>this</code>
            </returns>
        </member>
        <member name="M:NGit.Api.ReflogCommand.Call">
            <summary>Run the reflog command</summary>
            <exception cref="T:NGit.Api.Errors.GitAPIException">NGit.Api.Errors.GitAPIException
            	</exception>
            <exception cref="T:NGit.Api.Errors.InvalidRefNameException">NGit.Api.Errors.InvalidRefNameException
            	</exception>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.ObjectIdOwnerMap`1" -->
        <member name="F:NGit.ObjectIdOwnerMap`1.INITIAL_DIRECTORY">
            <summary>Size of the initial directory, will grow as necessary.</summary>
            <remarks>Size of the initial directory, will grow as necessary.</remarks>
        </member>
        <member name="F:NGit.ObjectIdOwnerMap`1.SEGMENT_BITS">
            <summary>Number of bits in a segment's index.</summary>
            <remarks>Number of bits in a segment's index. Segments are 2^11 in size.</remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "F:NGit.ObjectIdOwnerMap`1.directory" -->
        <member name="F:NGit.ObjectIdOwnerMap`1.size">
            <summary>Total number of objects in this map.</summary>
            <remarks>Total number of objects in this map.</remarks>
        </member>
        <member name="F:NGit.ObjectIdOwnerMap`1.grow">
            <summary>
            The map doubles in capacity when
            <see cref="F:NGit.ObjectIdOwnerMap`1.size">ObjectIdOwnerMap&lt;V&gt;.size</see>
            reaches this target.
            </summary>
        </member>
        <member name="F:NGit.ObjectIdOwnerMap`1.bits">
            <summary>
            Number of low bits used to form the index into
            <see cref="F:NGit.ObjectIdOwnerMap`1.directory">ObjectIdOwnerMap&lt;V&gt;.directory</see>
            .
            </summary>
        </member>
        <member name="F:NGit.ObjectIdOwnerMap`1.mask">
            <summary>
            Low bit mask to index into
            <see cref="F:NGit.ObjectIdOwnerMap`1.directory">ObjectIdOwnerMap&lt;V&gt;.directory</see>
            ,
            <code>2^bits-1</code>
            .
            </summary>
        </member>
        <member name="M:NGit.ObjectIdOwnerMap`1.#ctor">
            <summary>Create an empty map.</summary>
            <remarks>Create an empty map.</remarks>
        </member>
        <member name="M:NGit.ObjectIdOwnerMap`1.Clear">
            <summary>Remove all entries from this map.</summary>
            <remarks>Remove all entries from this map.</remarks>
        </member>
        <member name="M:NGit.ObjectIdOwnerMap`1.Get(NGit.AnyObjectId)">
            <summary>Lookup an existing mapping.</summary>
            <remarks>Lookup an existing mapping.</remarks>
            <param name="toFind">the object identifier to find.</param>
            <returns>the instance mapped to toFind, or null if no mapping exists.</returns>
        </member>
        <member name="M:NGit.ObjectIdOwnerMap`1.Contains(NGit.AnyObjectId)">
            <summary>Returns true if this map contains the specified object.</summary>
            <remarks>Returns true if this map contains the specified object.</remarks>
            <param name="toFind">object to find.</param>
            <returns>true if the mapping exists for this object; false otherwise.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.ObjectIdOwnerMap`1.Add``1(``0)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.ObjectIdOwnerMap`1.AddIfAbsent``1(``0)" -->
        <member name="M:NGit.ObjectIdOwnerMap`1.Size">
            <returns>number of objects in this map.</returns>
        </member>
        <member name="M:NGit.ObjectIdOwnerMap`1.IsEmpty">
            <returns>
            true if
            <see cref="M:NGit.ObjectIdOwnerMap`1.Size">ObjectIdOwnerMap&lt;V&gt;.Size()</see>
            is 0.
            </returns>
        </member>
        <member name="T:NGit.Transport.Resolver.ServiceNotEnabledException">
            <summary>Indicates the request service is not enabled on a repository.</summary>
            <remarks>Indicates the request service is not enabled on a repository.</remarks>
        </member>
        <member name="M:NGit.Transport.Resolver.ServiceNotEnabledException.#ctor">
            <summary>Indicates the request service is not available.</summary>
            <remarks>Indicates the request service is not available.</remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Storage.File.ObjectDirectoryPackParser" -->
        <member name="F:NGit.Storage.File.ObjectDirectoryPackParser.crc">
            <summary>CRC-32 computation for objects that are appended onto the pack.</summary>
            <remarks>CRC-32 computation for objects that are appended onto the pack.</remarks>
        </member>
        <member name="F:NGit.Storage.File.ObjectDirectoryPackParser.tailDigest">
            <summary>
            Running SHA-1 of any base objects appended after
            <see cref="F:NGit.Storage.File.ObjectDirectoryPackParser.origEnd">origEnd</see>
            .
            </summary>
        </member>
        <member name="F:NGit.Storage.File.ObjectDirectoryPackParser.indexVersion">
            <summary>Preferred format version of the pack-*.idx file to generate.</summary>
            <remarks>Preferred format version of the pack-*.idx file to generate.</remarks>
        </member>
        <member name="F:NGit.Storage.File.ObjectDirectoryPackParser.keepEmpty">
            <summary>If true, pack with 0 objects will be stored.</summary>
            <remarks>If true, pack with 0 objects will be stored. Usually these are deleted.</remarks>
        </member>
        <member name="F:NGit.Storage.File.ObjectDirectoryPackParser.tmpPack">
            <summary>Path of the temporary file holding the pack data.</summary>
            <remarks>Path of the temporary file holding the pack data.</remarks>
        </member>
        <member name="F:NGit.Storage.File.ObjectDirectoryPackParser.tmpIdx">
            <summary>
            Path of the index created for the pack, to find objects quickly at read
            time.
            </summary>
            <remarks>
            Path of the index created for the pack, to find objects quickly at read
            time.
            </remarks>
        </member>
        <member name="F:NGit.Storage.File.ObjectDirectoryPackParser.out">
            <summary>
            Read/write handle to
            <see cref="F:NGit.Storage.File.ObjectDirectoryPackParser.tmpPack">tmpPack</see>
            while it is being parsed.
            </summary>
        </member>
        <member name="F:NGit.Storage.File.ObjectDirectoryPackParser.origEnd">
            <summary>Length of the original pack stream, before missing bases were appended.</summary>
            <remarks>Length of the original pack stream, before missing bases were appended.</remarks>
        </member>
        <member name="F:NGit.Storage.File.ObjectDirectoryPackParser.origHash">
            <summary>
            The original checksum of data up to
            <see cref="F:NGit.Storage.File.ObjectDirectoryPackParser.origEnd">origEnd</see>
            .
            </summary>
        </member>
        <member name="F:NGit.Storage.File.ObjectDirectoryPackParser.packEnd">
            <summary>Current end of the pack file.</summary>
            <remarks>Current end of the pack file.</remarks>
        </member>
        <member name="F:NGit.Storage.File.ObjectDirectoryPackParser.packHash">
            <summary>Checksum of the entire pack file.</summary>
            <remarks>Checksum of the entire pack file.</remarks>
        </member>
        <member name="F:NGit.Storage.File.ObjectDirectoryPackParser.def">
            <summary>Compresses delta bases when completing a thin pack.</summary>
            <remarks>Compresses delta bases when completing a thin pack.</remarks>
        </member>
        <member name="F:NGit.Storage.File.ObjectDirectoryPackParser.newPack">
            <summary>The pack that was created, if parsing was successful.</summary>
            <remarks>The pack that was created, if parsing was successful.</remarks>
        </member>
        <member name="M:NGit.Storage.File.ObjectDirectoryPackParser.SetIndexVersion(System.Int32)">
            <summary>Set the pack index file format version this instance will create.</summary>
            <remarks>Set the pack index file format version this instance will create.</remarks>
            <param name="version">
            the version to write. The special version 0 designates the
            oldest (most compatible) format available for the objects.
            </param>
            <seealso cref="T:NGit.Storage.File.PackIndexWriter">PackIndexWriter</seealso>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Storage.File.ObjectDirectoryPackParser.SetKeepEmpty(System.Boolean)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Storage.File.ObjectDirectoryPackParser.GetPackFile" -->
        <member name="M:NGit.Storage.File.ObjectDirectoryPackParser.Parse(NGit.ProgressMonitor,NGit.ProgressMonitor)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.ObjectDirectoryPackParser.OnPackHeader(System.Int64)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.ObjectDirectoryPackParser.OnBeginWholeObject(System.Int64,System.Int32,System.Int64)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.ObjectDirectoryPackParser.OnEndWholeObject(NGit.Transport.PackedObjectInfo)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.ObjectDirectoryPackParser.OnBeginOfsDelta(System.Int64,System.Int64,System.Int64)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.ObjectDirectoryPackParser.OnBeginRefDelta(System.Int64,NGit.AnyObjectId,System.Int64)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.ObjectDirectoryPackParser.OnEndDelta">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.ObjectDirectoryPackParser.OnInflatedObjectData(NGit.Transport.PackedObjectInfo,System.Int32,System.Byte[])">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.ObjectDirectoryPackParser.OnObjectHeader(NGit.Transport.PackParser.Source,System.Byte[],System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.ObjectDirectoryPackParser.OnObjectData(NGit.Transport.PackParser.Source,System.Byte[],System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.ObjectDirectoryPackParser.OnStoreStream(System.Byte[],System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.ObjectDirectoryPackParser.OnPackFooter(System.Byte[])">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.ObjectDirectoryPackParser.SeekDatabase(NGit.Transport.PackParser.UnresolvedDelta,NGit.Transport.PackParser.ObjectTypeAndSize)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.ObjectDirectoryPackParser.SeekDatabase(NGit.Transport.PackedObjectInfo,NGit.Transport.PackParser.ObjectTypeAndSize)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.ObjectDirectoryPackParser.ReadDatabase(System.Byte[],System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.ObjectDirectoryPackParser.OnAppendBase(System.Int32,System.Byte[],NGit.Transport.PackedObjectInfo)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.ObjectDirectoryPackParser.OnEndThinPack">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.ObjectDirectoryPackParser.WriteIdx">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.ObjectDirectoryPackParser.RenameAndOpenPack(System.String)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Api.RevertCommand" -->
        <member name="M:NGit.Api.RevertCommand.#ctor(NGit.Repository)">
            <param name="repo"></param>
        </member>
        <member name="M:NGit.Api.RevertCommand.Call">
            <summary>
            Executes the
            <code>revert</code>
            command with all the options and parameters
            collected by the setter methods (e.g.
            <see cref="M:NGit.Api.RevertCommand.Include(NGit.Ref)">Include(NGit.Ref)</see>
            of this
            class. Each instance of this class should only be used for one invocation
            of the command. Don't call this method twice on an instance.
            </summary>
            <returns>
            on success the
            <see cref="T:NGit.Revwalk.RevCommit">NGit.Revwalk.RevCommit</see>
            pointed to by the new HEAD is
            returned. If a failure occurred during revert <code>null</code>
            is returned. The list of successfully reverted
            <see cref="T:NGit.Ref">NGit.Ref</see>
            's can
            be obtained by calling
            <see cref="M:NGit.Api.RevertCommand.GetRevertedRefs">GetRevertedRefs()</see>
            </returns>
            <exception cref="T:NGit.Api.Errors.GitAPIException">NGit.Api.Errors.GitAPIException
            	</exception>
            <exception cref="T:NGit.Api.Errors.WrongRepositoryStateException">NGit.Api.Errors.WrongRepositoryStateException
            	</exception>
            <exception cref="T:NGit.Api.Errors.ConcurrentRefUpdateException">NGit.Api.Errors.ConcurrentRefUpdateException
            	</exception>
            <exception cref="T:NGit.Api.Errors.UnmergedPathsException">NGit.Api.Errors.UnmergedPathsException
            	</exception>
            <exception cref="T:NGit.Api.Errors.NoMessageException">NGit.Api.Errors.NoMessageException
            	</exception>
        </member>
        <member name="M:NGit.Api.RevertCommand.Include(NGit.Ref)">
            <param name="commit">
            a reference to a commit which is reverted into the current
            head
            </param>
            <returns>
            
            <code>this</code>
            </returns>
        </member>
        <member name="M:NGit.Api.RevertCommand.Include(NGit.AnyObjectId)">
            <param name="commit">the Id of a commit which is reverted into the current head</param>
            <returns>
            
            <code>this</code>
            </returns>
        </member>
        <member name="M:NGit.Api.RevertCommand.Include(System.String,NGit.AnyObjectId)">
            <param name="name">a name given to the commit</param>
            <param name="commit">the Id of a commit which is reverted into the current head</param>
            <returns>
            
            <code>this</code>
            </returns>
        </member>
        <member name="M:NGit.Api.RevertCommand.GetRevertedRefs">
            <returns>
            the list of successfully reverted
            <see cref="T:NGit.Ref">NGit.Ref</see>
            's. Never
            <code>null</code> but maybe an empty list if no commit was
            successfully cherry-picked
            </returns>
        </member>
        <member name="M:NGit.Api.RevertCommand.GetFailingResult">
            <returns>
            the result of the merge failure, <code>null</code> if no merge
            failure occurred during the revert
            </returns>
        </member>
        <member name="M:NGit.Api.RevertCommand.GetUnmergedPaths">
            <returns>the unmerged paths, will be null if no merge conflicts</returns>
        </member>
        <member name="T:NGit.Api.Errors.UnmergedPathsException">
            <summary>Thrown when branch deletion fails due to unmerged data</summary>
        </member>
        <member name="M:NGit.Api.Errors.UnmergedPathsException.#ctor">
            <summary>The default constructor with a default message</summary>
        </member>
        <member name="M:NGit.Api.Errors.UnmergedPathsException.#ctor(System.Exception)">
            <summary>The default constructor with a default message</summary>
            <param name="cause">original exception</param>
        </member>
        <member name="T:NGit.Transport.CredentialsProviderUserInfo">
            <summary>
            A JSch
            <see cref="T:NSch.UserInfo">NSch.UserInfo</see>
            adapter for a
            <see cref="T:NGit.Transport.CredentialsProvider">CredentialsProvider</see>
            .
            </summary>
        </member>
        <member name="M:NGit.Transport.CredentialsProviderUserInfo.#ctor(NSch.Session,NGit.Transport.CredentialsProvider)">
            <summary>Wrap a CredentialsProvider to make it suitable for use with JSch.</summary>
            <remarks>Wrap a CredentialsProvider to make it suitable for use with JSch.</remarks>
            <param name="session">the JSch session this UserInfo will support authentication on.
            	</param>
            <param name="credentialsProvider">the provider that will perform the authentication.
            	</param>
        </member>
        <member name="T:NGit.Diff.HistogramDiff">
            <summary>An extended form of Bram Cohen's patience diff algorithm.</summary>
            <remarks>
            An extended form of Bram Cohen's patience diff algorithm.
            This implementation was derived by using the 4 rules that are outlined in
            Bram Cohen's <a href="http://bramcohen.livejournal.com/73318.html">blog</a>,
            and then was further extended to support low-occurrence common elements.
            The basic idea of the algorithm is to create a histogram of occurrences for
            each element of sequence A. Each element of sequence B is then considered in
            turn. If the element also exists in sequence A, and has a lower occurrence
            count, the positions are considered as a candidate for the longest common
            subsequence (LCS). After scanning of B is complete the LCS that has the
            lowest number of occurrences is chosen as a split point. The region is split
            around the LCS, and the algorithm is recursively applied to the sections
            before and after the LCS.
            By always selecting a LCS position with the lowest occurrence count, this
            algorithm behaves exactly like Bram Cohen's patience diff whenever there is a
            unique common element available between the two sequences. When no unique
            elements exist, the lowest occurrence element is chosen instead. This offers
            more readable diffs than simply falling back on the standard Myers' O(ND)
            algorithm would produce.
            To prevent the algorithm from having an O(N^2) running time, an upper limit
            on the number of unique elements in a histogram bucket is configured by
            <see cref="M:NGit.Diff.HistogramDiff.SetMaxChainLength(System.Int32)">SetMaxChainLength(int)</see>
            . If sequence A has more than this many
            elements that hash into the same hash bucket, the algorithm passes the region
            to
            <see cref="M:NGit.Diff.HistogramDiff.SetFallbackAlgorithm(NGit.Diff.DiffAlgorithm)">SetFallbackAlgorithm(DiffAlgorithm)
            	</see>
            . If no fallback algorithm is
            configured, the region is emitted as a replace edit.
            During scanning of sequence B, any element of A that occurs more than
            <see cref="M:NGit.Diff.HistogramDiff.SetMaxChainLength(System.Int32)">SetMaxChainLength(int)</see>
            times is never considered for an LCS match
            position, even if it is common between the two sequences. This limits the
            number of locations in sequence A that must be considered to find the LCS,
            and helps maintain a lower running time bound.
            So long as
            <see cref="M:NGit.Diff.HistogramDiff.SetMaxChainLength(System.Int32)">SetMaxChainLength(int)</see>
            is a small constant (such as 64),
            the algorithm runs in O(N * D) time, where N is the sum of the input lengths
            and D is the number of edits in the resulting EditList. If the supplied
            <see cref="T:NGit.Diff.SequenceComparator`1">SequenceComparator&lt;S&gt;</see>
            has a good hash function, this implementation
            typically out-performs
            <see cref="T:NGit.Diff.MyersDiff`1">MyersDiff&lt;S&gt;</see>
            , even though its theoretical running
            time is the same.
            This implementation has an internal limitation that prevents it from handling
            sequences with more than 268,435,456 (2^28) elements.
            </remarks>
        </member>
        <member name="F:NGit.Diff.HistogramDiff.fallback">
            <summary>Algorithm to use when there are too many element occurrences.</summary>
            <remarks>Algorithm to use when there are too many element occurrences.</remarks>
        </member>
        <member name="F:NGit.Diff.HistogramDiff.maxChainLength">
            <summary>Maximum number of positions to consider for a given element hash.</summary>
            <remarks>
            Maximum number of positions to consider for a given element hash.
            All elements with the same hash are stored into a single chain. The chain
            size is capped to ensure search is linear time at O(len_A + len_B) rather
            than quadratic at O(len_A * len_B).
            </remarks>
        </member>
        <member name="M:NGit.Diff.HistogramDiff.SetFallbackAlgorithm(NGit.Diff.DiffAlgorithm)">
            <summary>Set the algorithm used when there are too many element occurrences.</summary>
            <remarks>Set the algorithm used when there are too many element occurrences.</remarks>
            <param name="alg">
            the secondary algorithm. If null the region will be denoted as
            a single REPLACE block.
            </param>
        </member>
        <member name="M:NGit.Diff.HistogramDiff.SetMaxChainLength(System.Int32)">
            <summary>Maximum number of positions to consider for a given element hash.</summary>
            <remarks>
            Maximum number of positions to consider for a given element hash.
            All elements with the same hash are stored into a single chain. The chain
            size is capped to ensure search is linear time at O(len_A + len_B) rather
            than quadratic at O(len_A * len_B).
            </remarks>
            <param name="maxLen">new maximum length.</param>
        </member>
        <member name="F:NGit.Diff.HistogramDiff.State`1.edits">
            <summary>Result edits we have determined that must be made to convert a to b.</summary>
            <remarks>Result edits we have determined that must be made to convert a to b.</remarks>
        </member>
        <member name="F:NGit.Transport.FetchProcess.transport">
            <summary>Transport we will fetch over.</summary>
            <remarks>Transport we will fetch over.</remarks>
        </member>
        <member name="F:NGit.Transport.FetchProcess.toFetch">
            <summary>List of things we want to fetch from the remote repository.</summary>
            <remarks>List of things we want to fetch from the remote repository.</remarks>
        </member>
        <member name="F:NGit.Transport.FetchProcess.askFor">
            <summary>Set of refs we will actually wind up asking to obtain.</summary>
            <remarks>Set of refs we will actually wind up asking to obtain.</remarks>
        </member>
        <member name="F:NGit.Transport.FetchProcess.have">
            <summary>Objects we know we have locally.</summary>
            <remarks>Objects we know we have locally.</remarks>
        </member>
        <member name="F:NGit.Transport.FetchProcess.localUpdates">
            <summary>Updates to local tracking branches (if any).</summary>
            <remarks>Updates to local tracking branches (if any).</remarks>
        </member>
        <member name="F:NGit.Transport.FetchProcess.fetchHeadUpdates">
            <summary>Records to be recorded into FETCH_HEAD.</summary>
            <remarks>Records to be recorded into FETCH_HEAD.</remarks>
        </member>
        <member name="M:NGit.Transport.FetchProcess.Execute(NGit.ProgressMonitor,NGit.Transport.FetchResult)">
            <exception cref="T:System.NotSupportedException"></exception>
            <exception cref="T:NGit.Errors.TransportException"></exception>
        </member>
        <member name="M:NGit.Transport.FetchProcess.ExecuteImp(NGit.ProgressMonitor,NGit.Transport.FetchResult)">
            <exception cref="T:System.NotSupportedException"></exception>
            <exception cref="T:NGit.Errors.TransportException"></exception>
        </member>
        <member name="M:NGit.Transport.FetchProcess.FetchObjects(NGit.ProgressMonitor)">
            <exception cref="T:NGit.Errors.TransportException"></exception>
        </member>
        <member name="M:NGit.Transport.FetchProcess.ReopenConnection">
            <exception cref="T:System.NotSupportedException"></exception>
            <exception cref="T:NGit.Errors.TransportException"></exception>
        </member>
        <member name="M:NGit.Transport.FetchProcess.UpdateFETCH_HEAD(NGit.Transport.FetchResult)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Transport.FetchProcess.AskForIsComplete">
            <exception cref="T:NGit.Errors.TransportException"></exception>
        </member>
        <member name="M:NGit.Transport.FetchProcess.ExpandWildcard(NGit.Transport.RefSpec,System.Collections.Generic.ICollection{NGit.Ref})">
            <exception cref="T:NGit.Errors.TransportException"></exception>
        </member>
        <member name="M:NGit.Transport.FetchProcess.ExpandSingle(NGit.Transport.RefSpec,System.Collections.Generic.ICollection{NGit.Ref})">
            <exception cref="T:NGit.Errors.TransportException"></exception>
        </member>
        <member name="M:NGit.Transport.FetchProcess.ExpandAutoFollowTags">
            <exception cref="T:NGit.Errors.TransportException"></exception>
        </member>
        <member name="M:NGit.Transport.FetchProcess.ExpandFetchTags">
            <exception cref="T:NGit.Errors.TransportException"></exception>
        </member>
        <member name="M:NGit.Transport.FetchProcess.WantTag(NGit.Ref)">
            <exception cref="T:NGit.Errors.TransportException"></exception>
        </member>
        <member name="M:NGit.Transport.FetchProcess.Want(NGit.Ref,NGit.Transport.RefSpec)">
            <exception cref="T:NGit.Errors.TransportException"></exception>
        </member>
        <member name="M:NGit.Transport.FetchProcess.CreateUpdate(NGit.Transport.RefSpec,NGit.ObjectId)">
            <exception cref="T:NGit.Errors.TransportException"></exception>
        </member>
        <member name="M:NGit.Transport.FetchProcess.LocalRefs">
            <exception cref="T:NGit.Errors.TransportException"></exception>
        </member>
        <member name="M:NGit.Transport.FetchProcess.DeleteStaleTrackingRefs(NGit.Transport.FetchResult,NGit.BatchRefUpdate)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Util.RawCharUtil" -->
        <member name="M:NGit.Util.RawCharUtil.IsWhitespace(System.Byte)">
            <summary>Determine if an 8-bit US-ASCII encoded character is represents whitespace
            	</summary>
            <param name="c">the 8-bit US-ASCII encoded character</param>
            <returns>true if c represents a whitespace character in 8-bit US-ASCII</returns>
        </member>
        <member name="M:NGit.Util.RawCharUtil.TrimTrailingWhitespace(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Returns the new end point for the byte array passed in after trimming any
            trailing whitespace characters, as determined by the isWhitespace()
            function.
            </summary>
            <remarks>
            Returns the new end point for the byte array passed in after trimming any
            trailing whitespace characters, as determined by the isWhitespace()
            function. start and end are assumed to be within the bounds of raw.
            </remarks>
            <param name="raw">the byte array containing the portion to trim whitespace for</param>
            <param name="start">the start of the section of bytes</param>
            <param name="end">the end of the section of bytes</param>
            <returns>the new end point</returns>
        </member>
        <member name="M:NGit.Util.RawCharUtil.TrimLeadingWhitespace(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Returns the new start point for the byte array passed in after trimming
            any leading whitespace characters, as determined by the isWhitespace()
            function.
            </summary>
            <remarks>
            Returns the new start point for the byte array passed in after trimming
            any leading whitespace characters, as determined by the isWhitespace()
            function. start and end are assumed to be within the bounds of raw.
            </remarks>
            <param name="raw">the byte array containing the portion to trim whitespace for</param>
            <param name="start">the start of the section of bytes</param>
            <param name="end">the end of the section of bytes</param>
            <returns>the new start point</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Util.LongList" -->
        <member name="M:NGit.Util.LongList.#ctor">
            <summary>Create an empty list with a default capacity.</summary>
            <remarks>Create an empty list with a default capacity.</remarks>
        </member>
        <member name="M:NGit.Util.LongList.#ctor(System.Int32)">
            <summary>Create an empty list with the specified capacity.</summary>
            <remarks>Create an empty list with the specified capacity.</remarks>
            <param name="capacity">number of entries the list can initially hold.</param>
        </member>
        <member name="M:NGit.Util.LongList.Size">
            <returns>number of entries in this list</returns>
        </member>
        <member name="M:NGit.Util.LongList.Get(System.Int32)">
            <param name="i">
            index to read, must be in the range [0,
            <see cref="M:NGit.Util.LongList.Size">Size()</see>
            ).
            </param>
            <returns>the number at the specified index</returns>
            <exception cref="T:System.IndexOutOfRangeException">the index outside the valid range
            	</exception>
        </member>
        <member name="M:NGit.Util.LongList.Contains(System.Int64)">
            <summary>Determine if an entry appears in this collection.</summary>
            <remarks>Determine if an entry appears in this collection.</remarks>
            <param name="value">the value to search for.</param>
            <returns>
            true of
            <code>value</code>
            appears in this list.
            </returns>
        </member>
        <member name="M:NGit.Util.LongList.Clear">
            <summary>Empty this list</summary>
        </member>
        <member name="M:NGit.Util.LongList.Add(System.Int64)">
            <summary>Add an entry to the end of the list.</summary>
            <remarks>Add an entry to the end of the list.</remarks>
            <param name="n">the number to add.</param>
        </member>
        <member name="M:NGit.Util.LongList.Set(System.Int32,System.Int64)">
            <summary>Assign an entry in the list.</summary>
            <remarks>Assign an entry in the list.</remarks>
            <param name="index">
            index to set, must be in the range [0,
            <see cref="M:NGit.Util.LongList.Size">Size()</see>
            ).
            </param>
            <param name="n">value to store at the position.</param>
        </member>
        <member name="M:NGit.Util.LongList.FillTo(System.Int32,System.Int64)">
            <summary>Pad the list with entries.</summary>
            <remarks>Pad the list with entries.</remarks>
            <param name="toIndex">
            index position to stop filling at. 0 inserts no filler. 1
            ensures the list has a size of 1, adding <code>val</code> if
            the list is currently empty.
            </param>
            <param name="val">value to insert into padded positions.</param>
        </member>
        <member name="M:NGit.Util.LongList.Sort">
            <summary>Sort the list of longs according to their natural ordering.</summary>
            <remarks>Sort the list of longs according to their natural ordering.</remarks>
        </member>
        <member name="T:NGit.Storage.Pack.PackConfig">
            <summary>
            Configuration used by a
            <see cref="T:NGit.Storage.Pack.PackWriter">PackWriter</see>
            when constructing the stream.
            A configuration may be modified once created, but should not be modified
            while it is being used by a PackWriter. If a configuration is not modified it
            is safe to share the same configuration instance between multiple concurrent
            threads executing different PackWriters.
            </summary>
        </member>
        <member name="F:NGit.Storage.Pack.PackConfig.DEFAULT_REUSE_DELTAS">
            <summary>
            Default value of deltas reuse option:
            <value></value>
            </summary>
            <seealso cref="M:NGit.Storage.Pack.PackConfig.SetReuseDeltas(System.Boolean)">SetReuseDeltas(bool)</seealso>
        </member>
        <member name="F:NGit.Storage.Pack.PackConfig.DEFAULT_REUSE_OBJECTS">
            <summary>
            Default value of objects reuse option:
            <value></value>
            </summary>
            <seealso cref="M:NGit.Storage.Pack.PackConfig.SetReuseObjects(System.Boolean)">SetReuseObjects(bool)</seealso>
        </member>
        <member name="F:NGit.Storage.Pack.PackConfig.DEFAULT_DELTA_COMPRESS">
            <summary>
            Default value of delta compress option:
            <value></value>
            </summary>
            <seealso cref="M:NGit.Storage.Pack.PackConfig.SetDeltaCompress(System.Boolean)">SetDeltaCompress(bool)</seealso>
        </member>
        <member name="F:NGit.Storage.Pack.PackConfig.DEFAULT_DELTA_BASE_AS_OFFSET">
            <summary>
            Default value of delta base as offset option:
            <value></value>
            </summary>
            <seealso cref="M:NGit.Storage.Pack.PackConfig.SetDeltaBaseAsOffset(System.Boolean)">SetDeltaBaseAsOffset(bool)</seealso>
        </member>
        <member name="F:NGit.Storage.Pack.PackConfig.DEFAULT_MAX_DELTA_DEPTH">
            <summary>
            Default value of maximum delta chain depth:
            <value></value>
            </summary>
            <seealso cref="M:NGit.Storage.Pack.PackConfig.SetMaxDeltaDepth(System.Int32)">SetMaxDeltaDepth(int)</seealso>
        </member>
        <member name="F:NGit.Storage.Pack.PackConfig.DEFAULT_DELTA_SEARCH_WINDOW_SIZE">
            <summary>
            Default window size during packing:
            <value></value>
            </summary>
            <seealso cref="M:NGit.Storage.Pack.PackConfig.SetDeltaSearchWindowSize(System.Int32)">SetDeltaSearchWindowSize(int)</seealso>
        </member>
        <member name="F:NGit.Storage.Pack.PackConfig.DEFAULT_BIG_FILE_THRESHOLD">
            <summary>
            Default big file threshold:
            <value></value>
            </summary>
            <seealso cref="M:NGit.Storage.Pack.PackConfig.SetBigFileThreshold(System.Int32)">SetBigFileThreshold(int)</seealso>
        </member>
        <member name="F:NGit.Storage.Pack.PackConfig.DEFAULT_DELTA_CACHE_SIZE">
            <summary>
            Default delta cache size:
            <value></value>
            </summary>
            <seealso cref="M:NGit.Storage.Pack.PackConfig.SetDeltaCacheSize(System.Int64)">SetDeltaCacheSize(long)</seealso>
        </member>
        <member name="F:NGit.Storage.Pack.PackConfig.DEFAULT_DELTA_CACHE_LIMIT">
            <summary>
            Default delta cache limit:
            <value></value>
            </summary>
            <seealso cref="M:NGit.Storage.Pack.PackConfig.SetDeltaCacheLimit(System.Int32)">SetDeltaCacheLimit(int)</seealso>
        </member>
        <member name="F:NGit.Storage.Pack.PackConfig.DEFAULT_INDEX_VERSION">
            <summary>
            Default index version:
            <value></value>
            </summary>
            <seealso cref="M:NGit.Storage.Pack.PackConfig.SetIndexVersion(System.Int32)">SetIndexVersion(int)</seealso>
        </member>
        <member name="M:NGit.Storage.Pack.PackConfig.#ctor">
            <summary>Create a default configuration.</summary>
            <remarks>Create a default configuration.</remarks>
        </member>
        <member name="M:NGit.Storage.Pack.PackConfig.#ctor(NGit.Repository)">
            <summary>Create a configuration honoring the repository's settings.</summary>
            <remarks>Create a configuration honoring the repository's settings.</remarks>
            <param name="db">
            the repository to read settings from. The repository is not
            retained by the new configuration, instead its settings are
            copied during the constructor.
            </param>
        </member>
        <member name="M:NGit.Storage.Pack.PackConfig.#ctor(NGit.Config)">
            <summary>
            Create a configuration honoring settings in a
            <see cref="T:NGit.Config">NGit.Config</see>
            .
            </summary>
            <param name="cfg">
            the source to read settings from. The source is not retained
            by the new configuration, instead its settings are copied
            during the constructor.
            </param>
        </member>
        <member name="M:NGit.Storage.Pack.PackConfig.#ctor(NGit.Storage.Pack.PackConfig)">
            <summary>Copy an existing configuration to a new instance.</summary>
            <remarks>Copy an existing configuration to a new instance.</remarks>
            <param name="cfg">the source configuration to copy from.</param>
        </member>
        <member name="M:NGit.Storage.Pack.PackConfig.IsReuseDeltas">
            <summary>Check whether to reuse deltas existing in repository.</summary>
            <remarks>
            Check whether to reuse deltas existing in repository.
            Default setting:
            <value>#DEFAULT_REUSE_DELTAS</value>
            </remarks>
            <returns>true if object is configured to reuse deltas; false otherwise.</returns>
        </member>
        <member name="M:NGit.Storage.Pack.PackConfig.SetReuseDeltas(System.Boolean)">
            <summary>Set reuse deltas configuration option for the writer.</summary>
            <remarks>
            Set reuse deltas configuration option for the writer.
            When enabled, writer will search for delta representation of object in
            repository and use it if possible. Normally, only deltas with base to
            another object existing in set of objects to pack will be used. The
            exception however is thin-packs where the base object may exist on the
            other side.
            When raw delta data is directly copied from a pack file, its checksum is
            computed to verify the data is not corrupt.
            Default setting:
            <value>#DEFAULT_REUSE_DELTAS</value>
            </remarks>
            <param name="reuseDeltas">boolean indicating whether or not try to reuse deltas.</param>
        </member>
        <member name="M:NGit.Storage.Pack.PackConfig.IsReuseObjects">
            <summary>Checks whether to reuse existing objects representation in repository.</summary>
            <remarks>
            Checks whether to reuse existing objects representation in repository.
            Default setting:
            <value>#DEFAULT_REUSE_OBJECTS</value>
            </remarks>
            <returns>
            true if writer is configured to reuse objects representation from
            pack; false otherwise.
            </returns>
        </member>
        <member name="M:NGit.Storage.Pack.PackConfig.SetReuseObjects(System.Boolean)">
            <summary>Set reuse objects configuration option for the writer.</summary>
            <remarks>
            Set reuse objects configuration option for the writer.
            If enabled, writer searches for compressed representation in a pack file.
            If possible, compressed data is directly copied from such a pack file.
            Data checksum is verified.
            Default setting:
            <value>#DEFAULT_REUSE_OBJECTS</value>
            </remarks>
            <param name="reuseObjects">
            boolean indicating whether or not writer should reuse existing
            objects representation.
            </param>
        </member>
        <member name="M:NGit.Storage.Pack.PackConfig.IsDeltaBaseAsOffset">
            <summary>True if writer can use offsets to point to a delta base.</summary>
            <remarks>
            True if writer can use offsets to point to a delta base.
            If true the writer may choose to use an offset to point to a delta base
            in the same pack, this is a newer style of reference that saves space.
            False if the writer has to use the older (and more compatible style) of
            storing the full ObjectId of the delta base.
            Default setting:
            <value>#DEFAULT_DELTA_BASE_AS_OFFSET</value>
            </remarks>
            <returns>
            true if delta base is stored as an offset; false if it is stored
            as an ObjectId.
            </returns>
        </member>
        <member name="M:NGit.Storage.Pack.PackConfig.SetDeltaBaseAsOffset(System.Boolean)">
            <summary>Set writer delta base format.</summary>
            <remarks>
            Set writer delta base format.
            Delta base can be written as an offset in a pack file (new approach
            reducing file size) or as an object id (legacy approach, compatible with
            old readers).
            Default setting:
            <value>#DEFAULT_DELTA_BASE_AS_OFFSET</value>
            </remarks>
            <param name="deltaBaseAsOffset">
            boolean indicating whether delta base can be stored as an
            offset.
            </param>
        </member>
        <member name="M:NGit.Storage.Pack.PackConfig.IsDeltaCompress">
            <summary>Check whether the writer will create new deltas on the fly.</summary>
            <remarks>
            Check whether the writer will create new deltas on the fly.
            Default setting:
            <value>#DEFAULT_DELTA_COMPRESS</value>
            </remarks>
            <returns>
            true if the writer will create a new delta when either
            <see cref="M:NGit.Storage.Pack.PackConfig.IsReuseDeltas">IsReuseDeltas()</see>
            is false, or no suitable delta is
            available for reuse.
            </returns>
        </member>
        <member name="M:NGit.Storage.Pack.PackConfig.SetDeltaCompress(System.Boolean)">
            <summary>Set whether or not the writer will create new deltas on the fly.</summary>
            <remarks>
            Set whether or not the writer will create new deltas on the fly.
            Default setting:
            <value>#DEFAULT_DELTA_COMPRESS</value>
            </remarks>
            <param name="deltaCompress">
            true to create deltas when
            <see cref="M:NGit.Storage.Pack.PackConfig.IsReuseDeltas">IsReuseDeltas()</see>
            is false,
            or when a suitable delta isn't available for reuse. Set to
            false to write whole objects instead.
            </param>
        </member>
        <member name="M:NGit.Storage.Pack.PackConfig.GetMaxDeltaDepth">
            <summary>Get maximum depth of delta chain set up for the writer.</summary>
            <remarks>
            Get maximum depth of delta chain set up for the writer.
            Generated chains are not longer than this value.
            Default setting:
            <value>#DEFAULT_MAX_DELTA_DEPTH</value>
            </remarks>
            <returns>maximum delta chain depth.</returns>
        </member>
        <member name="M:NGit.Storage.Pack.PackConfig.SetMaxDeltaDepth(System.Int32)">
            <summary>Set up maximum depth of delta chain for the writer.</summary>
            <remarks>
            Set up maximum depth of delta chain for the writer.
            Generated chains are not longer than this value. Too low value causes low
            compression level, while too big makes unpacking (reading) longer.
            Default setting:
            <value>#DEFAULT_MAX_DELTA_DEPTH</value>
            </remarks>
            <param name="maxDeltaDepth">maximum delta chain depth.</param>
        </member>
        <member name="M:NGit.Storage.Pack.PackConfig.GetDeltaSearchWindowSize">
            <summary>Get the number of objects to try when looking for a delta base.</summary>
            <remarks>
            Get the number of objects to try when looking for a delta base.
            This limit is per thread, if 4 threads are used the actual memory used
            will be 4 times this value.
            Default setting:
            <value>#DEFAULT_DELTA_SEARCH_WINDOW_SIZE</value>
            </remarks>
            <returns>the object count to be searched.</returns>
        </member>
        <member name="M:NGit.Storage.Pack.PackConfig.SetDeltaSearchWindowSize(System.Int32)">
            <summary>Set the number of objects considered when searching for a delta base.</summary>
            <remarks>
            Set the number of objects considered when searching for a delta base.
            Default setting:
            <value>#DEFAULT_DELTA_SEARCH_WINDOW_SIZE</value>
            </remarks>
            <param name="objectCount">number of objects to search at once. Must be at least 2.
            	</param>
        </member>
        <member name="M:NGit.Storage.Pack.PackConfig.GetDeltaSearchMemoryLimit">
            <summary>Get maximum number of bytes to put into the delta search window.</summary>
            <remarks>
            Get maximum number of bytes to put into the delta search window.
            Default setting is 0, for an unlimited amount of memory usage. Actual
            memory used is the lower limit of either this setting, or the sum of
            space used by at most
            <see cref="M:NGit.Storage.Pack.PackConfig.GetDeltaSearchWindowSize">GetDeltaSearchWindowSize()</see>
            objects.
            This limit is per thread, if 4 threads are used the actual memory limit
            will be 4 times this value.
            </remarks>
            <returns>the memory limit.</returns>
        </member>
        <member name="M:NGit.Storage.Pack.PackConfig.SetDeltaSearchMemoryLimit(System.Int64)">
            <summary>Set the maximum number of bytes to put into the delta search window.</summary>
            <remarks>
            Set the maximum number of bytes to put into the delta search window.
            Default setting is 0, for an unlimited amount of memory usage. If the
            memory limit is reached before
            <see cref="M:NGit.Storage.Pack.PackConfig.GetDeltaSearchWindowSize">GetDeltaSearchWindowSize()</see>
            the
            window size is temporarily lowered.
            </remarks>
            <param name="memoryLimit">Maximum number of bytes to load at once, 0 for unlimited.
            	</param>
        </member>
        <member name="M:NGit.Storage.Pack.PackConfig.GetDeltaCacheSize">
            <summary>Get the size of the in-memory delta cache.</summary>
            <remarks>
            Get the size of the in-memory delta cache.
            This limit is for the entire writer, even if multiple threads are used.
            Default setting:
            <value>#DEFAULT_DELTA_CACHE_SIZE</value>
            </remarks>
            <returns>
            maximum number of bytes worth of delta data to cache in memory.
            If 0 the cache is infinite in size (up to the JVM heap limit
            anyway). A very tiny size such as 1 indicates the cache is
            effectively disabled.
            </returns>
        </member>
        <member name="M:NGit.Storage.Pack.PackConfig.SetDeltaCacheSize(System.Int64)">
            <summary>Set the maximum number of bytes of delta data to cache.</summary>
            <remarks>
            Set the maximum number of bytes of delta data to cache.
            During delta search, up to this many bytes worth of small or hard to
            compute deltas will be stored in memory. This cache speeds up writing by
            allowing the cached entry to simply be dumped to the output stream.
            Default setting:
            <value>#DEFAULT_DELTA_CACHE_SIZE</value>
            </remarks>
            <param name="size">
            number of bytes to cache. Set to 0 to enable an infinite
            cache, set to 1 (an impossible size for any delta) to disable
            the cache.
            </param>
        </member>
        <member name="M:NGit.Storage.Pack.PackConfig.GetDeltaCacheLimit">
            <summary>Maximum size in bytes of a delta to cache.</summary>
            <remarks>
            Maximum size in bytes of a delta to cache.
            Default setting:
            <value>#DEFAULT_DELTA_CACHE_LIMIT</value>
            </remarks>
            <returns>maximum size (in bytes) of a delta that should be cached.</returns>
        </member>
        <member name="M:NGit.Storage.Pack.PackConfig.SetDeltaCacheLimit(System.Int32)">
            <summary>Set the maximum size of a delta that should be cached.</summary>
            <remarks>
            Set the maximum size of a delta that should be cached.
            During delta search, any delta smaller than this size will be cached, up
            to the
            <see cref="M:NGit.Storage.Pack.PackConfig.GetDeltaCacheSize">GetDeltaCacheSize()</see>
            maximum limit. This speeds up writing
            by allowing these cached deltas to be output as-is.
            Default setting:
            <value>#DEFAULT_DELTA_CACHE_LIMIT</value>
            </remarks>
            <param name="size">maximum size (in bytes) of a delta to be cached.</param>
        </member>
        <member name="M:NGit.Storage.Pack.PackConfig.GetBigFileThreshold">
            <summary>Get the maximum file size that will be delta compressed.</summary>
            <remarks>
            Get the maximum file size that will be delta compressed.
            Files bigger than this setting will not be delta compressed, as they are
            more than likely already highly compressed binary data files that do not
            delta compress well, such as MPEG videos.
            Default setting:
            <value>#DEFAULT_BIG_FILE_THRESHOLD</value>
            </remarks>
            <returns>the configured big file threshold.</returns>
        </member>
        <member name="M:NGit.Storage.Pack.PackConfig.SetBigFileThreshold(System.Int32)">
            <summary>Set the maximum file size that should be considered for deltas.</summary>
            <remarks>
            Set the maximum file size that should be considered for deltas.
            Default setting:
            <value>#DEFAULT_BIG_FILE_THRESHOLD</value>
            </remarks>
            <param name="bigFileThreshold">the limit, in bytes.</param>
        </member>
        <member name="M:NGit.Storage.Pack.PackConfig.GetCompressionLevel">
            <summary>Get the compression level applied to objects in the pack.</summary>
            <remarks>
            Get the compression level applied to objects in the pack.
            Default setting:
            <value>java.util.zip.Deflater#DEFAULT_COMPRESSION</value>
            </remarks>
            <returns>
            current compression level, see
            <see cref="T:ICSharpCode.SharpZipLib.Zip.Compression.Deflater">ICSharpCode.SharpZipLib.Zip.Compression.Deflater
            	</see>
            .
            </returns>
        </member>
        <member name="M:NGit.Storage.Pack.PackConfig.SetCompressionLevel(System.Int32)">
            <summary>Set the compression level applied to objects in the pack.</summary>
            <remarks>
            Set the compression level applied to objects in the pack.
            Default setting:
            <value>java.util.zip.Deflater#DEFAULT_COMPRESSION</value>
            </remarks>
            <param name="level">
            compression level, must be a valid level recognized by the
            <see cref="T:ICSharpCode.SharpZipLib.Zip.Compression.Deflater">ICSharpCode.SharpZipLib.Zip.Compression.Deflater
            	</see>
            class.
            </param>
        </member>
        <member name="M:NGit.Storage.Pack.PackConfig.GetThreads">
            <summary>Get the number of threads used during delta compression.</summary>
            <remarks>
            Get the number of threads used during delta compression.
            Default setting: 0 (auto-detect processors)
            </remarks>
            <returns>
            number of threads used for delta compression. 0 will auto-detect
            the threads to the number of available processors.
            </returns>
        </member>
        <member name="M:NGit.Storage.Pack.PackConfig.SetThreads(System.Int32)">
            <summary>Set the number of threads to use for delta compression.</summary>
            <remarks>
            Set the number of threads to use for delta compression.
            During delta compression, if there are enough objects to be considered
            the writer will start up concurrent threads and allow them to compress
            different sections of the repository concurrently.
            An application thread pool can be set by
            <see cref="M:NGit.Storage.Pack.PackConfig.SetExecutor(Sharpen.Executor)">SetExecutor(Sharpen.Executor)</see>
            .
            If not set a temporary pool will be created by the writer, and torn down
            automatically when compression is over.
            Default setting: 0 (auto-detect processors)
            </remarks>
            <param name="threads">
            number of threads to use. If &lt;= 0 the number of available
            processors for this JVM is used.
            </param>
        </member>
        <member name="M:NGit.Storage.Pack.PackConfig.GetExecutor">
            <returns>the preferred thread pool to execute delta search on.</returns>
        </member>
        <member name="M:NGit.Storage.Pack.PackConfig.SetExecutor(Sharpen.Executor)">
            <summary>Set the executor to use when using threads.</summary>
            <remarks>
            Set the executor to use when using threads.
            During delta compression if the executor is non-null jobs will be queued
            up on it to perform delta compression in parallel. Aside from setting the
            executor, the caller must set
            <see cref="M:NGit.Storage.Pack.PackConfig.SetThreads(System.Int32)">SetThreads(int)</see>
            to enable threaded
            delta search.
            </remarks>
            <param name="executor">
            executor to use for threads. Set to null to create a temporary
            executor just for the writer.
            </param>
        </member>
        <member name="M:NGit.Storage.Pack.PackConfig.GetIndexVersion">
            <summary>Get the pack index file format version this instance creates.</summary>
            <remarks>
            Get the pack index file format version this instance creates.
            Default setting:
            <value>#DEFAULT_INDEX_VERSION</value>
            </remarks>
            <returns>
            the index version, the special version 0 designates the oldest
            (most compatible) format available for the objects.
            </returns>
            <seealso cref="T:NGit.Storage.File.PackIndexWriter">NGit.Storage.File.PackIndexWriter
            	</seealso>
        </member>
        <member name="M:NGit.Storage.Pack.PackConfig.SetIndexVersion(System.Int32)">
            <summary>Set the pack index file format version this instance will create.</summary>
            <remarks>
            Set the pack index file format version this instance will create.
            Default setting:
            <value>#DEFAULT_INDEX_VERSION</value>
            </remarks>
            <param name="version">
            the version to write. The special version 0 designates the
            oldest (most compatible) format available for the objects.
            </param>
            <seealso cref="T:NGit.Storage.File.PackIndexWriter">NGit.Storage.File.PackIndexWriter
            	</seealso>
        </member>
        <member name="M:NGit.Storage.Pack.PackConfig.FromConfig(NGit.Config)">
            <summary>Update properties by setting fields from the configuration.</summary>
            <remarks>
            Update properties by setting fields from the configuration.
            If a property's corresponding variable is not defined in the supplied
            configuration, then it is left unmodified.
            </remarks>
            <param name="rc">configuration to read properties from.</param>
        </member>
        <member name="T:NGit.Storage.File.PackIndexWriterV2">
            <summary>Creates the version 2 pack table of contents files.</summary>
            <remarks>Creates the version 2 pack table of contents files.</remarks>
            <seealso cref="T:NGit.Storage.File.PackIndexWriter">PackIndexWriter</seealso>
            <seealso cref="T:NGit.Storage.File.PackIndexV2">PackIndexV2</seealso>
        </member>
        <member name="M:NGit.Storage.File.PackIndexWriterV2.WriteImpl">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.PackIndexWriterV2.WriteObjectNames">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.PackIndexWriterV2.WriteCRCs">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.PackIndexWriterV2.WriteOffset32">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.PackIndexWriterV2.WriteOffset64">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Revwalk.RewriteTreeFilter" -->
        <member name="M:NGit.Revwalk.RewriteTreeFilter.Include(NGit.Revwalk.RevWalk,NGit.Revwalk.RevCommit)">
            <exception cref="T:NGit.Errors.StopWalkException"></exception>
            <exception cref="T:NGit.Errors.MissingObjectException"></exception>
            <exception cref="T:NGit.Errors.IncorrectObjectTypeException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Revwalk.RewriteTreeFilter.UpdateFollowFilter(NGit.ObjectId[])">
            <exception cref="T:NGit.Errors.MissingObjectException"></exception>
            <exception cref="T:NGit.Errors.IncorrectObjectTypeException"></exception>
            <exception cref="T:NGit.Errors.CorruptObjectException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Fnmatch.GroupHead.#ctor(System.String,System.String)">
            <exception cref="T:NGit.Errors.InvalidPatternException"></exception>
        </member>
        <member name="M:NGit.Fnmatch.GroupHead.CharacterPattern.Matches(System.Char)">
            <param name="c">the character to test</param>
            <returns>returns true if the character matches a pattern.</returns>
        </member>
        <member name="T:NGit.Errors.PackMismatchException">
            <summary>Thrown when a PackFile no longer matches the PackIndex.</summary>
            <remarks>Thrown when a PackFile no longer matches the PackIndex.</remarks>
        </member>
        <member name="M:NGit.Errors.PackMismatchException.#ctor(System.String)">
            <summary>Construct a pack modification error.</summary>
            <remarks>Construct a pack modification error.</remarks>
            <param name="why">description of the type of error.</param>
        </member>
        <member name="T:NGit.ThreadSafeProgressMonitor">
            <summary>
            Wrapper around the general
            <see cref="T:NGit.ProgressMonitor">ProgressMonitor</see>
            to make it thread safe.
            Updates to the underlying ProgressMonitor are made only from the thread that
            allocated this wrapper. Callers are responsible for ensuring the allocating
            thread uses
            <see cref="M:NGit.ThreadSafeProgressMonitor.PollForUpdates">PollForUpdates()</see>
            or
            <see cref="M:NGit.ThreadSafeProgressMonitor.WaitForCompletion">WaitForCompletion()</see>
            to
            update the underlying ProgressMonitor.
            Only
            <see cref="M:NGit.ThreadSafeProgressMonitor.Update(System.Int32)">Update(int)</see>
            ,
            <see cref="M:NGit.ThreadSafeProgressMonitor.IsCancelled">IsCancelled()</see>
            , and
            <see cref="M:NGit.ThreadSafeProgressMonitor.EndWorker">EndWorker()</see>
            may be invoked from a worker thread. All other methods of the ProgressMonitor
            interface can only be called from the thread that allocates this wrapper.
            </summary>
        </member>
        <member name="M:NGit.ThreadSafeProgressMonitor.#ctor(NGit.ProgressMonitor)">
            <summary>Wrap a ProgressMonitor to be thread safe.</summary>
            <remarks>Wrap a ProgressMonitor to be thread safe.</remarks>
            <param name="pm">the underlying monitor to receive events.</param>
        </member>
        <member name="M:NGit.ThreadSafeProgressMonitor.StartWorker">
            <summary>Notify the monitor a worker is starting.</summary>
            <remarks>Notify the monitor a worker is starting.</remarks>
        </member>
        <member name="M:NGit.ThreadSafeProgressMonitor.StartWorkers(System.Int32)">
            <summary>Notify the monitor of workers starting.</summary>
            <remarks>Notify the monitor of workers starting.</remarks>
            <param name="count">the number of worker threads that are starting.</param>
        </member>
        <member name="M:NGit.ThreadSafeProgressMonitor.EndWorker">
            <summary>Notify the monitor a worker is finished.</summary>
            <remarks>Notify the monitor a worker is finished.</remarks>
        </member>
        <member name="M:NGit.ThreadSafeProgressMonitor.PollForUpdates">
            <summary>Non-blocking poll for pending updates.</summary>
            <remarks>
            Non-blocking poll for pending updates.
            This method can only be invoked by the same thread that allocated this
            ThreadSafeProgressMonior.
            </remarks>
        </member>
        <member name="M:NGit.ThreadSafeProgressMonitor.WaitForCompletion">
            <summary>Process pending updates and wait for workers to finish.</summary>
            <remarks>
            Process pending updates and wait for workers to finish.
            This method can only be invoked by the same thread that allocated this
            ThreadSafeProgressMonior.
            </remarks>
            <exception cref="T:System.Exception">
            if the main thread is interrupted while waiting for
            completion of workers.
            </exception>
        </member>
        <member name="T:NGit.PersonIdent">
            <summary>A combination of a person identity and time in Git.</summary>
            <remarks>
            A combination of a person identity and time in Git.
            Git combines Name + email + time + time zone to specify who wrote or
            committed something.
            </remarks>
        </member>
        <member name="M:NGit.PersonIdent.#ctor(NGit.Repository)">
            <summary>Creates new PersonIdent from config info in repository, with current time.
            	</summary>
            <remarks>
            Creates new PersonIdent from config info in repository, with current time.
            This new PersonIdent gets the info from the default committer as available
            from the configuration.
            </remarks>
            <param name="repo"></param>
        </member>
        <member name="M:NGit.PersonIdent.#ctor(NGit.PersonIdent)">
            <summary>
            Copy a
            <see cref="T:NGit.PersonIdent">PersonIdent</see>
            .
            </summary>
            <param name="pi">
            Original
            <see cref="T:NGit.PersonIdent">PersonIdent</see>
            </param>
        </member>
        <member name="M:NGit.PersonIdent.#ctor(System.String,System.String)">
            <summary>
            Construct a new
            <see cref="T:NGit.PersonIdent">PersonIdent</see>
            with current time.
            </summary>
            <param name="aName"></param>
            <param name="aEmailAddress"></param>
        </member>
        <member name="M:NGit.PersonIdent.#ctor(NGit.PersonIdent,System.DateTime,System.TimeZoneInfo)">
            <summary>Copy a PersonIdent, but alter the clone's time stamp</summary>
            <param name="pi">
            original
            <see cref="T:NGit.PersonIdent">PersonIdent</see>
            </param>
            <param name="when">local time</param>
            <param name="tz">time zone</param>
        </member>
        <member name="M:NGit.PersonIdent.#ctor(NGit.PersonIdent,System.DateTime)">
            <summary>
            Copy a
            <see cref="T:NGit.PersonIdent">PersonIdent</see>
            , but alter the clone's time stamp
            </summary>
            <param name="pi">
            original
            <see cref="T:NGit.PersonIdent">PersonIdent</see>
            </param>
            <param name="aWhen">local time</param>
        </member>
        <member name="M:NGit.PersonIdent.#ctor(System.String,System.String,System.DateTime,System.TimeZoneInfo)">
            <summary>Construct a PersonIdent from simple data</summary>
            <param name="aName"></param>
            <param name="aEmailAddress"></param>
            <param name="aWhen">local time stamp</param>
            <param name="aTZ">time zone</param>
        </member>
        <member name="M:NGit.PersonIdent.#ctor(System.String,System.String,System.Int64,System.Int32)">
            <summary>
            Construct a
            <see cref="T:NGit.PersonIdent">PersonIdent</see>
            </summary>
            <param name="aName"></param>
            <param name="aEmailAddress"></param>
            <param name="aWhen">local time stamp</param>
            <param name="aTZ">time zone</param>
        </member>
        <member name="M:NGit.PersonIdent.#ctor(NGit.PersonIdent,System.Int64,System.Int32)">
            <summary>Copy a PersonIdent, but alter the clone's time stamp</summary>
            <param name="pi">
            original
            <see cref="T:NGit.PersonIdent">PersonIdent</see>
            </param>
            <param name="aWhen">local time stamp</param>
            <param name="aTZ">time zone</param>
        </member>
        <member name="M:NGit.PersonIdent.GetName">
            <returns>Name of person</returns>
        </member>
        <member name="M:NGit.PersonIdent.GetEmailAddress">
            <returns>email address of person</returns>
        </member>
        <member name="M:NGit.PersonIdent.GetWhen">
            <returns>timestamp</returns>
        </member>
        <member name="M:NGit.PersonIdent.GetTimeZone">
            <returns>this person's declared time zone; null if time zone is unknown.</returns>
        </member>
        <member name="M:NGit.PersonIdent.GetTimeZoneOffset">
            <returns>
            this person's declared time zone as minutes east of UTC. If the
            timezone is to the west of UTC it is negative.
            </returns>
        </member>
        <member name="M:NGit.PersonIdent.ToExternalString">
            <summary>Format for Git storage.</summary>
            <remarks>Format for Git storage.</remarks>
            <returns>a string in the git author format</returns>
        </member>
        <member name="T:NGit.Dircache.InvalidPathException">
            <summary>Thrown when JGit detects and refuses to use an invalid path</summary>
            <since>2.0</since>
        </member>
        <member name="M:NGit.Dircache.InvalidPathException.#ctor(System.String)">
            <param name="path"></param>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Transport.UploadPackLoggerChain" -->
        <!-- Badly formed XML comment ignored for member "T:NGit.Transport.UploadPackLogger" -->
        <member name="F:NGit.Transport.UploadPackLogger.NULL">
            <summary>A simple no-op logger.</summary>
            <remarks>A simple no-op logger.</remarks>
        </member>
        <member name="M:NGit.Transport.UploadPackLogger.OnPackStatistics(NGit.Storage.Pack.PackWriter.Statistics)">
            <summary>Notice to the logger after a pack has been sent.</summary>
            <remarks>Notice to the logger after a pack has been sent.</remarks>
            <param name="stats">the statistics after sending a pack to the client.</param>
        </member>
        <member name="M:NGit.Transport.UploadPackLoggerChain.NewChain``1(System.Collections.Generic.IList{``0})">
            <summary>Create a new logger chaining the given loggers together.</summary>
            <remarks>Create a new logger chaining the given loggers together.</remarks>
            <param name="loggers">loggers to execute, in order.</param>
            <returns>a new logger chain of the given loggers.</returns>
        </member>
        <member name="T:NGit.Api.BlameCommand">
            <summary>
            Blame command for building a
            <see cref="T:NGit.Blame.BlameResult">NGit.Blame.BlameResult</see>
            for a file path.
            </summary>
        </member>
        <member name="M:NGit.Api.BlameCommand.#ctor(NGit.Repository)">
            <param name="repo"></param>
        </member>
        <member name="M:NGit.Api.BlameCommand.SetFilePath(System.String)">
            <summary>Set file path</summary>
            <param name="filePath"></param>
            <returns>this command</returns>
        </member>
        <member name="M:NGit.Api.BlameCommand.SetDiffAlgorithm(NGit.Diff.DiffAlgorithm)">
            <summary>Set diff algorithm</summary>
            <param name="diffAlgorithm"></param>
            <returns>this command</returns>
        </member>
        <member name="M:NGit.Api.BlameCommand.SetTextComparator(NGit.Diff.RawTextComparator)">
            <summary>Set raw text comparator</summary>
            <param name="textComparator"></param>
            <returns>this command</returns>
        </member>
        <member name="M:NGit.Api.BlameCommand.SetStartCommit(NGit.AnyObjectId)">
            <summary>Set start commit id</summary>
            <param name="commit"></param>
            <returns>this command</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Api.BlameCommand.SetFollowFileRenames(System.Boolean)" -->
        <member name="M:NGit.Api.BlameCommand.Reverse(NGit.AnyObjectId,NGit.AnyObjectId)">
            <summary>Configure the command to compute reverse blame (history of deletes).</summary>
            <remarks>Configure the command to compute reverse blame (history of deletes).</remarks>
            <param name="start">
            oldest commit to traverse from. The result file will be loaded
            from this commit's tree.
            </param>
            <param name="end">
            most recent commit to stop traversal at. Usually an active
            branch tip, tag, or HEAD.
            </param>
            <returns>
            
            <code>this</code>
            </returns>
            <exception cref="T:System.IO.IOException">the repository cannot be read.</exception>
        </member>
        <member name="M:NGit.Api.BlameCommand.Reverse(NGit.AnyObjectId,System.Collections.Generic.ICollection{NGit.ObjectId})">
            <summary>Configure the generator to compute reverse blame (history of deletes).</summary>
            <remarks>Configure the generator to compute reverse blame (history of deletes).</remarks>
            <param name="start">
            oldest commit to traverse from. The result file will be loaded
            from this commit's tree.
            </param>
            <param name="end">
            most recent commits to stop traversal at. Usually an active
            branch tip, tag, or HEAD.
            </param>
            <returns>
            
            <code>this</code>
            </returns>
            <exception cref="T:System.IO.IOException">the repository cannot be read.</exception>
        </member>
        <member name="M:NGit.Api.BlameCommand.Call">
            <summary>
            Generate a list of lines with information about when the lines were
            introduced into the file path.
            </summary>
            <remarks>
            Generate a list of lines with information about when the lines were
            introduced into the file path.
            </remarks>
            <returns>list of lines</returns>
            <exception cref="T:NGit.Api.Errors.GitAPIException"></exception>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Api.RemoveNoteCommand" -->
        <member name="M:NGit.Api.RemoveNoteCommand.#ctor(NGit.Repository)">
            <param name="repo"></param>
        </member>
        <member name="M:NGit.Api.RemoveNoteCommand.Call">
            <exception cref="T:NGit.Api.Errors.GitAPIException"></exception>
        </member>
        <member name="M:NGit.Api.RemoveNoteCommand.SetObjectId(NGit.Revwalk.RevObject)">
            <summary>Sets the object id of object you want to remove a note</summary>
            <param name="id"></param>
            <returns>
            
            <code>this</code>
            </returns>
        </member>
        <member name="M:NGit.Api.RemoveNoteCommand.CommitNoteMap(NGit.Revwalk.RevWalk,NGit.Notes.NoteMap,NGit.Revwalk.RevCommit,NGit.ObjectInserter,System.String)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Api.RemoveNoteCommand.SetNotesRef(System.String)">
            <param name="notesRef">
            the ref to read notes from. Note, the default value of
            <see cref="F:NGit.Constants.R_NOTES_COMMITS">NGit.Constants.R_NOTES_COMMITS</see>
            will be used if nothing is
            set
            </param>
            <returns>
            
            <code>this</code>
            </returns>
            <seealso cref="F:NGit.Constants.R_NOTES_COMMITS">NGit.Constants.R_NOTES_COMMITS</seealso>
        </member>
        <member name="T:NGit.Notes.LeafBucket">
            <summary>A note tree holding only notes, with no subtrees.</summary>
            <remarks>
            A note tree holding only notes, with no subtrees.
            The leaf bucket contains on average less than 256 notes, all of whom share
            the same leading prefix. If a notes branch has less than 256 notes, the top
            level tree of the branch should be a LeafBucket. Once a notes branch has more
            than 256 notes, the root should be a
            <see cref="T:NGit.Notes.FanoutBucket">FanoutBucket</see>
            and the LeafBucket
            will appear only as a cell of a FanoutBucket.
            Entries within the LeafBucket are stored sorted by ObjectId, and lookup is
            performed using binary search. As the entry list should contain fewer than
            256 elements, the average number of compares to find an element should be
            less than 8 due to the O(log N) lookup behavior.
            A LeafBucket must be parsed from a tree object by
            <see cref="T:NGit.Notes.NoteParser">NoteParser</see>
            .
            </remarks>
        </member>
        <member name="F:NGit.Notes.LeafBucket.notes">
            <summary>All note blobs in this bucket, sorted sequentially.</summary>
            <remarks>All note blobs in this bucket, sorted sequentially.</remarks>
        </member>
        <member name="F:NGit.Notes.LeafBucket.cnt">
            <summary>
            Number of items in
            <see cref="F:NGit.Notes.LeafBucket.notes">notes</see>
            .
            </summary>
        </member>
        <member name="M:NGit.Notes.LeafBucket.EstimateSize(NGit.AnyObjectId,NGit.ObjectReader)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Notes.LeafBucket.Set(NGit.AnyObjectId,NGit.AnyObjectId,NGit.ObjectReader)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Notes.LeafBucket.WriteTree(NGit.ObjectInserter)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="T:NGit.Errors.UnpackException">
            <summary>Indicates a ReceivePack failure while scanning the pack stream.</summary>
            <remarks>Indicates a ReceivePack failure while scanning the pack stream.</remarks>
        </member>
        <member name="M:NGit.Errors.UnpackException.#ctor(System.Exception)">
            <summary>Creates an exception with a root cause.</summary>
            <remarks>Creates an exception with a root cause.</remarks>
            <param name="why">the root cause of the unpacking failure.</param>
        </member>
        <member name="M:NGit.Transport.TransportBundleFile.OpenFetch">
            <exception cref="T:System.NotSupportedException"></exception>
            <exception cref="T:NGit.Errors.TransportException"></exception>
        </member>
        <member name="M:NGit.Transport.TransportBundleFile.OpenPush">
            <exception cref="T:System.NotSupportedException"></exception>
        </member>
        <member name="M:NGit.Transport.TransportBundleFile._TransportProtocol_64.Open(NGit.Transport.URIish,NGit.Repository,System.String)">
            <exception cref="T:System.NotSupportedException"></exception>
            <exception cref="T:NGit.Errors.TransportException"></exception>
        </member>
        <member name="T:NGit.Util.StringUtils">
            <summary>Miscellaneous string comparison utility methods.</summary>
            <remarks>Miscellaneous string comparison utility methods.</remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Util.StringUtils.ToLowerCase(System.Char)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Util.StringUtils.ToLowerCase(System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Util.StringUtils.EqualsIgnoreCase(System.String,System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Util.StringUtils.CompareIgnoreCase(System.String,System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Util.StringUtils.CompareWithCase(System.String,System.String)" -->
        <member name="M:NGit.Util.StringUtils.ToBoolean(System.String)">
            <summary>Parse a string as a standard Git boolean value.</summary>
            <remarks>
            Parse a string as a standard Git boolean value. See
            <see cref="M:NGit.Util.StringUtils.ToBooleanOrNull(System.String)">ToBooleanOrNull(string)</see>
            .
            </remarks>
            <param name="stringValue">the string to parse.</param>
            <returns>
            the boolean interpretation of
            <code>value</code>
            .
            </returns>
            <exception cref="T:System.ArgumentException">
            if
            <code>value</code>
            is not recognized as one of the standard
            boolean names.
            </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Util.StringUtils.ToBooleanOrNull(System.String)" -->
        <member name="M:NGit.Util.StringUtils.Join(System.Collections.Generic.ICollection{System.String},System.String)">
            <summary>Join a collection of Strings together using the specified separator.</summary>
            <remarks>Join a collection of Strings together using the specified separator.</remarks>
            <param name="parts">Strings to join</param>
            <param name="separator">used to join</param>
            <returns>a String with all the joined parts</returns>
        </member>
        <member name="M:NGit.Util.StringUtils.Join(System.Collections.Generic.ICollection{System.String},System.String,System.String)">
            <summary>
            Join a collection of Strings together using the specified separator and a
            lastSeparator which is used for joining the second last and the last
            part.
            </summary>
            <remarks>
            Join a collection of Strings together using the specified separator and a
            lastSeparator which is used for joining the second last and the last
            part.
            </remarks>
            <param name="parts">Strings to join</param>
            <param name="separator">separator used to join all but the two last elements</param>
            <param name="lastSeparator">separator to use for joining the last two elements</param>
            <returns>a String with all the joined parts</returns>
        </member>
        <member name="M:NGit.Util.StringUtils.IsEmptyOrNull(System.String)">
            <summary>Test if a string is empty or null.</summary>
            <remarks>Test if a string is empty or null.</remarks>
            <param name="stringValue">the string to check</param>
            <returns><code>true</code> if the string is <code>null</code> or empty</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Storage.Pack.PackWriter" -->
        <member name="M:NGit.Storage.Pack.PackWriter.GetInstances">
            <returns>all allocated, non-released PackWriters instances.</returns>
        </member>
        <member name="F:NGit.Storage.Pack.PackWriter.reuseSupport">
            <summary>
            <see cref="F:NGit.Storage.Pack.PackWriter.reader">reader</see>
            recast to the reuse interface, if it supports it.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Storage.Pack.PackWriter.#ctor(NGit.Repository)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Storage.Pack.PackWriter.#ctor(NGit.ObjectReader)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Storage.Pack.PackWriter.#ctor(NGit.Repository,NGit.ObjectReader)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Storage.Pack.PackWriter.#ctor(NGit.Storage.Pack.PackConfig,NGit.ObjectReader)" -->
        <member name="M:NGit.Storage.Pack.PackWriter.IsDeltaBaseAsOffset">
            <summary>
            Check whether writer can store delta base as an offset (new style
            reducing pack size) or should store it as an object id (legacy style,
            compatible with old readers).
            </summary>
            <remarks>
            Check whether writer can store delta base as an offset (new style
            reducing pack size) or should store it as an object id (legacy style,
            compatible with old readers).
            Default setting:
            <value>PackConfig#DEFAULT_DELTA_BASE_AS_OFFSET</value>
            </remarks>
            <returns>
            true if delta base is stored as an offset; false if it is stored
            as an object id.
            </returns>
        </member>
        <member name="M:NGit.Storage.Pack.PackWriter.SetDeltaBaseAsOffset(System.Boolean)">
            <summary>Set writer delta base format.</summary>
            <remarks>
            Set writer delta base format. Delta base can be written as an offset in a
            pack file (new approach reducing file size) or as an object id (legacy
            approach, compatible with old readers).
            Default setting:
            <value>PackConfig#DEFAULT_DELTA_BASE_AS_OFFSET</value>
            </remarks>
            <param name="deltaBaseAsOffset">
            boolean indicating whether delta base can be stored as an
            offset.
            </param>
        </member>
        <member name="M:NGit.Storage.Pack.PackWriter.IsReuseDeltaCommits">
            <summary>Check if the writer will reuse commits that are already stored as deltas.
            	</summary>
            <remarks>Check if the writer will reuse commits that are already stored as deltas.
            	</remarks>
            <returns>
            true if the writer would reuse commits stored as deltas, assuming
            delta reuse is already enabled.
            </returns>
        </member>
        <member name="M:NGit.Storage.Pack.PackWriter.SetReuseDeltaCommits(System.Boolean)">
            <summary>Set the writer to reuse existing delta versions of commits.</summary>
            <remarks>Set the writer to reuse existing delta versions of commits.</remarks>
            <param name="reuse">
            if true, the writer will reuse any commits stored as deltas.
            By default the writer does not reuse delta commits.
            </param>
        </member>
        <member name="M:NGit.Storage.Pack.PackWriter.IsReuseValidatingObjects">
            <summary>Check if the writer validates objects before copying them.</summary>
            <remarks>Check if the writer validates objects before copying them.</remarks>
            <returns>
            true if validation is enabled; false if the reader will handle
            object validation as a side-effect of it consuming the output.
            </returns>
        </member>
        <member name="M:NGit.Storage.Pack.PackWriter.SetReuseValidatingObjects(System.Boolean)">
            <summary>Enable (or disable) object validation during packing.</summary>
            <remarks>Enable (or disable) object validation during packing.</remarks>
            <param name="validate">
            if true the pack writer will validate an object before it is
            put into the output. This additional validation work may be
            necessary to avoid propagating corruption from one local pack
            file to another local pack file.
            </param>
        </member>
        <member name="M:NGit.Storage.Pack.PackWriter.IsThin">
            <returns>true if this writer is producing a thin pack.</returns>
        </member>
        <member name="M:NGit.Storage.Pack.PackWriter.SetThin(System.Boolean)">
            <param name="packthin">
            a boolean indicating whether writer may pack objects with
            delta base object not within set of objects to pack, but
            belonging to party repository (uninteresting/boundary) as
            determined by set; this kind of pack is used only for
            transport; true - to produce thin pack, false - otherwise.
            </param>
        </member>
        <member name="M:NGit.Storage.Pack.PackWriter.IsUseCachedPacks">
            <returns>true to reuse cached packs. If true index creation isn't available.</returns>
        </member>
        <member name="M:NGit.Storage.Pack.PackWriter.SetUseCachedPacks(System.Boolean)">
            <param name="useCached">
            if set to true and a cached pack is present, it will be
            appended onto the end of a thin-pack, reducing the amount of
            working set space and CPU used by PackWriter. Enabling this
            feature prevents PackWriter from creating an index for the
            newly created pack, so its only suitable for writing to a
            network client, where the client will make the index.
            </param>
        </member>
        <member name="M:NGit.Storage.Pack.PackWriter.IsIgnoreMissingUninteresting">
            <returns>
            true to ignore objects that are uninteresting and also not found
            on local disk; false to throw a
            <see cref="T:NGit.Errors.MissingObjectException">NGit.Errors.MissingObjectException
            	</see>
            out of
            <see cref="!:PreparePack(NGit.ProgressMonitor, System.Collections.Generic.ICollection&lt;E&gt;, System.Collections.Generic.ICollection&lt;E&gt;)&#xA;            	">PreparePack(NGit.ProgressMonitor, System.Collections.Generic.ICollection&lt;E&gt;, System.Collections.Generic.ICollection&lt;E&gt;)
            	</see>
            if an
            uninteresting object is not in the source repository. By default,
            true, permitting gracefully ignoring of uninteresting objects.
            </returns>
        </member>
        <member name="M:NGit.Storage.Pack.PackWriter.SetIgnoreMissingUninteresting(System.Boolean)">
            <param name="ignore">
            true if writer should ignore non existing uninteresting
            objects during construction set of objects to pack; false
            otherwise - non existing uninteresting objects may cause
            <see cref="T:NGit.Errors.MissingObjectException">NGit.Errors.MissingObjectException
            	</see>
            </param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Storage.Pack.PackWriter.SetTagTargets(System.Collections.Generic.ICollection{NGit.ObjectId})" -->
        <member name="M:NGit.Storage.Pack.PackWriter.SetShallowPack(System.Int32,System.Collections.Generic.ICollection{NGit.ObjectId})">
            <summary>Configure this pack for a shallow clone.</summary>
            <remarks>Configure this pack for a shallow clone.</remarks>
            <param name="depth">maximum depth to traverse the commit graph</param>
            <param name="unshallow">
            objects which used to be shallow on the client, but are being
            extended as part of this fetch
            </param>
        </member>
        <member name="M:NGit.Storage.Pack.PackWriter.GetObjectCount">
            <summary>Returns objects number in a pack file that was created by this writer.</summary>
            <remarks>Returns objects number in a pack file that was created by this writer.</remarks>
            <returns>number of objects in pack.</returns>
            <exception cref="T:System.IO.IOException">a cached pack cannot supply its object count.
            	</exception>
        </member>
        <member name="M:NGit.Storage.Pack.PackWriter.ExcludeObjects(NGit.Storage.File.PackIndex)">
            <summary>Add a pack index whose contents should be excluded from the result.</summary>
            <remarks>Add a pack index whose contents should be excluded from the result.</remarks>
            <param name="idx">objects in this index will not be in the output pack.</param>
        </member>
        <member name="M:NGit.Storage.Pack.PackWriter.PreparePack(Sharpen.Iterator{NGit.Revwalk.RevObject})">
            <summary>Prepare the list of objects to be written to the pack stream.</summary>
            <remarks>
            Prepare the list of objects to be written to the pack stream.
            <p>
            Iterator <b>exactly</b> determines which objects are included in a pack
            and order they appear in pack (except that objects order by type is not
            needed at input). This order should conform general rules of ordering
            objects in git - by recency and path (type and delta-base first is
            internally secured) and responsibility for guaranteeing this order is on
            a caller side. Iterator must return each id of object to write exactly
            once.
            </p>
            </remarks>
            <param name="objectsSource">
            iterator of object to store in a pack; order of objects within
            each type is important, ordering by type is not needed;
            allowed types for objects are
            <see cref="F:NGit.Constants.OBJ_COMMIT">NGit.Constants.OBJ_COMMIT</see>
            ,
            <see cref="F:NGit.Constants.OBJ_TREE">NGit.Constants.OBJ_TREE</see>
            ,
            <see cref="F:NGit.Constants.OBJ_BLOB">NGit.Constants.OBJ_BLOB</see>
            and
            <see cref="F:NGit.Constants.OBJ_TAG">NGit.Constants.OBJ_TAG</see>
            ; objects returned by iterator may be
            later reused by caller as object id and type are internally
            copied in each iteration.
            </param>
            <exception cref="T:System.IO.IOException">when some I/O problem occur during reading objects.
            	</exception>
        </member>
        <member name="M:NGit.Storage.Pack.PackWriter.PreparePack``2(NGit.ProgressMonitor,System.Collections.Generic.ICollection{``0},System.Collections.Generic.ICollection{``1})">
            <summary>Prepare the list of objects to be written to the pack stream.</summary>
            <remarks>
            Prepare the list of objects to be written to the pack stream.
            <p>
            Basing on these 2 sets, another set of objects to put in a pack file is
            created: this set consists of all objects reachable (ancestors) from
            interesting objects, except uninteresting objects and their ancestors.
            This method uses class
            <see cref="T:NGit.Revwalk.ObjectWalk">NGit.Revwalk.ObjectWalk</see>
            extensively to find out that
            appropriate set of output objects and their optimal order in output pack.
            Order is consistent with general git in-pack rules: sort by object type,
            recency, path and delta-base first.
            </p>
            </remarks>
            <param name="countingMonitor">progress during object enumeration.</param>
            <param name="want">
            collection of objects to be marked as interesting (start
            points of graph traversal).
            </param>
            <param name="have">
            collection of objects to be marked as uninteresting (end
            points of graph traversal).
            </param>
            <exception cref="T:System.IO.IOException">when some I/O problem occur during reading objects.
            	</exception>
        </member>
        <member name="M:NGit.Storage.Pack.PackWriter.PreparePack``2(NGit.ProgressMonitor,NGit.Revwalk.ObjectWalk,System.Collections.Generic.ICollection{``0},System.Collections.Generic.ICollection{``1})">
            <summary>Prepare the list of objects to be written to the pack stream.</summary>
            <remarks>
            Prepare the list of objects to be written to the pack stream.
            <p>
            Basing on these 2 sets, another set of objects to put in a pack file is
            created: this set consists of all objects reachable (ancestors) from
            interesting objects, except uninteresting objects and their ancestors.
            This method uses class
            <see cref="T:NGit.Revwalk.ObjectWalk">NGit.Revwalk.ObjectWalk</see>
            extensively to find out that
            appropriate set of output objects and their optimal order in output pack.
            Order is consistent with general git in-pack rules: sort by object type,
            recency, path and delta-base first.
            </p>
            </remarks>
            <param name="countingMonitor">progress during object enumeration.</param>
            <param name="walk">ObjectWalk to perform enumeration.</param>
            <param name="interestingObjects">
            collection of objects to be marked as interesting (start
            points of graph traversal).
            </param>
            <param name="uninterestingObjects">
            collection of objects to be marked as uninteresting (end
            points of graph traversal).
            </param>
            <exception cref="T:System.IO.IOException">when some I/O problem occur during reading objects.
            	</exception>
        </member>
        <member name="M:NGit.Storage.Pack.PackWriter.WillInclude(NGit.ObjectId)">
            <summary>Determine if the pack file will contain the requested object.</summary>
            <remarks>Determine if the pack file will contain the requested object.</remarks>
            <param name="id">the object to test the existence of.</param>
            <returns>true if the object will appear in the output pack file.</returns>
            <exception cref="T:System.IO.IOException">a cached pack cannot be examined.</exception>
        </member>
        <member name="M:NGit.Storage.Pack.PackWriter.Get(NGit.AnyObjectId)">
            <summary>Lookup the ObjectToPack object for a given ObjectId.</summary>
            <remarks>Lookup the ObjectToPack object for a given ObjectId.</remarks>
            <param name="id">the object to find in the pack.</param>
            <returns>the object we are packing, or null.</returns>
        </member>
        <member name="M:NGit.Storage.Pack.PackWriter.ComputeName">
            <summary>
            Computes SHA-1 of lexicographically sorted objects ids written in this
            pack, as used to name a pack file in repository.
            </summary>
            <remarks>
            Computes SHA-1 of lexicographically sorted objects ids written in this
            pack, as used to name a pack file in repository.
            </remarks>
            <returns>ObjectId representing SHA-1 name of a pack that was created.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Storage.Pack.PackWriter.WriteIndex(Sharpen.OutputStream)" -->
        <member name="M:NGit.Storage.Pack.PackWriter.WritePack(NGit.ProgressMonitor,NGit.ProgressMonitor,Sharpen.OutputStream)">
            <summary>Write the prepared pack to the supplied stream.</summary>
            <remarks>
            Write the prepared pack to the supplied stream.
            <p>
            At first, this method collects and sorts objects to pack, then deltas
            search is performed if set up accordingly, finally pack stream is
            written.
            </p>
            <p>
            All reused objects data checksum (Adler32/CRC32) is computed and
            validated against existing checksum.
            </p>
            </remarks>
            <param name="compressMonitor">progress monitor to report object compression work.
            	</param>
            <param name="writeMonitor">progress monitor to report the number of objects written.
            	</param>
            <param name="packStream">
            output stream of pack data. The stream should be buffered by
            the caller. The caller is responsible for closing the stream.
            </param>
            <exception cref="T:System.IO.IOException">
            an error occurred reading a local object's data to include in
            the pack, or writing compressed object data to the output
            stream.
            </exception>
        </member>
        <member name="M:NGit.Storage.Pack.PackWriter.GetStatistics">
            <returns>
            description of what this PackWriter did in order to create the
            final pack stream. The object is only available to callers after
            <see cref="M:NGit.Storage.Pack.PackWriter.WritePack(NGit.ProgressMonitor,NGit.ProgressMonitor,Sharpen.OutputStream)">WritePack(NGit.ProgressMonitor, NGit.ProgressMonitor, Sharpen.OutputStream)</see>
            </returns>
        </member>
        <member name="M:NGit.Storage.Pack.PackWriter.GetState">
            <returns>snapshot of the current state of this PackWriter.</returns>
        </member>
        <member name="M:NGit.Storage.Pack.PackWriter.Release">
            <summary>Release all resources used by this writer.</summary>
            <remarks>Release all resources used by this writer.</remarks>
        </member>
        <member name="M:NGit.Storage.Pack.PackWriter.SearchForReuse(NGit.ProgressMonitor)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.Pack.PackWriter.SearchForReuse(NGit.ProgressMonitor,System.Collections.Generic.IList{NGit.Storage.Pack.ObjectToPack})">
            <exception cref="T:System.IO.IOException"></exception>
            <exception cref="T:NGit.Errors.MissingObjectException"></exception>
        </member>
        <member name="M:NGit.Storage.Pack.PackWriter.SearchForDeltas(NGit.ProgressMonitor)">
            <exception cref="T:NGit.Errors.MissingObjectException"></exception>
            <exception cref="T:NGit.Errors.IncorrectObjectTypeException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.Pack.PackWriter.SearchForDeltas(NGit.ProgressMonitor,NGit.Storage.Pack.ObjectToPack[],System.Int32)">
            <exception cref="T:NGit.Errors.MissingObjectException"></exception>
            <exception cref="T:NGit.Errors.IncorrectObjectTypeException"></exception>
            <exception cref="T:NGit.Errors.LargeObjectException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.Pack.PackWriter.RunTasks(Sharpen.ExecutorService,NGit.ThreadSafeProgressMonitor,System.Collections.Generic.IList{NGit.Storage.Pack.DeltaTask},System.Collections.Generic.IList{System.Exception})">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.Pack.PackWriter.WriteObjects(NGit.Storage.Pack.PackOutputStream)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.Pack.PackWriter.WriteObjects(NGit.Storage.Pack.PackOutputStream,System.Collections.Generic.IList{NGit.Storage.Pack.ObjectToPack})">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.Pack.PackWriter.WriteObject(NGit.Storage.Pack.PackOutputStream,NGit.Storage.Pack.ObjectToPack)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.Pack.PackWriter.WriteObjectImpl(NGit.Storage.Pack.PackOutputStream,NGit.Storage.Pack.ObjectToPack)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.Pack.PackWriter.WriteBase(NGit.Storage.Pack.PackOutputStream,NGit.Storage.Pack.ObjectToPack)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.Pack.PackWriter.WriteWholeObjectDeflate(NGit.Storage.Pack.PackOutputStream,NGit.Storage.Pack.ObjectToPack)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.Pack.PackWriter.WriteDeltaObjectDeflate(NGit.Storage.Pack.PackOutputStream,NGit.Storage.Pack.ObjectToPack)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.Pack.PackWriter.Delta(NGit.Storage.Pack.ObjectToPack)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.Pack.PackWriter.Buffer(NGit.AnyObjectId)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.Pack.PackWriter.Buffer(NGit.Storage.Pack.PackConfig,NGit.ObjectReader,NGit.AnyObjectId)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.Pack.PackWriter.WriteChecksum(NGit.Storage.Pack.PackOutputStream)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.Pack.PackWriter.FindObjectsToPack``2(NGit.ProgressMonitor,NGit.Revwalk.ObjectWalk,System.Collections.Generic.ICollection{``0},System.Collections.Generic.ICollection{``1})">
            <exception cref="T:NGit.Errors.MissingObjectException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
            <exception cref="T:NGit.Errors.IncorrectObjectTypeException"></exception>
        </member>
        <member name="M:NGit.Storage.Pack.PackWriter.UseCachedPack(NGit.Revwalk.ObjectWalk,NGit.Revwalk.RevFlagSet,System.Collections.Generic.IList{NGit.Revwalk.RevObject},System.Collections.Generic.IList{NGit.Revwalk.RevObject},NGit.Storage.Pack.CachedPack)">
            <exception cref="T:NGit.Errors.MissingObjectException"></exception>
            <exception cref="T:NGit.Errors.IncorrectObjectTypeException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Storage.Pack.PackWriter.AddObject(NGit.Revwalk.RevObject)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Storage.Pack.PackWriter.Select(NGit.Storage.Pack.ObjectToPack,NGit.Storage.Pack.StoredObjectRepresentation)" -->
        <member name="T:NGit.Storage.Pack.PackWriter.Statistics">
            <summary>Summary of how PackWriter created the pack.</summary>
            <remarks>Summary of how PackWriter created the pack.</remarks>
        </member>
        <member name="M:NGit.Storage.Pack.PackWriter.Statistics.GetInterestingObjects">
            <returns>
            unmodifiable collection of objects to be included in the
            pack. May be null if the pack was hand-crafted in a unit
            test.
            </returns>
        </member>
        <member name="M:NGit.Storage.Pack.PackWriter.Statistics.GetUninterestingObjects">
            <returns>
            unmodifiable collection of objects that should be excluded
            from the pack, as the peer that will receive the pack already
            has these objects.
            </returns>
        </member>
        <member name="M:NGit.Storage.Pack.PackWriter.Statistics.GetReusedPacks">
            <returns>
            unmodifiable collection of the cached packs that were reused
            in the output, if any were selected for reuse.
            </returns>
        </member>
        <member name="M:NGit.Storage.Pack.PackWriter.Statistics.GetDeltaSearchNonEdgeObjects">
            <returns>
            number of objects in the output pack that went through the
            delta search process in order to find a potential delta base.
            </returns>
        </member>
        <member name="M:NGit.Storage.Pack.PackWriter.Statistics.GetDeltasFound">
            <returns>
            number of objects in the output pack that went through delta
            base search and found a suitable base. This is a subset of
            <see cref="M:NGit.Storage.Pack.PackWriter.Statistics.GetDeltaSearchNonEdgeObjects">GetDeltaSearchNonEdgeObjects()</see>
            .
            </returns>
        </member>
        <member name="M:NGit.Storage.Pack.PackWriter.Statistics.GetTotalObjects">
            <returns>
            total number of objects output. This total includes the value
            of
            <see cref="M:NGit.Storage.Pack.PackWriter.Statistics.GetTotalDeltas">GetTotalDeltas()</see>
            .
            </returns>
        </member>
        <member name="M:NGit.Storage.Pack.PackWriter.Statistics.GetTotalDeltas">
            <returns>
            total number of deltas output. This may be lower than the
            actual number of deltas if a cached pack was reused.
            </returns>
        </member>
        <member name="M:NGit.Storage.Pack.PackWriter.Statistics.GetReusedObjects">
            <returns>
            number of objects whose existing representation was reused in
            the output. This count includes
            <see cref="M:NGit.Storage.Pack.PackWriter.Statistics.GetReusedDeltas">GetReusedDeltas()</see>
            .
            </returns>
        </member>
        <member name="M:NGit.Storage.Pack.PackWriter.Statistics.GetReusedDeltas">
            <returns>
            number of deltas whose existing representation was reused in
            the output, as their base object was also output or was
            assumed present for a thin pack. This may be lower than the
            actual number of reused deltas if a cached pack was reused.
            </returns>
        </member>
        <member name="M:NGit.Storage.Pack.PackWriter.Statistics.GetTotalBytes">
            <returns>
            total number of bytes written. This size includes the pack
            header, trailer, thin pack, and reused cached pack(s).
            </returns>
        </member>
        <member name="M:NGit.Storage.Pack.PackWriter.Statistics.GetThinPackBytes">
            <returns>
            size of the thin pack in bytes, if a thin pack was generated.
            A thin pack is created when the client already has objects
            and some deltas are created against those objects, or if a
            cached pack is being used and some deltas will reference
            objects in the cached pack. This size does not include the
            pack header or trailer.
            </returns>
        </member>
        <member name="M:NGit.Storage.Pack.PackWriter.Statistics.ByObjectType(System.Int32)">
            <param name="typeCode">object type code, e.g. OBJ_COMMIT or OBJ_TREE.</param>
            <returns>information about this type of object in the pack.</returns>
        </member>
        <member name="M:NGit.Storage.Pack.PackWriter.Statistics.IsShallow">
            <returns>true if the resulting pack file was a shallow pack.</returns>
        </member>
        <member name="M:NGit.Storage.Pack.PackWriter.Statistics.GetDepth">
            <returns>depth (in commits) the pack includes if shallow.</returns>
        </member>
        <member name="M:NGit.Storage.Pack.PackWriter.Statistics.GetTimeCounting">
            <returns>
            time in milliseconds spent enumerating the objects that need
            to be included in the output. This time includes any restarts
            that occur when a cached pack is selected for reuse.
            </returns>
        </member>
        <member name="M:NGit.Storage.Pack.PackWriter.Statistics.GetTimeSearchingForReuse">
            <returns>
            time in milliseconds spent matching existing representations
            against objects that will be transmitted, or that the client
            can be assumed to already have.
            </returns>
        </member>
        <member name="M:NGit.Storage.Pack.PackWriter.Statistics.GetTimeSearchingForSizes">
            <returns>
            time in milliseconds spent finding the sizes of all objects
            that will enter the delta compression search window. The
            sizes need to be known to better match similar objects
            together and improve delta compression ratios.
            </returns>
        </member>
        <member name="M:NGit.Storage.Pack.PackWriter.Statistics.GetTimeCompressing">
            <returns>
            time in milliseconds spent on delta compression. This is
            observed wall-clock time and does not accurately track CPU
            time used when multiple threads were used to perform the
            delta compression.
            </returns>
        </member>
        <member name="M:NGit.Storage.Pack.PackWriter.Statistics.GetTimeWriting">
            <returns>
            time in milliseconds spent writing the pack output, from
            start of header until end of trailer. The transfer speed can
            be approximated by dividing
            <see cref="M:NGit.Storage.Pack.PackWriter.Statistics.GetTotalBytes">GetTotalBytes()</see>
            by this
            value.
            </returns>
        </member>
        <member name="M:NGit.Storage.Pack.PackWriter.Statistics.GetTimeTotal">
            <returns>total time spent processing this pack.</returns>
        </member>
        <member name="M:NGit.Storage.Pack.PackWriter.Statistics.GetTransferRate">
            <returns>
            get the average output speed in terms of bytes-per-second.
            <code>getTotalBytes() / (getTimeWriting() / 1000.0)</code>
            .
            </returns>
        </member>
        <member name="M:NGit.Storage.Pack.PackWriter.Statistics.GetMessage">
            <returns>formatted message string for display to clients.</returns>
        </member>
        <member name="T:NGit.Storage.Pack.PackWriter.Statistics.ObjectType">
            <summary>Statistics about a single class of object.</summary>
            <remarks>Statistics about a single class of object.</remarks>
        </member>
        <member name="M:NGit.Storage.Pack.PackWriter.Statistics.ObjectType.GetObjects">
            <returns>
            total number of objects output. This total includes the
            value of
            <see cref="M:NGit.Storage.Pack.PackWriter.Statistics.ObjectType.GetDeltas">GetDeltas()</see>
            .
            </returns>
        </member>
        <member name="M:NGit.Storage.Pack.PackWriter.Statistics.ObjectType.GetDeltas">
            <returns>
            total number of deltas output. This may be lower than the
            actual number of deltas if a cached pack was reused.
            </returns>
        </member>
        <member name="M:NGit.Storage.Pack.PackWriter.Statistics.ObjectType.GetReusedObjects">
            <returns>
            number of objects whose existing representation was
            reused in the output. This count includes
            <see cref="M:NGit.Storage.Pack.PackWriter.Statistics.ObjectType.GetReusedDeltas">GetReusedDeltas()</see>
            .
            </returns>
        </member>
        <member name="M:NGit.Storage.Pack.PackWriter.Statistics.ObjectType.GetReusedDeltas">
            <returns>
            number of deltas whose existing representation was reused
            in the output, as their base object was also output or
            was assumed present for a thin pack. This may be lower
            than the actual number of reused deltas if a cached pack
            was reused.
            </returns>
        </member>
        <member name="M:NGit.Storage.Pack.PackWriter.Statistics.ObjectType.GetBytes">
            <returns>
            total number of bytes written. This size includes the
            object headers as well as the compressed data. This size
            also includes all of
            <see cref="M:NGit.Storage.Pack.PackWriter.Statistics.ObjectType.GetDeltaBytes">GetDeltaBytes()</see>
            .
            </returns>
        </member>
        <member name="M:NGit.Storage.Pack.PackWriter.Statistics.ObjectType.GetDeltaBytes">
            <returns>
            number of delta bytes written. This size includes the
            object headers for the delta objects.
            </returns>
        </member>
        <member name="F:NGit.Storage.Pack.PackWriter.MutableState.OBJECT_TO_PACK_SIZE">
            <summary>Estimated size of a single ObjectToPack instance.</summary>
            <remarks>Estimated size of a single ObjectToPack instance.</remarks>
        </member>
        <member name="T:NGit.Storage.Pack.PackWriter.PackingPhase">
            <summary>Possible states that a PackWriter can be in.</summary>
            <remarks>Possible states that a PackWriter can be in.</remarks>
        </member>
        <member name="T:NGit.Storage.Pack.PackWriter.State">
            <summary>Summary of the current state of a PackWriter.</summary>
            <remarks>Summary of the current state of a PackWriter.</remarks>
        </member>
        <member name="M:NGit.Storage.Pack.PackWriter.State.GetConfig">
            <returns>the PackConfig used to build the writer.</returns>
        </member>
        <member name="M:NGit.Storage.Pack.PackWriter.State.GetPhase">
            <returns>the current phase of the writer.</returns>
        </member>
        <member name="M:NGit.Storage.Pack.PackWriter.State.EstimateBytesUsed">
            <returns>an estimate of the total memory used by the writer.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Storage.Pack.ObjectReuseAsIs" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Storage.Pack.ObjectReuseAsIs.NewObjectToPack(NGit.Revwalk.RevObject)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Storage.Pack.ObjectReuseAsIs.SelectObjectRepresentation(NGit.Storage.Pack.PackWriter,NGit.ProgressMonitor,Sharpen.Iterable{NGit.Storage.Pack.ObjectToPack})" -->
        <member name="M:NGit.Storage.Pack.ObjectReuseAsIs.WriteObjects(NGit.Storage.Pack.PackOutputStream,System.Collections.Generic.IList{NGit.Storage.Pack.ObjectToPack})">
            <summary>Write objects to the pack stream in roughly the order given.</summary>
            <remarks>
            Write objects to the pack stream in roughly the order given.
            <code>PackWriter</code>
            invokes this method to write out one or more objects,
            in approximately the order specified by the iteration over the list. A
            simple implementation of this method would just iterate the list and
            output each object:
            <pre>
            for (ObjectToPack obj : list)
            out.writeObject(obj)
            </pre>
            However more sophisticated implementors may try to perform some (small)
            reordering to access objects that are stored close to each other at
            roughly the same time. Implementations may choose to write objects out of
            order, but this may increase pack file size due to using a larger header
            format to reach a delta base that is later in the stream. It may also
            reduce data locality for the reader, slowing down data access.
            Invoking
            <see cref="M:NGit.Storage.Pack.PackOutputStream.WriteObject(NGit.Storage.Pack.ObjectToPack)">PackOutputStream.WriteObject(ObjectToPack)
            	</see>
            will cause
            <see cref="M:NGit.Storage.Pack.ObjectReuseAsIs.CopyObjectAsIs(NGit.Storage.Pack.PackOutputStream,NGit.Storage.Pack.ObjectToPack,System.Boolean)">CopyObjectAsIs(PackOutputStream, ObjectToPack, bool)
            	</see>
            to be
            invoked recursively on
            <code>this</code>
            if the current object is scheduled
            for reuse.
            </remarks>
            <param name="out">the stream to write each object to.</param>
            <param name="list">
            the list of objects to write. Objects should be written in
            approximately this order. Implementors may resort the list
            elements in-place during writing if desired.
            </param>
            <exception cref="T:System.IO.IOException">
            the stream cannot be written to, or one or more required
            objects cannot be accessed from the object database.
            </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Storage.Pack.ObjectReuseAsIs.CopyObjectAsIs(NGit.Storage.Pack.PackOutputStream,NGit.Storage.Pack.ObjectToPack,System.Boolean)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Storage.Pack.ObjectReuseAsIs.GetCachedPacks" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Storage.Pack.ObjectReuseAsIs.CopyPackAsIs(NGit.Storage.Pack.PackOutputStream,NGit.Storage.Pack.CachedPack,System.Boolean)" -->
        <member name="T:NGit.Storage.File.WindowCursor">
            <summary>Active handle to a ByteWindow.</summary>
            <remarks>Active handle to a ByteWindow.</remarks>
        </member>
        <member name="F:NGit.Storage.File.WindowCursor.tempId">
            <summary>Temporary buffer large enough for at least one raw object id.</summary>
            <remarks>Temporary buffer large enough for at least one raw object id.</remarks>
        </member>
        <member name="M:NGit.Storage.File.WindowCursor.Resolve(NGit.AbbreviatedObjectId)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.WindowCursor.Has(NGit.AnyObjectId)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.WindowCursor.Open(NGit.AnyObjectId,System.Int32)">
            <exception cref="T:NGit.Errors.MissingObjectException"></exception>
            <exception cref="T:NGit.Errors.IncorrectObjectTypeException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.WindowCursor.GetObjectSize(NGit.AnyObjectId,System.Int32)">
            <exception cref="T:NGit.Errors.MissingObjectException"></exception>
            <exception cref="T:NGit.Errors.IncorrectObjectTypeException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.WindowCursor.SelectObjectRepresentation(NGit.Storage.Pack.PackWriter,NGit.ProgressMonitor,Sharpen.Iterable{NGit.Storage.Pack.ObjectToPack})">
            <exception cref="T:System.IO.IOException"></exception>
            <exception cref="T:NGit.Errors.MissingObjectException"></exception>
        </member>
        <member name="M:NGit.Storage.File.WindowCursor.CopyObjectAsIs(NGit.Storage.Pack.PackOutputStream,NGit.Storage.Pack.ObjectToPack,System.Boolean)">
            <exception cref="T:System.IO.IOException"></exception>
            <exception cref="T:NGit.Errors.StoredObjectRepresentationNotAvailableException"></exception>
        </member>
        <member name="M:NGit.Storage.File.WindowCursor.WriteObjects(NGit.Storage.Pack.PackOutputStream,System.Collections.Generic.IList{NGit.Storage.Pack.ObjectToPack})">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.WindowCursor.GetCachedPacks">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.WindowCursor.Copy(NGit.Storage.File.PackFile,System.Int64,System.Byte[],System.Int32,System.Int32)">
            <summary>Copy bytes from the window to a caller supplied buffer.</summary>
            <remarks>Copy bytes from the window to a caller supplied buffer.</remarks>
            <param name="pack">the file the desired window is stored within.</param>
            <param name="position">position within the file to read from.</param>
            <param name="dstbuf">destination buffer to copy into.</param>
            <param name="dstoff">offset within <code>dstbuf</code> to start copying into.</param>
            <param name="cnt">
            number of bytes to copy. This value may exceed the number of
            bytes remaining in the window starting at offset
            <code>pos</code>.
            </param>
            <returns>
            number of bytes actually copied; this may be less than
            <code>cnt</code> if <code>cnt</code> exceeded the number of bytes
            available.
            </returns>
            <exception cref="T:System.IO.IOException">
            this cursor does not match the provider or id and the proper
            window could not be acquired through the provider's cache.
            </exception>
        </member>
        <member name="M:NGit.Storage.File.WindowCursor.CopyPackAsIs(NGit.Storage.Pack.PackOutputStream,NGit.Storage.Pack.CachedPack,System.Boolean)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.WindowCursor.CopyPackAsIs(NGit.Storage.File.PackFile,System.Int64,System.Boolean,NGit.Storage.Pack.PackOutputStream)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.WindowCursor.Inflate(NGit.Storage.File.PackFile,System.Int64,System.Byte[],System.Int32)">
            <summary>
            Inflate a region of the pack starting at
            <code>position</code>
            .
            </summary>
            <param name="pack">the file the desired window is stored within.</param>
            <param name="position">position within the file to read from.</param>
            <param name="dstbuf">
            destination buffer the inflater should output decompressed
            data to.
            </param>
            <param name="dstoff">current offset within <code>dstbuf</code> to inflate into.</param>
            <returns>
            updated <code>dstoff</code> based on the number of bytes
            successfully inflated into <code>dstbuf</code>.
            </returns>
            <exception cref="T:System.IO.IOException">
            this cursor does not match the provider or id and the proper
            window could not be acquired through the provider's cache.
            </exception>
            <exception cref="T:ICSharpCode.SharpZipLib.SharpZipBaseException">
            the inflater encountered an invalid chunk of data. Data
            stream corruption is likely.
            </exception>
        </member>
        <member name="M:NGit.Storage.File.WindowCursor.QuickCopy(NGit.Storage.File.PackFile,System.Int64,System.Int64)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.WindowCursor.Pin(NGit.Storage.File.PackFile,System.Int64)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.WindowCursor.Release">
            <summary>Release the current window cursor.</summary>
            <remarks>Release the current window cursor.</remarks>
        </member>
        <member name="T:NGit.Storage.File.UnpackedObject">
            <summary>Loose object loader.</summary>
            <remarks>Loose object loader. This class loads an object not stored in a pack.</remarks>
        </member>
        <member name="M:NGit.Storage.File.UnpackedObject.Parse(System.Byte[],NGit.AnyObjectId)">
            <summary>Parse an object from the unpacked object format.</summary>
            <remarks>Parse an object from the unpacked object format.</remarks>
            <param name="raw">complete contents of the compressed object.</param>
            <param name="id">
            expected ObjectId of the object, used only for error reporting
            in exceptions.
            </param>
            <returns>loader to read the inflated contents.</returns>
            <exception cref="T:System.IO.IOException">the object cannot be parsed.</exception>
        </member>
        <member name="M:NGit.Storage.File.UnpackedObject.Open(Sharpen.InputStream,Sharpen.FilePath,NGit.AnyObjectId,NGit.Storage.File.WindowCursor)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.UnpackedObject.GetSize(Sharpen.InputStream,NGit.AnyObjectId,NGit.Storage.File.WindowCursor)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.UnpackedObject.CheckValidEndOfStream(Sharpen.InputStream,ICSharpCode.SharpZipLib.Zip.Compression.Inflater,NGit.AnyObjectId,System.Byte[])">
            <exception cref="T:System.IO.IOException"></exception>
            <exception cref="T:NGit.Errors.CorruptObjectException"></exception>
        </member>
        <member name="M:NGit.Storage.File.UnpackedObject.ReadSome(Sharpen.InputStream,System.Byte[],System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.UnpackedObject._InflaterInputStream_307.Read(System.Byte[],System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.UnpackedObject._InflaterInputStream_307.Close">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.UnpackedObject.LargeObject.GetCachedBytes">
            <exception cref="T:NGit.Errors.LargeObjectException"></exception>
        </member>
        <member name="M:NGit.Storage.File.UnpackedObject.LargeObject.OpenStream">
            <exception cref="T:NGit.Errors.MissingObjectException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="T:NGit.Storage.File.RefDirectoryUpdate">
            <summary>
            Updates any reference stored by
            <see cref="T:NGit.Storage.File.RefDirectory">RefDirectory</see>
            .
            </summary>
        </member>
        <member name="M:NGit.Storage.File.RefDirectoryUpdate.TryLock(System.Boolean)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.RefDirectoryUpdate.DoUpdate(NGit.RefUpdate.Result)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.RefDirectoryUpdate.DoDelete(NGit.RefUpdate.Result)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.RefDirectoryUpdate.DoLink(System.String)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="T:NGit.Storage.File.PackIndexWriterV1">
            <summary>Creates the version 1 (old style) pack table of contents files.</summary>
            <remarks>Creates the version 1 (old style) pack table of contents files.</remarks>
            <seealso cref="T:NGit.Storage.File.PackIndexWriter">PackIndexWriter</seealso>
            <seealso cref="T:NGit.Storage.File.PackIndexV1">PackIndexV1</seealso>
        </member>
        <member name="M:NGit.Storage.File.PackIndexWriterV1.WriteImpl">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Storage.File.FileRepository" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Storage.File.FileRepository.#ctor(Sharpen.FilePath)" -->
        <member name="M:NGit.Storage.File.FileRepository.#ctor(System.String)">
            <summary>
            A convenience API for
            <see cref="M:NGit.Storage.File.FileRepository.#ctor(Sharpen.FilePath)">FileRepository(Sharpen.FilePath)</see>
            .
            </summary>
            <param name="gitDir">GIT_DIR (the location of the repository metadata).</param>
            <exception cref="T:System.IO.IOException">
            the repository appears to already exist but cannot be
            accessed.
            </exception>
            <seealso cref="T:NGit.Storage.File.FileRepositoryBuilder">FileRepositoryBuilder</seealso>
        </member>
        <member name="M:NGit.Storage.File.FileRepository.#ctor(NGit.BaseRepositoryBuilder)">
            <summary>Create a repository using the local file system.</summary>
            <remarks>Create a repository using the local file system.</remarks>
            <param name="options">description of the repository's important paths.</param>
            <exception cref="T:System.IO.IOException">
            the user configuration file or repository configuration file
            cannot be accessed.
            </exception>
        </member>
        <member name="M:NGit.Storage.File.FileRepository.LoadSystemConfig">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.FileRepository.LoadUserConfig">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.FileRepository.LoadRepoConfig">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.FileRepository.Create(System.Boolean)">
            <summary>
            Create a new Git repository initializing the necessary files and
            directories.
            </summary>
            <remarks>
            Create a new Git repository initializing the necessary files and
            directories.
            </remarks>
            <param name="bare">if true, a bare repository is created.</param>
            <exception cref="T:System.IO.IOException">in case of IO problem</exception>
        </member>
        <member name="M:NGit.Storage.File.FileRepository.GetConfig">
            <returns>the configuration of this repository</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Storage.File.FileRepository.GetAdditionalHaves" -->
        <member name="M:NGit.Storage.File.FileRepository.OpenPack(Sharpen.FilePath,Sharpen.FilePath)">
            <summary>Add a single existing pack to the list of available pack files.</summary>
            <remarks>Add a single existing pack to the list of available pack files.</remarks>
            <param name="pack">path of the pack file to open.</param>
            <param name="idx">path of the corresponding index file.</param>
            <exception cref="T:System.IO.IOException">
            index file could not be opened, read, or is not recognized as
            a Git pack file index.
            </exception>
        </member>
        <member name="M:NGit.Storage.File.FileRepository.ScanForRepoChanges">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.FileRepository.DetectIndexChanges">
            <summary>Detect index changes.</summary>
            <remarks>Detect index changes.</remarks>
        </member>
        <member name="M:NGit.Storage.File.FileRepository.GetReflogReader(System.String)">
            <param name="refName"></param>
            <returns>
            a
            <see cref="T:NGit.Storage.File.ReflogReader">ReflogReader</see>
            for the supplied refname, or null if the
            named ref does not exist.
            </returns>
            <exception cref="T:System.IO.IOException">the ref could not be accessed.</exception>
        </member>
        <member name="P:NGit.Storage.File.FileRepository.ObjectsDirectory">
            <returns>the directory containing the objects owned by this repository.</returns>
        </member>
        <member name="P:NGit.Storage.File.FileRepository.ObjectDatabase">
            <returns>the object database which stores this repository's data.</returns>
        </member>
        <member name="P:NGit.Storage.File.FileRepository.RefDatabase">
            <returns>the reference database which stores the reference namespace.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Revwalk.Filter.OrRevFilter" -->
        <member name="M:NGit.Revwalk.Filter.OrRevFilter.Create(NGit.Revwalk.Filter.RevFilter,NGit.Revwalk.Filter.RevFilter)">
            <summary>Create a filter with two filters, one of which must match.</summary>
            <remarks>Create a filter with two filters, one of which must match.</remarks>
            <param name="a">first filter to test.</param>
            <param name="b">second filter to test.</param>
            <returns>a filter that must match at least one input filter.</returns>
        </member>
        <member name="M:NGit.Revwalk.Filter.OrRevFilter.Create(NGit.Revwalk.Filter.RevFilter[])">
            <summary>Create a filter around many filters, one of which must match.</summary>
            <remarks>Create a filter around many filters, one of which must match.</remarks>
            <param name="list">
            list of filters to match against. Must contain at least 2
            filters.
            </param>
            <returns>a filter that must match at least one input filter.</returns>
        </member>
        <member name="M:NGit.Revwalk.Filter.OrRevFilter.Create(System.Collections.Generic.ICollection{NGit.Revwalk.Filter.RevFilter})">
            <summary>Create a filter around many filters, one of which must match.</summary>
            <remarks>Create a filter around many filters, one of which must match.</remarks>
            <param name="list">
            list of filters to match against. Must contain at least 2
            filters.
            </param>
            <returns>a filter that must match at least one input filter.</returns>
        </member>
        <member name="M:NGit.Revwalk.Filter.OrRevFilter.Binary.Include(NGit.Revwalk.RevWalk,NGit.Revwalk.RevCommit)">
            <exception cref="T:NGit.Errors.MissingObjectException"></exception>
            <exception cref="T:NGit.Errors.IncorrectObjectTypeException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Revwalk.Filter.OrRevFilter.List.Include(NGit.Revwalk.RevWalk,NGit.Revwalk.RevCommit)">
            <exception cref="T:NGit.Errors.MissingObjectException"></exception>
            <exception cref="T:NGit.Errors.IncorrectObjectTypeException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="T:NGit.Revwalk.Filter.MessageRevFilter">
            <summary>Matches only commits whose message matches the pattern.</summary>
            <remarks>Matches only commits whose message matches the pattern.</remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Revwalk.Filter.MessageRevFilter.Create(System.String)" -->
        <!-- Badly formed XML comment ignored for member "T:NGit.Revwalk.FixUninterestingGenerator" -->
        <member name="M:NGit.Revwalk.FixUninterestingGenerator.Next">
            <exception cref="T:NGit.Errors.MissingObjectException"></exception>
            <exception cref="T:NGit.Errors.IncorrectObjectTypeException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Nls.NLS" -->
        <member name="F:NGit.Nls.NLS.ROOT_LOCALE">
            <summary>The root locale constant.</summary>
            <remarks>The root locale constant. It is defined here because the Locale.ROOT is not defined in Java 5
            	</remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Nls.NLS.SetLocale(System.Globalization.CultureInfo)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Nls.NLS.UseJVMDefaultLocale" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Nls.NLS.GetBundleFor``1" -->
        <member name="T:NGit.Merge.MergeFormatter">
            <summary>A class to convert merge results into a Git conformant textual presentation
            	</summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Merge.MergeFormatter.FormatMerge(Sharpen.OutputStream,NGit.Merge.MergeResult{NGit.Diff.RawText},System.Collections.Generic.IList{System.String},System.String)" -->
        <member name="M:NGit.Merge.MergeFormatter.FormatMerge(Sharpen.OutputStream,NGit.Merge.MergeResult{NGit.Diff.RawText},System.String,System.String,System.String,System.String)">
            <summary>
            Formats the results of a merge of exactly two
            <see cref="T:NGit.Diff.RawText">NGit.Diff.RawText</see>
            objects in
            a Git conformant way. This convenience method accepts the names for the
            three sequences (base and the two merged sequences) as explicit
            parameters and doesn't require the caller to specify a List
            </summary>
            <param name="out">
            the
            <see cref="T:Sharpen.OutputStream">Sharpen.OutputStream</see>
            where to write the textual
            presentation
            </param>
            <param name="res">the merge result which should be presented</param>
            <param name="baseName">the name ranges from the base should get</param>
            <param name="oursName">the name ranges from ours should get</param>
            <param name="theirsName">the name ranges from theirs should get</param>
            <param name="charsetName">
            the name of the characterSet used when writing conflict
            metadata
            </param>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="T:NGit.Merge.MergeAlgorithm">
            <summary>
            Provides the merge algorithm which does a three-way merge on content provided
            as RawText.
            </summary>
            <remarks>
            Provides the merge algorithm which does a three-way merge on content provided
            as RawText. By default
            <see cref="T:NGit.Diff.HistogramDiff">NGit.Diff.HistogramDiff</see>
            is used as diff algorithm.
            </remarks>
        </member>
        <member name="M:NGit.Merge.MergeAlgorithm.#ctor">
            <summary>
            Creates a new MergeAlgorithm which uses
            <see cref="T:NGit.Diff.HistogramDiff">NGit.Diff.HistogramDiff</see>
            as diff
            algorithm
            </summary>
        </member>
        <member name="M:NGit.Merge.MergeAlgorithm.#ctor(NGit.Diff.DiffAlgorithm)">
            <summary>Creates a new MergeAlgorithm</summary>
            <param name="diff">the diff algorithm used by this merge</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Merge.MergeAlgorithm.Merge``1(NGit.Diff.SequenceComparator{``0},``0,``0,``0)" -->
        <member name="M:NGit.Merge.MergeAlgorithm.NextEdit(Sharpen.Iterator{NGit.Diff.Edit})">
            <summary>Helper method which returns the next Edit for an Iterator over Edits.</summary>
            <remarks>
            Helper method which returns the next Edit for an Iterator over Edits.
            When there are no more edits left this method will return the constant
            END_EDIT.
            </remarks>
            <param name="it">the iterator for which the next edit should be returned</param>
            <returns>
            the next edit from the iterator or END_EDIT if there no more
            edits
            </returns>
        </member>
        <member name="T:NGit.Errors.TranslationStringMissingException">
            <summary>
            This exception will be thrown when a translation string for a translation
            bundle and locale is missing.
            </summary>
            <remarks>
            This exception will be thrown when a translation string for a translation
            bundle and locale is missing.
            </remarks>
        </member>
        <member name="M:NGit.Errors.TranslationStringMissingException.#ctor(System.Type,System.Globalization.CultureInfo,System.String,System.Exception)">
            <summary>
            Construct a
            <see cref="T:NGit.Errors.TranslationStringMissingException">TranslationStringMissingException</see>
            for the specified
            bundle class, locale and translation key
            </summary>
            <param name="bundleClass">the bundle class for which a translation string was missing
            	</param>
            <param name="locale">the locale for which a translation string was missing</param>
            <param name="key">the key of the missing translation string</param>
            <param name="cause">
            the original exception thrown from the
            <see cref="M:Sharpen.ResourceBundle.GetString(System.String)">Sharpen.ResourceBundle.GetString(string)
            	</see>
            method.
            </param>
        </member>
        <member name="M:NGit.Errors.TranslationStringMissingException.GetKey">
            <returns>the key of the missing translation string</returns>
        </member>
        <member name="T:NGit.Errors.StoredObjectRepresentationNotAvailableException">
            <summary>A previously selected representation is no longer available.</summary>
            <remarks>A previously selected representation is no longer available.</remarks>
        </member>
        <member name="M:NGit.Errors.StoredObjectRepresentationNotAvailableException.#ctor(NGit.Storage.Pack.ObjectToPack)">
            <summary>Construct an error for an object.</summary>
            <remarks>Construct an error for an object.</remarks>
            <param name="otp">the object whose current representation is no longer present.</param>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Errors.RevWalkException" -->
        <member name="M:NGit.Errors.RevWalkException.#ctor(System.Exception)">
            <summary>Create a new walk exception an original cause.</summary>
            <remarks>Create a new walk exception an original cause.</remarks>
            <param name="cause">the checked exception that describes why the walk failed.</param>
        </member>
        <member name="T:NGit.Errors.InvalidObjectIdException">
            <summary>Thrown when an invalid object id is passed in as an argument.</summary>
            <remarks>Thrown when an invalid object id is passed in as an argument.</remarks>
        </member>
        <member name="M:NGit.Errors.InvalidObjectIdException.#ctor(System.Byte[],System.Int32,System.Int32)">
            <summary>Create exception with bytes of the invalid object id.</summary>
            <remarks>Create exception with bytes of the invalid object id.</remarks>
            <param name="bytes">containing the invalid id.</param>
            <param name="offset">in the byte array where the error occurred.</param>
            <param name="length">of the sequence of invalid bytes.</param>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Diff.RawText" -->
        <member name="F:NGit.Diff.RawText.FIRST_FEW_BYTES">
            <summary>
            Number of bytes to check for heuristics in
            <see cref="M:NGit.Diff.RawText.IsBinary(System.Byte[])">IsBinary(byte[])</see>
            
            </summary>
        </member>
        <member name="F:NGit.Diff.RawText.EMPTY_TEXT">
            <summary>A Rawtext of length 0</summary>
        </member>
        <member name="F:NGit.Diff.RawText.content">
            <summary>The file content for this sequence.</summary>
            <remarks>The file content for this sequence.</remarks>
        </member>
        <member name="F:NGit.Diff.RawText.lines">
            <summary>
            Map of line number to starting position within
            <see cref="F:NGit.Diff.RawText.content">content</see>
            .
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Diff.RawText.#ctor(System.Byte[])" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Diff.RawText.#ctor(Sharpen.FilePath)" -->
        <member name="M:NGit.Diff.RawText.Size">
            <returns>total number of items in the sequence.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Diff.RawText.WriteLine(Sharpen.OutputStream,System.Int32)" -->
        <member name="M:NGit.Diff.RawText.IsMissingNewlineAtEnd">
            <summary>Determine if the file ends with a LF ('\n').</summary>
            <remarks>Determine if the file ends with a LF ('\n').</remarks>
            <returns>true if the last line has an LF; false otherwise.</returns>
        </member>
        <member name="M:NGit.Diff.RawText.GetString(System.Int32)">
            <summary>Get the text for a single line.</summary>
            <remarks>Get the text for a single line.</remarks>
            <param name="i">
            index of the line to extract. Note this is 0-based, so line
            number 1 is actually index 0.
            </param>
            <returns>the text for the line, without a trailing LF.</returns>
        </member>
        <member name="M:NGit.Diff.RawText.GetString(System.Int32,System.Int32,System.Boolean)">
            <summary>Get the text for a region of lines.</summary>
            <remarks>Get the text for a region of lines.</remarks>
            <param name="begin">
            index of the first line to extract. Note this is 0-based, so
            line number 1 is actually index 0.
            </param>
            <param name="end">index of one past the last line to extract.</param>
            <param name="dropLF">
            if true the trailing LF ('\n') of the last returned line is
            dropped, if present.
            </param>
            <returns>
            the text for lines
            <code>[begin, end)</code>
            .
            </returns>
        </member>
        <member name="M:NGit.Diff.RawText.Decode(System.Int32,System.Int32)">
            <summary>Decode a region of the text into a String.</summary>
            <remarks>
            Decode a region of the text into a String.
            The default implementation of this method tries to guess the character
            set by considering UTF-8, the platform default, and falling back on
            ISO-8859-1 if neither of those can correctly decode the region given.
            </remarks>
            <param name="start">first byte of the content to decode.</param>
            <param name="end">one past the last byte of the content to decode.</param>
            <returns>
            the region
            <code>[start, end)</code>
            decoded as a String.
            </returns>
        </member>
        <member name="M:NGit.Diff.RawText.IsBinary(System.Byte[])">
            <summary>
            Determine heuristically whether a byte array represents binary (as
            opposed to text) content.
            </summary>
            <remarks>
            Determine heuristically whether a byte array represents binary (as
            opposed to text) content.
            </remarks>
            <param name="raw">the raw file content.</param>
            <returns>true if raw is likely to be a binary file, false otherwise</returns>
        </member>
        <member name="M:NGit.Diff.RawText.IsBinary(Sharpen.InputStream)">
            <summary>
            Determine heuristically whether the bytes contained in a stream
            represents binary (as opposed to text) content.
            </summary>
            <remarks>
            Determine heuristically whether the bytes contained in a stream
            represents binary (as opposed to text) content.
            Note: Do not further use this stream after having called this method! The
            stream may not be fully read and will be left at an unknown position
            after consuming an unknown number of bytes. The caller is responsible for
            closing the stream.
            </remarks>
            <param name="raw">input stream containing the raw file content.</param>
            <returns>true if raw is likely to be a binary file, false otherwise</returns>
            <exception cref="T:System.IO.IOException">if input stream could not be read</exception>
        </member>
        <member name="M:NGit.Diff.RawText.IsBinary(System.Byte[],System.Int32)">
            <summary>
            Determine heuristically whether a byte array represents binary (as
            opposed to text) content.
            </summary>
            <remarks>
            Determine heuristically whether a byte array represents binary (as
            opposed to text) content.
            </remarks>
            <param name="raw">the raw file content.</param>
            <param name="length">
            number of bytes in
            <code>raw</code>
            to evaluate. This should be
            <code>raw.length</code>
            unless
            <code>raw</code>
            was over-allocated by
            the caller.
            </param>
            <returns>true if raw is likely to be a binary file, false otherwise</returns>
        </member>
        <member name="M:NGit.Diff.RawText.GetLineDelimiter">
            <summary>Get the line delimiter for the first line.</summary>
            <remarks>Get the line delimiter for the first line.</remarks>
            <since>2.0</since>
            <returns>the line delimiter or <code>null</code></returns>
        </member>
        <member name="T:NGit.Api.Errors.NoMessageException">
            <summary>
            Exception thrown when the options given to a command don't include a
            specification of a message text (e.g.
            </summary>
            <remarks>
            Exception thrown when the options given to a command don't include a
            specification of a message text (e.g. a commit was called without explicitly
            specifying a commit message (or other options telling where to take the
            message from.
            </remarks>
        </member>
        <member name="M:NGit.Api.Errors.NoMessageException.#ctor(System.String,System.Exception)">
            <param name="message"></param>
            <param name="cause"></param>
        </member>
        <member name="M:NGit.Api.Errors.NoMessageException.#ctor(System.String)">
            <param name="message"></param>
        </member>
        <member name="T:NGit.Api.Errors.ConcurrentRefUpdateException">
            <summary>
            Exception thrown when a command wants to update a ref but failed because
            another process is accessing (or even also updating) the ref.
            </summary>
            <remarks>
            Exception thrown when a command wants to update a ref but failed because
            another process is accessing (or even also updating) the ref.
            </remarks>
            <seealso cref="F:NGit.RefUpdate.Result.LOCK_FAILURE">NGit.RefUpdate.Result.LOCK_FAILURE
            	</seealso>
        </member>
        <member name="M:NGit.Api.Errors.ConcurrentRefUpdateException.#ctor(System.String,NGit.Ref,NGit.RefUpdate.Result,System.Exception)">
            <param name="message"></param>
            <param name="ref"></param>
            <param name="rc"></param>
            <param name="cause"></param>
        </member>
        <member name="M:NGit.Api.Errors.ConcurrentRefUpdateException.#ctor(System.String,NGit.Ref,NGit.RefUpdate.Result)">
            <param name="message"></param>
            <param name="ref"></param>
            <param name="rc"></param>
        </member>
        <member name="M:NGit.Api.Errors.ConcurrentRefUpdateException.GetRef">
            <returns>
            the
            <see cref="T:NGit.Ref">NGit.Ref</see>
            which was tried to by updated
            </returns>
        </member>
        <member name="M:NGit.Api.Errors.ConcurrentRefUpdateException.GetResult">
            <returns>
            the result which was returned by
            <see cref="M:NGit.RefUpdate.Update">NGit.RefUpdate.Update()</see>
            and
            which caused this error
            </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Api.Git" -->
        <member name="F:NGit.Api.Git.repo">
            <summary>The git repository this class is interacting with</summary>
        </member>
        <member name="M:NGit.Api.Git.Open(Sharpen.FilePath)">
            <param name="dir">
            the repository to open. May be either the GIT_DIR, or the
            working tree directory that contains
            <code>.git</code>
            .
            </param>
            <returns>
            a
            <see cref="T:NGit.Api.Git">Git</see>
            object for the existing git repository
            </returns>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:NGit.Api.Git.Open(Sharpen.FilePath,NGit.Util.FS)">
            <param name="dir">
            the repository to open. May be either the GIT_DIR, or the
            working tree directory that contains
            <code>.git</code>
            .
            </param>
            <param name="fs">filesystem abstraction to use when accessing the repository.</param>
            <returns>
            a
            <see cref="T:NGit.Api.Git">Git</see>
            object for the existing git repository
            </returns>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:NGit.Api.Git.Wrap(NGit.Repository)">
            <param name="repo">
            the git repository this class is interacting with.
            <code>null</code>
            is not allowed
            </param>
            <returns>
            a
            <see cref="T:NGit.Api.Git">Git</see>
            object for the existing git repository
            </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Api.Git.CloneRepository" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Api.Git.Init" -->
        <member name="M:NGit.Api.Git.#ctor(NGit.Repository)">
            <summary>
            Constructs a new
            <see cref="T:NGit.Api.Git">Git</see>
            object which can interact with the specified
            git repository. All command classes returned by methods of this class
            will always interact with this git repository.
            </summary>
            <param name="repo">
            the git repository this class is interacting with.
            <code>null</code>
            is not allowed
            </param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Api.Git.Commit" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Api.Git.Log" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Api.Git.Merge" -->
        <member name="M:NGit.Api.Git.Pull">
            <summary>
            Returns a command object to execute a
            <code>Pull</code>
            command
            </summary>
            <returns>
            a
            <see cref="T:NGit.Api.PullCommand">PullCommand</see>
            </returns>
        </member>
        <member name="M:NGit.Api.Git.BranchCreate">
            <summary>Returns a command object used to create branches</summary>
            <returns>
            a
            <see cref="T:NGit.Api.CreateBranchCommand">CreateBranchCommand</see>
            </returns>
        </member>
        <member name="M:NGit.Api.Git.BranchDelete">
            <summary>Returns a command object used to delete branches</summary>
            <returns>
            a
            <see cref="T:NGit.Api.DeleteBranchCommand">DeleteBranchCommand</see>
            </returns>
        </member>
        <member name="M:NGit.Api.Git.BranchList">
            <summary>Returns a command object used to list branches</summary>
            <returns>
            a
            <see cref="T:NGit.Api.ListBranchCommand">ListBranchCommand</see>
            </returns>
        </member>
        <member name="M:NGit.Api.Git.TagList">
            <summary>Returns a command object used to list tags</summary>
            <returns>
            a
            <see cref="T:NGit.Api.ListTagCommand">ListTagCommand</see>
            </returns>
        </member>
        <member name="M:NGit.Api.Git.BranchRename">
            <summary>Returns a command object used to rename branches</summary>
            <returns>
            a
            <see cref="T:NGit.Api.RenameBranchCommand">RenameBranchCommand</see>
            </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Api.Git.Add" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Api.Git.Tag" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Api.Git.Fetch" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Api.Git.Push" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Api.Git.CherryPick" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Api.Git.Revert" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Api.Git.Rebase" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Api.Git.Rm" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Api.Git.Checkout" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Api.Git.Reset" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Api.Git.Status" -->
        <member name="M:NGit.Api.Git.NotesAdd">
            <summary>Returns a command to add notes to an object</summary>
            <returns>
            a
            <see cref="T:NGit.Api.AddNoteCommand">AddNoteCommand</see>
            </returns>
        </member>
        <member name="M:NGit.Api.Git.NotesRemove">
            <summary>Returns a command to remove notes on an object</summary>
            <returns>
            a
            <see cref="T:NGit.Api.RemoveNoteCommand">RemoveNoteCommand</see>
            </returns>
        </member>
        <member name="M:NGit.Api.Git.NotesList">
            <summary>Returns a command to list all notes</summary>
            <returns>
            a
            <see cref="T:NGit.Api.ListNotesCommand">ListNotesCommand</see>
            </returns>
        </member>
        <member name="M:NGit.Api.Git.NotesShow">
            <summary>Returns a command to show notes on an object</summary>
            <returns>
            a
            <see cref="T:NGit.Api.ShowNoteCommand">ShowNoteCommand</see>
            </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Api.Git.LsRemote" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Api.Git.Clean" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Api.Git.Blame" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Api.Git.Reflog" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Api.Git.Diff" -->
        <member name="M:NGit.Api.Git.TagDelete">
            <summary>Returns a command object used to delete tags</summary>
            <returns>
            a
            <see cref="T:NGit.Api.DeleteTagCommand">DeleteTagCommand</see>
            </returns>
        </member>
        <member name="M:NGit.Api.Git.SubmoduleAdd">
            <summary>
            Returns a command object to execute a
            <code>submodule add</code>
            command
            </summary>
            <returns>
            a
            <see cref="T:NGit.Api.SubmoduleAddCommand">SubmoduleAddCommand</see>
            used to add a new submodule to a
            parent repository
            </returns>
        </member>
        <member name="M:NGit.Api.Git.SubmoduleInit">
            <summary>
            Returns a command object to execute a
            <code>submodule init</code>
            command
            </summary>
            <returns>
            a
            <see cref="T:NGit.Api.SubmoduleInitCommand">SubmoduleInitCommand</see>
            used to initialize the
            repository's config with settings from the .gitmodules file in
            the working tree
            </returns>
        </member>
        <member name="M:NGit.Api.Git.SubmoduleStatus">
            <summary>
            Returns a command object to execute a
            <code>submodule status</code>
            command
            </summary>
            <returns>
            a
            <see cref="T:NGit.Api.SubmoduleStatusCommand">SubmoduleStatusCommand</see>
            used to report the status of a
            repository's configured submodules
            </returns>
        </member>
        <member name="M:NGit.Api.Git.SubmoduleSync">
            <summary>
            Returns a command object to execute a
            <code>submodule sync</code>
            command
            </summary>
            <returns>
            a
            <see cref="T:NGit.Api.SubmoduleSyncCommand">SubmoduleSyncCommand</see>
            used to update the URL of a
            submodule from the parent repository's .gitmodules file
            </returns>
        </member>
        <member name="M:NGit.Api.Git.SubmoduleUpdate">
            <summary>
            Returns a command object to execute a
            <code>submodule update</code>
            command
            </summary>
            <returns>
            a
            <see cref="T:NGit.Api.SubmoduleUpdateCommand">SubmoduleUpdateCommand</see>
            used to update the submodules in
            a repository to the configured revision
            </returns>
        </member>
        <member name="M:NGit.Api.Git.StashList">
            <summary>Returns a command object used to list stashed commits</summary>
            <returns>
            a
            <see cref="T:NGit.Api.StashListCommand">StashListCommand</see>
            </returns>
        </member>
        <member name="M:NGit.Api.Git.StashCreate">
            <summary>Returns a command object used to create a stashed commit</summary>
            <returns>
            a
            <see cref="T:NGit.Api.StashCreateCommand">StashCreateCommand</see>
            </returns>
            <since>2.0</since>
        </member>
        <member name="M:NGit.Api.Git.StashApply">
            <summary>Returns a command object used to apply a stashed commit</summary>
            <returns>
            a
            <see cref="T:NGit.Api.StashApplyCommand">StashApplyCommand</see>
            </returns>
            <since>2.0</since>
        </member>
        <member name="M:NGit.Api.Git.StashDrop">
            <summary>Returns a command object used to drop a stashed commit</summary>
            <returns>
            a
            <see cref="T:NGit.Api.StashDropCommand">StashDropCommand</see>
            </returns>
            <since>2.0</since>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Api.Git.Apply" -->
        <member name="M:NGit.Api.Git.GetRepository">
            <returns>the git repository this class is interacting with</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Api.AddCommand" -->
        <member name="M:NGit.Api.AddCommand.#ctor(NGit.Repository)">
            <param name="repo"></param>
        </member>
        <member name="M:NGit.Api.AddCommand.AddFilepattern(System.String)">
            <param name="filepattern">
            File to add content from. Also a leading directory name (e.g.
            dir to add dir/file1 and dir/file2) can be given to add all
            files in the directory, recursively. Fileglobs (e.g. *.c) are
            not yet supported.
            </param>
            <returns>
            
            <code>this</code>
            </returns>
        </member>
        <member name="M:NGit.Api.AddCommand.SetWorkingTreeIterator(NGit.Treewalk.WorkingTreeIterator)">
            <summary>Allow clients to provide their own implementation of a FileTreeIterator</summary>
            <param name="f"></param>
            <returns>
            
            <code>this</code>
            </returns>
        </member>
        <member name="M:NGit.Api.AddCommand.Call">
            <summary>
            Executes the
            <code>Add</code>
            command. Each instance of this class should only
            be used for one invocation of the command. Don't call this method twice
            on an instance.
            </summary>
            <returns>the DirCache after Add</returns>
            <exception cref="T:NGit.Api.Errors.GitAPIException"></exception>
            <exception cref="T:NGit.Api.Errors.NoFilepatternException"></exception>
        </member>
        <member name="M:NGit.Api.AddCommand.SetUpdate(System.Boolean)">
            <param name="update">
            If set to true, the command only matches
            <code>filepattern</code>
            against already tracked files in the index rather than the
            working tree. That means that it will never stage new files,
            but that it will stage modified new contents of tracked files
            and that it will remove files from the index if the
            corresponding files in the working tree have been removed.
            In contrast to the git command line a
            <code>filepattern</code>
            must
            exist also if update is set to true as there is no
            concept of a working directory here.
            </param>
            <returns>
            
            <code>this</code>
            </returns>
        </member>
        <member name="M:NGit.Api.AddCommand.IsUpdate">
            <returns>is the parameter update is set</returns>
        </member>
        <member name="T:NGit.FileMode">
            <summary>Constants describing various file modes recognized by GIT.</summary>
            <remarks>
            Constants describing various file modes recognized by GIT.
            <p>
            GIT uses a subset of the available UNIX file permission bits. The
            <code>FileMode</code> class provides access to constants defining the modes
            actually used by GIT.
            </p>
            </remarks>
        </member>
        <member name="F:NGit.FileMode.TYPE_MASK">
            <summary>Mask to apply to a file mode to obtain its type bits.</summary>
            <remarks>Mask to apply to a file mode to obtain its type bits.</remarks>
            <seealso cref="F:NGit.FileMode.TYPE_TREE">TYPE_TREE</seealso>
            <seealso cref="F:NGit.FileMode.TYPE_SYMLINK">TYPE_SYMLINK</seealso>
            <seealso cref="F:NGit.FileMode.TYPE_FILE">TYPE_FILE</seealso>
            <seealso cref="F:NGit.FileMode.TYPE_GITLINK">TYPE_GITLINK</seealso>
            <seealso cref="F:NGit.FileMode.TYPE_MISSING">TYPE_MISSING</seealso>
        </member>
        <member name="F:NGit.FileMode.TYPE_TREE">
            <summary>
            Bit pattern for
            <see cref="F:NGit.FileMode.TYPE_MASK">TYPE_MASK</see>
            matching
            <see cref="F:NGit.FileMode.TREE">TREE</see>
            .
            </summary>
        </member>
        <member name="F:NGit.FileMode.TYPE_SYMLINK">
            <summary>
            Bit pattern for
            <see cref="F:NGit.FileMode.TYPE_MASK">TYPE_MASK</see>
            matching
            <see cref="F:NGit.FileMode.SYMLINK">SYMLINK</see>
            .
            </summary>
        </member>
        <member name="F:NGit.FileMode.TYPE_FILE">
            <summary>
            Bit pattern for
            <see cref="F:NGit.FileMode.TYPE_MASK">TYPE_MASK</see>
            matching
            <see cref="F:NGit.FileMode.REGULAR_FILE">REGULAR_FILE</see>
            .
            </summary>
        </member>
        <member name="F:NGit.FileMode.TYPE_GITLINK">
            <summary>
            Bit pattern for
            <see cref="F:NGit.FileMode.TYPE_MASK">TYPE_MASK</see>
            matching
            <see cref="F:NGit.FileMode.GITLINK">GITLINK</see>
            .
            </summary>
        </member>
        <member name="F:NGit.FileMode.TYPE_MISSING">
            <summary>
            Bit pattern for
            <see cref="F:NGit.FileMode.TYPE_MASK">TYPE_MASK</see>
            matching
            <see cref="F:NGit.FileMode.MISSING">MISSING</see>
            .
            </summary>
        </member>
        <member name="F:NGit.FileMode.TREE">
            <summary>Mode indicating an entry is a tree (aka directory).</summary>
            <remarks>Mode indicating an entry is a tree (aka directory).</remarks>
        </member>
        <member name="F:NGit.FileMode.SYMLINK">
            <summary>Mode indicating an entry is a symbolic link.</summary>
            <remarks>Mode indicating an entry is a symbolic link.</remarks>
        </member>
        <member name="F:NGit.FileMode.REGULAR_FILE">
            <summary>Mode indicating an entry is a non-executable file.</summary>
            <remarks>Mode indicating an entry is a non-executable file.</remarks>
        </member>
        <member name="F:NGit.FileMode.EXECUTABLE_FILE">
            <summary>Mode indicating an entry is an executable file.</summary>
            <remarks>Mode indicating an entry is an executable file.</remarks>
        </member>
        <member name="F:NGit.FileMode.GITLINK">
            <summary>Mode indicating an entry is a submodule commit in another repository.</summary>
            <remarks>Mode indicating an entry is a submodule commit in another repository.</remarks>
        </member>
        <member name="F:NGit.FileMode.MISSING">
            <summary>Mode indicating an entry is missing during parallel walks.</summary>
            <remarks>Mode indicating an entry is missing during parallel walks.</remarks>
        </member>
        <member name="M:NGit.FileMode.FromBits(System.Int32)">
            <summary>Convert a set of mode bits into a FileMode enumerated value.</summary>
            <remarks>Convert a set of mode bits into a FileMode enumerated value.</remarks>
            <param name="bits">the mode bits the caller has somehow obtained.</param>
            <returns>the FileMode instance that represents the given bits.</returns>
        </member>
        <member name="M:NGit.FileMode.Equals(System.Int32)">
            <summary>
            Test a file mode for equality with this
            <see cref="T:NGit.FileMode">FileMode</see>
            object.
            </summary>
            <param name="modebits"></param>
            <returns>true if the mode bits represent the same mode as this object</returns>
        </member>
        <member name="M:NGit.FileMode.CopyTo(Sharpen.OutputStream)">
            <summary>Copy this mode as a sequence of octal US-ASCII bytes.</summary>
            <remarks>
            Copy this mode as a sequence of octal US-ASCII bytes.
            <p>
            The mode is copied as a sequence of octal digits using the US-ASCII
            character encoding. The sequence does not use a leading '0' prefix to
            indicate octal notation. This method is suitable for generation of a mode
            string within a GIT tree object.
            </p>
            </remarks>
            <param name="os">stream to copy the mode to.</param>
            <exception cref="T:System.IO.IOException">the stream encountered an error during the copy.
            	</exception>
        </member>
        <member name="M:NGit.FileMode.CopyTo(System.Byte[],System.Int32)">
            <summary>Copy this mode as a sequence of octal US-ASCII bytes.</summary>
            <remarks>
            Copy this mode as a sequence of octal US-ASCII bytes.
            The mode is copied as a sequence of octal digits using the US-ASCII
            character encoding. The sequence does not use a leading '0' prefix to
            indicate octal notation. This method is suitable for generation of a mode
            string within a GIT tree object.
            </remarks>
            <param name="buf">buffer to copy the mode to.</param>
            <param name="ptr">
            position within
            <code>buf</code>
            for first digit.
            </param>
        </member>
        <member name="M:NGit.FileMode.CopyToLength">
            <returns>
            the number of bytes written by
            <see cref="M:NGit.FileMode.CopyTo(Sharpen.OutputStream)">CopyTo(Sharpen.OutputStream)</see>
            .
            </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.FileMode.GetObjectType" -->
        <member name="M:NGit.FileMode.ToString">
            <summary>Format this mode as an octal string (for debugging only).</summary>
            <remarks>Format this mode as an octal string (for debugging only).</remarks>
        </member>
        <member name="M:NGit.FileMode.GetBits">
            <returns>The mode bits as an integer.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Api.StashApplyCommand" -->
        <member name="M:NGit.Api.StashApplyCommand.#ctor(NGit.Repository)">
            <summary>Create command to apply the changes of a stashed commit</summary>
            <param name="repo"></param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Api.StashApplyCommand.SetStashRef(System.String)" -->
        <member name="M:NGit.Api.StashApplyCommand.IsConflict(NGit.Treewalk.AbstractTreeIterator,NGit.Treewalk.AbstractTreeIterator,NGit.Treewalk.AbstractTreeIterator,NGit.Treewalk.AbstractTreeIterator,NGit.Treewalk.AbstractTreeIterator)">
            <summary>Would unstashing overwrite local changes?</summary>
            <param name="stashIndexIter"></param>
            <param name="stashWorkingTreeIter"></param>
            <param name="headIter"></param>
            <param name="indexIter"></param>
            <param name="workingTreeIter"></param>
            <returns>true if unstash conflict, false otherwise</returns>
        </member>
        <member name="M:NGit.Api.StashApplyCommand.GetHeadTree">
            <exception cref="T:NGit.Api.Errors.GitAPIException"></exception>
        </member>
        <member name="M:NGit.Api.StashApplyCommand.GetStashId">
            <exception cref="T:NGit.Api.Errors.GitAPIException"></exception>
        </member>
        <member name="M:NGit.Api.StashApplyCommand.ScanForConflicts(NGit.Treewalk.TreeWalk)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Api.StashApplyCommand.ApplyChanges(NGit.Treewalk.TreeWalk,NGit.Dircache.DirCache,NGit.Dircache.DirCacheEditor)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Api.StashApplyCommand.Call">
            <summary>Apply the changes in a stashed commit to the working directory and index
            	</summary>
            <returns>id of stashed commit that was applied</returns>
            <exception cref="T:NGit.Api.Errors.GitAPIException">NGit.Api.Errors.GitAPIException
            	</exception>
            <exception cref="T:NGit.Api.Errors.WrongRepositoryStateException">NGit.Api.Errors.WrongRepositoryStateException
            	</exception>
        </member>
        <member name="T:NGit.Api.StashApplyCommand.StashDiffFilter">
            <summary>
            Stash diff filter that looks for differences in the first three trees
            which must be the stash head tree, stash index tree, and stash working
            directory tree in any order.
            </summary>
            <remarks>
            Stash diff filter that looks for differences in the first three trees
            which must be the stash head tree, stash index tree, and stash working
            directory tree in any order.
            </remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Api.Status" -->
        <member name="M:NGit.Api.Status.#ctor(NGit.IndexDiff)">
            <param name="diff"></param>
        </member>
        <member name="M:NGit.Api.Status.IsClean">
            <returns>
            true if no differences exist between the working-tree, the index,
            and the current HEAD, false if differences do exist
            </returns>
        </member>
        <member name="M:NGit.Api.Status.GetAdded">
            <returns>
            list of files added to the index, not in HEAD (e.g. what you get
            if you call 'git add ...' on a newly created file)
            </returns>
        </member>
        <member name="M:NGit.Api.Status.GetChanged">
            <returns>
            list of files changed from HEAD to index (e.g. what you get if
            you modify an existing file and call 'git add ...' on it)
            </returns>
        </member>
        <member name="M:NGit.Api.Status.GetRemoved">
            <returns>
            list of files removed from index, but in HEAD (e.g. what you get
            if you call 'git rm ...' on a existing file)
            </returns>
        </member>
        <member name="M:NGit.Api.Status.GetMissing">
            <returns>
            list of files in index, but not filesystem (e.g. what you get if
            you call 'rm ...' on a existing file)
            </returns>
        </member>
        <member name="M:NGit.Api.Status.GetModified">
            <returns>
            list of files modified on disk relative to the index (e.g. what
            you get if you modify an existing file without adding it to the
            index)
            </returns>
        </member>
        <member name="M:NGit.Api.Status.GetUntracked">
            <returns>
            list of files that are not ignored, and not in the index. (e.g.
            what you get if you create a new file without adding it to the
            index)
            </returns>
        </member>
        <member name="M:NGit.Api.Status.GetConflicting">
            <returns>
            list of files that are in conflict. (e.g what you get if you
            modify file that was modified by someone else in the meantime)
            </returns>
        </member>
        <member name="T:NGit.Api.RebaseResult">
            <summary>
            The result of a
            <see cref="T:NGit.Api.RebaseCommand">RebaseCommand</see>
            execution
            </summary>
        </member>
        <member name="M:NGit.Api.RebaseResult.#ctor(NGit.Revwalk.RevCommit)">
            <summary>
            Create <code>RebaseResult</code> with status
            <see cref="F:NGit.Api.RebaseResult.Status.STOPPED">Status.STOPPED</see>
            </summary>
            <param name="commit">current commit</param>
        </member>
        <member name="M:NGit.Api.RebaseResult.#ctor(System.Collections.Generic.IDictionary{System.String,NGit.Merge.ResolveMerger.MergeFailureReason})">
            <summary>
            Create <code>RebaseResult</code> with status
            <see cref="F:NGit.Api.RebaseResult.Status.FAILED">Status.FAILED</see>
            </summary>
            <param name="failingPaths">list of paths causing this rebase to fail</param>
        </member>
        <member name="M:NGit.Api.RebaseResult.GetStatus">
            <returns>the overall status</returns>
        </member>
        <member name="M:NGit.Api.RebaseResult.GetCurrentCommit">
            <returns>
            the current commit if status is
            <see cref="F:NGit.Api.RebaseResult.Status.STOPPED">Status.STOPPED</see>
            , otherwise
            <code>null</code>
            </returns>
        </member>
        <member name="M:NGit.Api.RebaseResult.GetFailingPaths">
            <returns>
            the list of paths causing this rebase to fail (see
            <see cref="M:NGit.Merge.ResolveMerger.GetFailingPaths">NGit.Merge.ResolveMerger.GetFailingPaths()
            	</see>
            for details) if status is
            <see cref="F:NGit.Api.RebaseResult.Status.FAILED">Status.FAILED</see>
            , otherwise <code>null</code>
            </returns>
        </member>
        <member name="T:NGit.Api.Errors.NotMergedException">
            <summary>Thrown when branch deletion fails due to unmerged data</summary>
        </member>
        <member name="M:NGit.Api.Errors.NotMergedException.#ctor">
            <summary>The default constructor with a default message</summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Diff.HashedSequenceComparator`1" -->
        <member name="T:NGit.Diff.ContentSource">
            <summary>
            Supplies the content of a file for
            <see cref="T:NGit.Diff.DiffFormatter">DiffFormatter</see>
            .
            A content source is not thread-safe. Sources may contain state, including
            information about the last ObjectLoader they returned. Callers must be
            careful to ensure there is no more than one ObjectLoader pending on any
            source, at any time.
            </summary>
        </member>
        <member name="M:NGit.Diff.ContentSource.Create(NGit.ObjectReader)">
            <summary>Construct a content source for an ObjectReader.</summary>
            <remarks>Construct a content source for an ObjectReader.</remarks>
            <param name="reader">the reader to obtain blobs from.</param>
            <returns>a source wrapping the reader.</returns>
        </member>
        <member name="M:NGit.Diff.ContentSource.Create(NGit.Treewalk.WorkingTreeIterator)">
            <summary>Construct a content source for a working directory.</summary>
            <remarks>
            Construct a content source for a working directory.
            If the iterator is a
            <see cref="T:NGit.Treewalk.FileTreeIterator">NGit.Treewalk.FileTreeIterator</see>
            an optimized version is
            used that doesn't require seeking through a TreeWalk.
            </remarks>
            <param name="iterator">the iterator to obtain source files through.</param>
            <returns>a content source wrapping the iterator.</returns>
        </member>
        <member name="M:NGit.Diff.ContentSource.Size(System.String,NGit.ObjectId)">
            <summary>Determine the size of the object.</summary>
            <remarks>Determine the size of the object.</remarks>
            <param name="path">the path of the file, relative to the root of the repository.</param>
            <param name="id">blob id of the file, if known.</param>
            <returns>the size in bytes.</returns>
            <exception cref="T:System.IO.IOException">the file cannot be accessed.</exception>
        </member>
        <member name="M:NGit.Diff.ContentSource.Open(System.String,NGit.ObjectId)">
            <summary>Open the object.</summary>
            <remarks>Open the object.</remarks>
            <param name="path">the path of the file, relative to the root of the repository.</param>
            <param name="id">blob id of the file, if known.</param>
            <returns>
            a loader that can supply the content of the file. The loader must
            be used before another loader can be obtained from this same
            source.
            </returns>
            <exception cref="T:System.IO.IOException">the file cannot be accessed.</exception>
        </member>
        <member name="M:NGit.Diff.ContentSource.ObjectReaderSource.Size(System.String,NGit.ObjectId)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Diff.ContentSource.ObjectReaderSource.Open(System.String,NGit.ObjectId)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Diff.ContentSource.WorkingTreeSource.Size(System.String,NGit.ObjectId)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Diff.ContentSource.WorkingTreeSource.Open(System.String,NGit.ObjectId)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Diff.ContentSource.WorkingTreeSource.Seek(System.String)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Diff.ContentSource.WorkingTreeSource._ObjectLoader_173.OpenStream">
            <exception cref="T:NGit.Errors.MissingObjectException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Diff.ContentSource.WorkingTreeSource._ObjectLoader_173.GetCachedBytes">
            <exception cref="T:NGit.Errors.LargeObjectException"></exception>
        </member>
        <member name="M:NGit.Diff.ContentSource.FileSource.Size(System.String,NGit.ObjectId)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Diff.ContentSource.FileSource.Open(System.String,NGit.ObjectId)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Diff.ContentSource.FileSource._ObjectLoader_238.OpenStream">
            <exception cref="T:NGit.Errors.MissingObjectException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Diff.ContentSource.FileSource._ObjectLoader_238.GetCachedBytes">
            <exception cref="T:NGit.Errors.LargeObjectException"></exception>
        </member>
        <member name="T:NGit.Diff.ContentSource.Pair">
            <summary>A pair of sources to access the old and new sides of a DiffEntry.</summary>
            <remarks>A pair of sources to access the old and new sides of a DiffEntry.</remarks>
        </member>
        <member name="M:NGit.Diff.ContentSource.Pair.#ctor(NGit.Diff.ContentSource,NGit.Diff.ContentSource)">
            <summary>Construct a pair of sources.</summary>
            <remarks>Construct a pair of sources.</remarks>
            <param name="oldSource">source to read the old side of a DiffEntry.</param>
            <param name="newSource">source to read the new side of a DiffEntry.</param>
        </member>
        <member name="M:NGit.Diff.ContentSource.Pair.Size(NGit.Diff.DiffEntry.Side,NGit.Diff.DiffEntry)">
            <summary>Determine the size of the object.</summary>
            <remarks>Determine the size of the object.</remarks>
            <param name="side">which side of the entry to read (OLD or NEW).</param>
            <param name="ent">the entry to examine.</param>
            <returns>the size in bytes.</returns>
            <exception cref="T:System.IO.IOException">the file cannot be accessed.</exception>
        </member>
        <member name="M:NGit.Diff.ContentSource.Pair.Open(NGit.Diff.DiffEntry.Side,NGit.Diff.DiffEntry)">
            <summary>Open the object.</summary>
            <remarks>Open the object.</remarks>
            <param name="side">which side of the entry to read (OLD or NEW).</param>
            <param name="ent">the entry to examine.</param>
            <returns>
            a loader that can supply the content of the file. The loader
            must be used before another loader can be obtained from this
            same source.
            </returns>
            <exception cref="T:System.IO.IOException">the file cannot be accessed.</exception>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Transport.TransportGitSsh" -->
        <member name="M:NGit.Transport.TransportGitSsh.OpenFetch">
            <exception cref="T:NGit.Errors.TransportException"></exception>
        </member>
        <member name="M:NGit.Transport.TransportGitSsh.OpenPush">
            <exception cref="T:NGit.Errors.TransportException"></exception>
        </member>
        <member name="M:NGit.Transport.TransportGitSsh.CheckExecFailure(System.Int32,System.String,System.String)">
            <exception cref="T:NGit.Errors.TransportException"></exception>
        </member>
        <member name="M:NGit.Transport.TransportGitSsh._TransportProtocol_84.Open(NGit.Transport.URIish,NGit.Repository,System.String)">
            <exception cref="T:System.NotSupportedException"></exception>
        </member>
        <member name="M:NGit.Transport.TransportGitSsh._SshSessionFactory_134.GetSession(NGit.Transport.URIish,NGit.Transport.CredentialsProvider,NGit.Util.FS,System.Int32)">
            <exception cref="T:NGit.Errors.TransportException"></exception>
        </member>
        <member name="M:NGit.Transport.TransportGitSsh.ExtSession.Exec(System.String,System.Int32)">
            <exception cref="T:NGit.Errors.TransportException"></exception>
        </member>
        <member name="M:NGit.Transport.TransportGitSsh.SshFetchConnection.#ctor(NGit.Transport.TransportGitSsh)">
            <exception cref="T:NGit.Errors.TransportException"></exception>
        </member>
        <member name="M:NGit.Transport.TransportGitSsh.SshPushConnection.#ctor(NGit.Transport.TransportGitSsh)">
            <exception cref="T:NGit.Errors.TransportException"></exception>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Transport.WalkPushConnection" -->
        <member name="F:NGit.Transport.WalkPushConnection.local">
            <summary>The repository this transport pushes out of.</summary>
            <remarks>The repository this transport pushes out of.</remarks>
        </member>
        <member name="F:NGit.Transport.WalkPushConnection.uri">
            <summary>Location of the remote repository we are writing to.</summary>
            <remarks>Location of the remote repository we are writing to.</remarks>
        </member>
        <member name="F:NGit.Transport.WalkPushConnection.dest">
            <summary>Database connection to the remote repository.</summary>
            <remarks>Database connection to the remote repository.</remarks>
        </member>
        <member name="F:NGit.Transport.WalkPushConnection.transport">
            <summary>The configured transport we were constructed by.</summary>
            <remarks>The configured transport we were constructed by.</remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "F:NGit.Transport.WalkPushConnection.packNames" -->
        <member name="F:NGit.Transport.WalkPushConnection.newRefs">
            <summary>Complete listing of refs the remote will have after our push.</summary>
            <remarks>Complete listing of refs the remote will have after our push.</remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "F:NGit.Transport.WalkPushConnection.packedRefUpdates" -->
        <member name="M:NGit.Transport.WalkPushConnection.Push(NGit.ProgressMonitor,System.Collections.Generic.IDictionary{System.String,NGit.Transport.RemoteRefUpdate})">
            <exception cref="T:NGit.Errors.TransportException"></exception>
        </member>
        <member name="M:NGit.Transport.WalkPushConnection.Sendpack(System.Collections.Generic.IList{NGit.Transport.RemoteRefUpdate},NGit.ProgressMonitor)">
            <exception cref="T:NGit.Errors.TransportException"></exception>
        </member>
        <member name="M:NGit.Transport.WalkPushConnection.CreateNewRepository(System.Collections.Generic.IList{NGit.Transport.RemoteRefUpdate})">
            <exception cref="T:NGit.Errors.TransportException"></exception>
        </member>
        <member name="M:NGit.Transport.WalkPushConnection._RefWriter_179.WriteFile(System.String,System.Byte[])">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Errors.RemoteRepositoryException" -->
        <member name="M:NGit.Errors.RemoteRepositoryException.#ctor(NGit.Transport.URIish,System.String)">
            <summary>Constructs a RemoteRepositoryException for a message.</summary>
            <remarks>Constructs a RemoteRepositoryException for a message.</remarks>
            <param name="uri">URI used for transport</param>
            <param name="message">
            message, exactly as supplied by the remote repository. May
            contain LFs (newlines) if the remote formatted it that way.
            </param>
        </member>
        <member name="T:NGit.Util.IO.TimeoutOutputStream">
            <summary>OutputStream with a configurable timeout.</summary>
            <remarks>OutputStream with a configurable timeout.</remarks>
        </member>
        <member name="M:NGit.Util.IO.TimeoutOutputStream.#ctor(Sharpen.OutputStream,NGit.Util.IO.InterruptTimer)">
            <summary>Wrap an output stream with a timeout on all write operations.</summary>
            <remarks>Wrap an output stream with a timeout on all write operations.</remarks>
            <param name="destination">
            base input stream (to write to). The stream must be
            interruptible (most socket streams are).
            </param>
            <param name="timer">timer to manage the timeouts during writes.</param>
        </member>
        <member name="M:NGit.Util.IO.TimeoutOutputStream.GetTimeout">
            <returns>number of milliseconds before aborting a write.</returns>
        </member>
        <member name="M:NGit.Util.IO.TimeoutOutputStream.SetTimeout(System.Int32)">
            <param name="millis">number of milliseconds before aborting a write. Must be &gt; 0.
            	</param>
        </member>
        <member name="M:NGit.Util.IO.TimeoutOutputStream.Write(System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Util.IO.TimeoutOutputStream.Write(System.Byte[])">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Util.IO.TimeoutOutputStream.Write(System.Byte[],System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Util.IO.TimeoutOutputStream.Flush">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Util.IO.TimeoutOutputStream.Close">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="T:NGit.Treewalk.Filter.PathSuffixFilter">
            <summary>Includes tree entries only if they match the configured path.</summary>
            <remarks>Includes tree entries only if they match the configured path.</remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Treewalk.Filter.PathSuffixFilter.Create(System.String)" -->
        <member name="M:NGit.Treewalk.Filter.PathSuffixFilter.Include(NGit.Treewalk.TreeWalk)">
            <exception cref="T:NGit.Errors.MissingObjectException"></exception>
            <exception cref="T:NGit.Errors.IncorrectObjectTypeException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Storage.File.ObjectDirectory" -->
        <member name="F:NGit.Storage.File.ObjectDirectory.RESOLVE_ABBREV_LIMIT">
            <summary>Maximum number of candidates offered as resolutions of abbreviation.</summary>
            <remarks>Maximum number of candidates offered as resolutions of abbreviation.</remarks>
        </member>
        <member name="M:NGit.Storage.File.ObjectDirectory.#ctor(NGit.Config,Sharpen.FilePath,Sharpen.FilePath[],NGit.Util.FS)">
            <summary>Initialize a reference to an on-disk object directory.</summary>
            <remarks>Initialize a reference to an on-disk object directory.</remarks>
            <param name="cfg">configuration this directory consults for write settings.</param>
            <param name="dir">the location of the <code>objects</code> directory.</param>
            <param name="alternatePaths">a list of alternate object directories</param>
            <param name="fs">
            the file system abstraction which will be necessary to perform
            certain file system operations.
            </param>
            <exception cref="T:System.IO.IOException">an alternate object cannot be opened.</exception>
        </member>
        <member name="M:NGit.Storage.File.ObjectDirectory.GetDirectory">
            <returns>the location of the <code>objects</code> directory.</returns>
        </member>
        <member name="M:NGit.Storage.File.ObjectDirectory.Create">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.ObjectDirectory.FileFor(NGit.AnyObjectId)">
            <summary>Compute the location of a loose object file.</summary>
            <remarks>Compute the location of a loose object file.</remarks>
            <param name="objectId">identity of the loose object to map to the directory.</param>
            <returns>location of the object, if it were to exist as a loose object.</returns>
        </member>
        <member name="M:NGit.Storage.File.ObjectDirectory.GetPacks">
            <returns>
            unmodifiable collection of all known pack files local to this
            directory. Most recent packs are presented first. Packs most
            likely to contain more recent objects appear before packs
            containing objects referenced by commits further back in the
            history of the repository.
            </returns>
        </member>
        <member name="M:NGit.Storage.File.ObjectDirectory.GetCachedPacks">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.ObjectDirectory.ScanCachedPacks(NGit.Storage.File.ObjectDirectory.CachedPackList)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.ObjectDirectory.OpenPack(Sharpen.FilePath,Sharpen.FilePath)">
            <summary>Add a single existing pack to the list of available pack files.</summary>
            <remarks>Add a single existing pack to the list of available pack files.</remarks>
            <param name="pack">path of the pack file to open.</param>
            <param name="idx">path of the corresponding index file.</param>
            <returns>the pack that was opened and added to the database.</returns>
            <exception cref="T:System.IO.IOException">
            index file could not be opened, read, or is not recognized as
            a Git pack file index.
            </exception>
        </member>
        <member name="M:NGit.Storage.File.ObjectDirectory.Resolve(System.Collections.Generic.ICollection{NGit.ObjectId},NGit.AbbreviatedObjectId)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.ObjectDirectory.OpenObject1(NGit.Storage.File.WindowCursor,NGit.AnyObjectId)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.ObjectDirectory.GetObjectSize1(NGit.Storage.File.WindowCursor,NGit.AnyObjectId)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.ObjectDirectory.GetObjectSize2(NGit.Storage.File.WindowCursor,System.String,NGit.AnyObjectId)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.ObjectDirectory.SelectObjectRepresentation(NGit.Storage.Pack.PackWriter,NGit.Storage.Pack.ObjectToPack,NGit.Storage.File.WindowCursor)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.ObjectDirectory.OpenObject2(NGit.Storage.File.WindowCursor,System.String,NGit.AnyObjectId)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.ObjectDirectory.InsertUnpackedObject(Sharpen.FilePath,NGit.ObjectId,System.Boolean)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.ObjectDirectory.LoadAlternates">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.ObjectDirectory.Open(Sharpen.FilePath)">
            <exception cref="T:System.IO.FileNotFoundException"></exception>
        </member>
        <member name="M:NGit.Storage.File.ObjectDirectory.OpenAlternate(System.String)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.ObjectDirectory.OpenAlternate(Sharpen.FilePath)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="F:NGit.Storage.File.ObjectDirectory.PackList.snapshot">
            <summary>State just before reading the pack directory.</summary>
            <remarks>State just before reading the pack directory.</remarks>
        </member>
        <member name="F:NGit.Storage.File.ObjectDirectory.PackList.packs">
            <summary>
            All known packs, sorted by
            <see cref="F:NGit.Storage.File.PackFile.SORT">PackFile.SORT</see>
            .
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Storage.File.CachedObjectDirectory" -->
        <member name="F:NGit.Storage.File.CachedObjectDirectory.unpackedObjects">
            <summary>
            The set that contains unpacked objects identifiers, it is created when
            the cached instance is created.
            </summary>
            <remarks>
            The set that contains unpacked objects identifiers, it is created when
            the cached instance is created.
            </remarks>
        </member>
        <member name="M:NGit.Storage.File.CachedObjectDirectory.#ctor(NGit.Storage.File.ObjectDirectory)">
            <summary>The constructor</summary>
            <param name="wrapped">the wrapped database</param>
        </member>
        <member name="M:NGit.Storage.File.CachedObjectDirectory.GetCachedPacks">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.CachedObjectDirectory.Resolve(System.Collections.Generic.ICollection{NGit.ObjectId},NGit.AbbreviatedObjectId)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.CachedObjectDirectory.OpenObject(NGit.Storage.File.WindowCursor,NGit.AnyObjectId)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.CachedObjectDirectory.OpenObject1(NGit.Storage.File.WindowCursor,NGit.AnyObjectId)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.CachedObjectDirectory.OpenObject2(NGit.Storage.File.WindowCursor,System.String,NGit.AnyObjectId)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.CachedObjectDirectory.GetObjectSize1(NGit.Storage.File.WindowCursor,NGit.AnyObjectId)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.CachedObjectDirectory.GetObjectSize2(NGit.Storage.File.WindowCursor,System.String,NGit.AnyObjectId)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.CachedObjectDirectory.InsertUnpackedObject(Sharpen.FilePath,NGit.ObjectId,System.Boolean)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.CachedObjectDirectory.OpenPack(Sharpen.FilePath,Sharpen.FilePath)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.CachedObjectDirectory.SelectObjectRepresentation(NGit.Storage.Pack.PackWriter,NGit.Storage.Pack.ObjectToPack,NGit.Storage.File.WindowCursor)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="T:NGit.Revwalk.Filter.CommitterRevFilter">
            <summary>Matches only commits whose committer name matches the pattern.</summary>
            <remarks>Matches only commits whose committer name matches the pattern.</remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Revwalk.Filter.CommitterRevFilter.Create(System.String)" -->
        <!-- Badly formed XML comment ignored for member "T:NGit.Revplot.PlotCommitList`1" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Revplot.PlotCommitList`1.FindPassingThrough(NGit.Revplot.PlotCommit{`0},System.Collections.Generic.ICollection{`0})" -->
        <member name="M:NGit.Revplot.PlotCommitList`1.HandleBlockedLanes(System.Int32,NGit.Revplot.PlotCommit{`0},System.Int32)">
            <summary>
            when connecting a plotcommit to the child make sure that you will not be
            located on a lane on which a passed commit is located on.
            </summary>
            <remarks>
            when connecting a plotcommit to the child make sure that you will not be
            located on a lane on which a passed commit is located on. Otherwise we
            would have to draw a line through a commit.
            </remarks>
            <param name="index"></param>
            <param name="commit"></param>
            <param name="nChildren"></param>
        </member>
        <member name="M:NGit.Revplot.PlotCommitList`1.CreateLane">
            <returns>a new Lane appropriate for this particular PlotList.</returns>
        </member>
        <member name="M:NGit.Revplot.PlotCommitList`1.RecycleLane(`0)">
            <summary>
            Return colors and other reusable information to the plotter when a lane
            is no longer needed.
            </summary>
            <remarks>
            Return colors and other reusable information to the plotter when a lane
            is no longer needed.
            </remarks>
            <param name="lane"></param>
        </member>
        <member name="T:NGit.Errors.GitlinksNotSupportedException">
            <summary>
            An exception thrown when a gitlink entry is found and cannot be
            handled.
            </summary>
            <remarks>
            An exception thrown when a gitlink entry is found and cannot be
            handled.
            </remarks>
        </member>
        <member name="M:NGit.Errors.GitlinksNotSupportedException.#ctor(System.String)">
            <summary>Construct a GitlinksNotSupportedException for the specified link</summary>
            <param name="s">name of link in tree or workdir</param>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Api.MergeCommand" -->
        <member name="M:NGit.Api.MergeCommand.#ctor(NGit.Repository)">
            <param name="repo"></param>
        </member>
        <member name="M:NGit.Api.MergeCommand.Call">
            <summary>
            Executes the
            <code>Merge</code>
            command with all the options and parameters
            collected by the setter methods (e.g.
            <see cref="M:NGit.Api.MergeCommand.Include(NGit.Ref)">Include(NGit.Ref)</see>
            ) of this
            class. Each instance of this class should only be used for one invocation
            of the command. Don't call this method twice on an instance.
            </summary>
            <returns>the result of the merge</returns>
            <exception cref="T:NGit.Api.Errors.GitAPIException"></exception>
            <exception cref="T:NGit.Api.Errors.NoHeadException"></exception>
            <exception cref="T:NGit.Api.Errors.ConcurrentRefUpdateException"></exception>
            <exception cref="T:NGit.Api.Errors.CheckoutConflictException"></exception>
            <exception cref="T:NGit.Api.Errors.InvalidMergeHeadsException"></exception>
            <exception cref="T:NGit.Api.Errors.WrongRepositoryStateException"></exception>
            <exception cref="T:NGit.Api.Errors.NoMessageException"></exception>
        </member>
        <member name="M:NGit.Api.MergeCommand.UpdateHead(System.Text.StringBuilder,NGit.ObjectId,NGit.ObjectId)">
            <exception cref="T:System.IO.IOException"></exception>
            <exception cref="T:NGit.Api.Errors.ConcurrentRefUpdateException"></exception>
        </member>
        <member name="M:NGit.Api.MergeCommand.SetStrategy(NGit.Merge.MergeStrategy)">
            <param name="mergeStrategy">
            the
            <see cref="T:NGit.Merge.MergeStrategy">NGit.Merge.MergeStrategy</see>
            to be used
            </param>
            <returns>
            
            <code>this</code>
            </returns>
        </member>
        <member name="M:NGit.Api.MergeCommand.Include(NGit.Ref)">
            <param name="commit">a reference to a commit which is merged with the current head
            	</param>
            <returns>
            
            <code>this</code>
            </returns>
        </member>
        <member name="M:NGit.Api.MergeCommand.Include(NGit.AnyObjectId)">
            <param name="commit">the Id of a commit which is merged with the current head</param>
            <returns>
            
            <code>this</code>
            </returns>
        </member>
        <member name="M:NGit.Api.MergeCommand.Include(System.String,NGit.AnyObjectId)">
            <param name="name">a name given to the commit</param>
            <param name="commit">the Id of a commit which is merged with the current head</param>
            <returns>
            
            <code>this</code>
            </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Api.MergeCommand.SetSquash(System.Boolean)" -->
        <member name="T:NGit.GitIndex">
            <summary>A representation of the Git index.</summary>
            <remarks>
            A representation of the Git index.
            The index points to the objects currently checked out or in the process of
            being prepared for committing or objects involved in an unfinished merge.
            The abstract format is:<br/> path stage flags statdata SHA-1
            <ul>
            <li>Path is the relative path in the workdir</li>
            <li>stage is 0 (normally), but when
            merging 1 is the common ancestor version, 2 is 'our' version and 3 is 'their'
            version. A fully resolved merge only contains stage 0.</li>
            <li>flags is the object type and information of validity</li>
            <li>statdata is the size of this object and some other file system specifics,
            some of it ignored by JGit</li>
            <li>SHA-1 represents the content of the references object</li>
            </ul>
            An index can also contain a tree cache which we ignore for now. We drop the
            tree cache when writing the index.
            </remarks>
        </member>
        <member name="F:NGit.GitIndex.STAGE_0">
            <summary>Stage 0 represents merged entries.</summary>
            <remarks>Stage 0 represents merged entries.</remarks>
        </member>
        <member name="M:NGit.GitIndex.#ctor(NGit.Repository)">
            <summary>Construct a Git index representation.</summary>
            <remarks>Construct a Git index representation.</remarks>
            <param name="db"></param>
        </member>
        <member name="M:NGit.GitIndex.IsChanged">
            <returns>true if we have modified the index in memory since reading it from disk</returns>
        </member>
        <member name="M:NGit.GitIndex.RereadIfNecessary">
            <summary>Reread index data from disk if the index file has been changed</summary>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:NGit.GitIndex.Add(Sharpen.FilePath,Sharpen.FilePath)">
            <summary>Add the content of a file to the index.</summary>
            <remarks>Add the content of a file to the index.</remarks>
            <param name="wd">workdir</param>
            <param name="f">the file</param>
            <returns>a new or updated index entry for the path represented by f</returns>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:NGit.GitIndex.Add(Sharpen.FilePath,Sharpen.FilePath,System.Byte[])">
            <summary>Add the content of a file to the index.</summary>
            <remarks>Add the content of a file to the index.</remarks>
            <param name="wd">workdir</param>
            <param name="f">the file</param>
            <param name="content">content of the file</param>
            <returns>a new or updated index entry for the path represented by f</returns>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:NGit.GitIndex.Remove(Sharpen.FilePath,Sharpen.FilePath)">
            <summary>Remove a path from the index.</summary>
            <remarks>Remove a path from the index.</remarks>
            <param name="wd">workdir</param>
            <param name="f">the file whose path shall be removed.</param>
            <returns>true if such a path was found (and thus removed)</returns>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:NGit.GitIndex.Read">
            <summary>Read the cache file into memory.</summary>
            <remarks>Read the cache file into memory.</remarks>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:NGit.GitIndex.Write">
            <summary>Write content of index to disk.</summary>
            <remarks>Write content of index to disk.</remarks>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:NGit.GitIndex.CheckWriteOk">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.GitIndex.ReadTree(NGit.Tree)">
            <summary>Read a Tree recursively into the index</summary>
            <param name="t">The tree to read</param>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:NGit.GitIndex.ReadTree(System.String,NGit.Tree)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.GitIndex.AddEntry(NGit.TreeEntry)">
            <summary>Add tree entry to index</summary>
            <param name="te">tree entry</param>
            <returns>new or modified index entry</returns>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:NGit.GitIndex.Checkout(Sharpen.FilePath)">
            <summary>Check out content of the content represented by the index</summary>
            <param name="wd">workdir</param>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:NGit.GitIndex.CheckoutEntry(Sharpen.FilePath,NGit.GitIndex.Entry)">
            <summary>Check out content of the specified index entry</summary>
            <param name="wd">workdir</param>
            <param name="e">index entry</param>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:NGit.GitIndex.WriteTree">
            <summary>Construct and write tree out of index.</summary>
            <remarks>Construct and write tree out of index.</remarks>
            <returns>SHA-1 of the constructed tree</returns>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:NGit.GitIndex.GetMembers">
            <summary>
            Return the members of the index sorted by the unsigned byte
            values of the path names.
            </summary>
            <remarks>
            Return the members of the index sorted by the unsigned byte
            values of the path names.
            Small beware: Unaccounted for are unmerged entries. You may want
            to abort if members with stage != 0 are found if you are doing
            any updating operations. All stages will be found after one another
            here later. Currently only one stage per name is returned.
            </remarks>
            <returns>The index entries sorted</returns>
        </member>
        <member name="M:NGit.GitIndex.GetEntry(System.String)">
            <summary>Look up an entry with the specified path.</summary>
            <remarks>Look up an entry with the specified path.</remarks>
            <param name="path"></param>
            <returns>index entry for the path or null if not in index.</returns>
            <exception cref="T:Sharpen.UnsupportedEncodingException">Sharpen.UnsupportedEncodingException
            	</exception>
        </member>
        <member name="M:NGit.GitIndex.GetRepository">
            <returns>The repository holding this index.</returns>
        </member>
        <member name="T:NGit.GitIndex.Entry">
            <summary>An index entry</summary>
        </member>
        <member name="M:NGit.GitIndex.Entry.#ctor(NGit.GitIndex,System.Byte[],Sharpen.FilePath,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.GitIndex.Entry.#ctor(NGit.GitIndex,System.Byte[],Sharpen.FilePath,System.Int32,System.Byte[])">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.GitIndex.Entry.Update(Sharpen.FilePath)">
            <summary>
            Update this index entry with stat and SHA-1 information if it looks
            like the file has been modified in the workdir.
            </summary>
            <remarks>
            Update this index entry with stat and SHA-1 information if it looks
            like the file has been modified in the workdir.
            </remarks>
            <param name="f">file in work dir</param>
            <returns>true if a change occurred</returns>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:NGit.GitIndex.Entry.Update(Sharpen.FilePath,System.Byte[])">
            <summary>
            Update this index entry with stat and SHA-1 information if it looks
            like the file has been modified in the workdir.
            </summary>
            <remarks>
            Update this index entry with stat and SHA-1 information if it looks
            like the file has been modified in the workdir.
            </remarks>
            <param name="f">file in work dir</param>
            <param name="newContent">the new content of the file</param>
            <returns>true if a change occurred</returns>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:NGit.GitIndex.Entry.IsModified(Sharpen.FilePath)">
            <summary>
            Check if an entry's content is different from the cache,
            File status information is used and status is same we
            consider the file identical to the state in the working
            directory.
            </summary>
            <remarks>
            Check if an entry's content is different from the cache,
            File status information is used and status is same we
            consider the file identical to the state in the working
            directory. Native git uses more stat fields than we
            have accessible in Java.
            </remarks>
            <param name="wd">working directory to compare content with</param>
            <returns>true if content is most likely different.</returns>
        </member>
        <member name="M:NGit.GitIndex.Entry.IsModified(Sharpen.FilePath,System.Boolean)">
            <summary>
            Check if an entry's content is different from the cache,
            File status information is used and status is same we
            consider the file identical to the state in the working
            directory.
            </summary>
            <remarks>
            Check if an entry's content is different from the cache,
            File status information is used and status is same we
            consider the file identical to the state in the working
            directory. Native git uses more stat fields than we
            have accessible in Java.
            </remarks>
            <param name="wd">working directory to compare content with</param>
            <param name="forceContentCheck">
            True if the actual file content
            should be checked if modification time differs.
            </param>
            <returns>true if content is most likely different.</returns>
        </member>
        <member name="M:NGit.GitIndex.Entry.GetStages">
            <summary>Returns the stages in which the entry's file is recorded in the index.</summary>
            <remarks>
            Returns the stages in which the entry's file is recorded in the index.
            The stages are bit-encoded: bit N is set if the file is present
            in stage N. In particular, the N-th bit will be set if this entry
            itself is in stage N (see getStage()).
            </remarks>
            <returns>flags denoting stages</returns>
            <seealso cref="M:NGit.GitIndex.Entry.GetStage">GetStage()</seealso>
        </member>
        <member name="M:NGit.GitIndex.Entry.GetName">
            <returns>path name for this entry</returns>
        </member>
        <member name="M:NGit.GitIndex.Entry.GetNameUTF8">
            <returns>path name for this entry as byte array, hopefully UTF-8 encoded</returns>
        </member>
        <member name="M:NGit.GitIndex.Entry.GetObjectId">
            <returns>SHA-1 of the entry managed by this index</returns>
        </member>
        <member name="M:NGit.GitIndex.Entry.GetStage">
            <returns>the stage this entry is in</returns>
        </member>
        <member name="M:NGit.GitIndex.Entry.GetSize">
            <returns>size of disk object</returns>
        </member>
        <member name="M:NGit.GitIndex.Entry.IsAssumedValid">
            <returns>true if this entry shall be assumed valid</returns>
        </member>
        <member name="M:NGit.GitIndex.Entry.IsUpdateNeeded">
            <returns>true if this entry should be checked for changes</returns>
        </member>
        <member name="M:NGit.GitIndex.Entry.SetAssumeValid(System.Boolean)">
            <summary>Set whether to always assume this entry valid</summary>
            <param name="assumeValid">true to ignore changes</param>
        </member>
        <member name="M:NGit.GitIndex.Entry.SetUpdateNeeded(System.Boolean)">
            <summary>Set whether this entry must be checked</summary>
            <param name="updateNeeded"></param>
        </member>
        <member name="M:NGit.GitIndex.Entry.GetModeBits">
            <summary>Return raw file mode bits.</summary>
            <remarks>
            Return raw file mode bits. See
            <see cref="T:NGit.FileMode">FileMode</see>
            </remarks>
            <returns>file mode bits</returns>
        </member>
        <member name="M:NGit.GitIndex.Header.#ctor(Sharpen.ByteBuffer)">
            <exception cref="T:NGit.Errors.CorruptObjectException"></exception>
        </member>
        <member name="M:NGit.GitIndex.Header.Read(Sharpen.ByteBuffer)">
            <exception cref="T:NGit.Errors.CorruptObjectException"></exception>
        </member>
        <member name="T:NGit.CoreConfig">
            <summary>This class keeps git repository core parameters.</summary>
            <remarks>This class keeps git repository core parameters.</remarks>
        </member>
        <member name="F:NGit.CoreConfig.KEY">
            <summary>
            Key for
            <see cref="!:Config.Get&lt;T&gt;(SectionParser&lt;T&gt;)">Config.Get&lt;T&gt;(SectionParser&lt;T&gt;)
            	</see>
            .
            </summary>
        </member>
        <member name="M:NGit.CoreConfig.GetCompression">
            <returns>The compression level to use when storing loose objects</returns>
        </member>
        <member name="M:NGit.CoreConfig.GetPackIndexVersion">
            <returns>the preferred pack index file format; 0 for oldest possible.</returns>
        </member>
        <member name="M:NGit.CoreConfig.IsLogAllRefUpdates">
            <returns>whether to log all refUpdates</returns>
        </member>
        <member name="M:NGit.CoreConfig.GetExcludesFile">
            <returns>path of excludesfile</returns>
        </member>
        <member name="T:NGit.CoreConfig.AutoCRLF">
            <summary>
            Permissible values for
            <code>core.autocrlf</code>
            .
            </summary>
        </member>
        <member name="T:NGit.ConfigConstants">
            <summary>
            Constants for use with the Configuration classes: section names,
            configuration keys
            </summary>
        </member>
        <member name="F:NGit.ConfigConstants.CONFIG_CORE_SECTION">
            <summary>The "core" section</summary>
        </member>
        <member name="F:NGit.ConfigConstants.CONFIG_BRANCH_SECTION">
            <summary>The "branch" section</summary>
        </member>
        <member name="F:NGit.ConfigConstants.CONFIG_REMOTE_SECTION">
            <summary>The "remote" section</summary>
        </member>
        <member name="F:NGit.ConfigConstants.CONFIG_DIFF_SECTION">
            <summary>The "diff" section</summary>
        </member>
        <member name="F:NGit.ConfigConstants.CONFIG_DFS_SECTION">
            <summary>The "dfs" section</summary>
        </member>
        <member name="F:NGit.ConfigConstants.CONFIG_USER_SECTION">
            <summary>The "user" section</summary>
        </member>
        <member name="F:NGit.ConfigConstants.CONFIG_GERRIT_SECTION">
            <summary>The "gerrit" section</summary>
        </member>
        <member name="F:NGit.ConfigConstants.CONFIG_WORKFLOW_SECTION">
            <summary>The "workflow" section</summary>
        </member>
        <member name="F:NGit.ConfigConstants.CONFIG_SUBMODULE_SECTION">
            <summary>The "submodule" section</summary>
        </member>
        <member name="F:NGit.ConfigConstants.CONFIG_PACK_SECTION">
            <summary>The "pack" section</summary>
        </member>
        <member name="F:NGit.ConfigConstants.CONFIG_KEY_ALGORITHM">
            <summary>The "algorithm" key</summary>
        </member>
        <member name="F:NGit.ConfigConstants.CONFIG_KEY_AUTOCRLF">
            <summary>The "autocrlf" key</summary>
        </member>
        <member name="F:NGit.ConfigConstants.CONFIG_KEY_BARE">
            <summary>The "bare" key</summary>
        </member>
        <member name="F:NGit.ConfigConstants.CONFIG_KEY_EXCLUDESFILE">
            <summary>The "excludesfile" key</summary>
        </member>
        <member name="F:NGit.ConfigConstants.CONFIG_KEY_FILEMODE">
            <summary>The "filemode" key</summary>
        </member>
        <member name="F:NGit.ConfigConstants.CONFIG_KEY_LOGALLREFUPDATES">
            <summary>The "logallrefupdates" key</summary>
        </member>
        <member name="F:NGit.ConfigConstants.CONFIG_KEY_REPO_FORMAT_VERSION">
            <summary>The "repositoryformatversion" key</summary>
        </member>
        <member name="F:NGit.ConfigConstants.CONFIG_KEY_WORKTREE">
            <summary>The "worktree" key</summary>
        </member>
        <member name="F:NGit.ConfigConstants.CONFIG_KEY_BLOCK_LIMIT">
            <summary>The "blockLimit" key</summary>
        </member>
        <member name="F:NGit.ConfigConstants.CONFIG_KEY_BLOCK_SIZE">
            <summary>The "blockSize" key</summary>
        </member>
        <member name="F:NGit.ConfigConstants.CONFIG_KEY_READ_AHEAD_LIMIT">
            <summary>The "readAheadLimit" key</summary>
        </member>
        <member name="F:NGit.ConfigConstants.CONFIG_KEY_READ_AHEAD_THREADS">
            <summary>The "readAheadThreads" key</summary>
        </member>
        <member name="F:NGit.ConfigConstants.CONFIG_KEY_DELTA_BASE_CACHE_LIMIT">
            <summary>The "deltaBaseCacheLimit" key</summary>
        </member>
        <member name="F:NGit.ConfigConstants.CONFIG_KEY_STREAM_FILE_TRESHOLD">
            <summary>The "streamFileThreshold" key</summary>
        </member>
        <member name="F:NGit.ConfigConstants.CONFIG_KEY_REMOTE">
            <summary>The "remote" key</summary>
        </member>
        <member name="F:NGit.ConfigConstants.CONFIG_KEY_MERGE">
            <summary>The "merge" key</summary>
        </member>
        <member name="F:NGit.ConfigConstants.CONFIG_KEY_REBASE">
            <summary>The "rebase" key</summary>
        </member>
        <member name="F:NGit.ConfigConstants.CONFIG_KEY_URL">
            <summary>The "url" key</summary>
        </member>
        <member name="F:NGit.ConfigConstants.CONFIG_KEY_AUTOSETUPMERGE">
            <summary>The "autosetupmerge" key</summary>
        </member>
        <member name="F:NGit.ConfigConstants.CONFIG_KEY_AUTOSETUPREBASE">
            <summary>The "autosetuprebase" key</summary>
        </member>
        <member name="F:NGit.ConfigConstants.CONFIG_KEY_NAME">
            <summary>The "name" key</summary>
        </member>
        <member name="F:NGit.ConfigConstants.CONFIG_KEY_EMAIL">
            <summary>The "email" key</summary>
        </member>
        <member name="F:NGit.ConfigConstants.CONFIG_KEY_FALSE">
            <summary>
            The "false" key (used to configure
            <see cref="F:NGit.ConfigConstants.CONFIG_KEY_AUTOSETUPMERGE">CONFIG_KEY_AUTOSETUPMERGE</see>
            
            </summary>
        </member>
        <member name="F:NGit.ConfigConstants.CONFIG_KEY_TRUE">
            <summary>
            The "true" key (used to configure
            <see cref="F:NGit.ConfigConstants.CONFIG_KEY_AUTOSETUPMERGE">CONFIG_KEY_AUTOSETUPMERGE</see>
            
            </summary>
        </member>
        <member name="F:NGit.ConfigConstants.CONFIG_KEY_ALWAYS">
            <summary>
            The "always" key (used to configure
            <see cref="F:NGit.ConfigConstants.CONFIG_KEY_AUTOSETUPREBASE">CONFIG_KEY_AUTOSETUPREBASE</see>
            and
            <see cref="F:NGit.ConfigConstants.CONFIG_KEY_AUTOSETUPMERGE">CONFIG_KEY_AUTOSETUPMERGE</see>
            </summary>
        </member>
        <member name="F:NGit.ConfigConstants.CONFIG_KEY_NEVER">
            <summary>
            The "never" key (used to configure
            <see cref="F:NGit.ConfigConstants.CONFIG_KEY_AUTOSETUPREBASE">CONFIG_KEY_AUTOSETUPREBASE</see>
            
            </summary>
        </member>
        <member name="F:NGit.ConfigConstants.CONFIG_KEY_LOCAL">
            <summary>
            The "local" key (used to configure
            <see cref="F:NGit.ConfigConstants.CONFIG_KEY_AUTOSETUPREBASE">CONFIG_KEY_AUTOSETUPREBASE</see>
            
            </summary>
        </member>
        <member name="F:NGit.ConfigConstants.CONFIG_KEY_CREATECHANGEID">
            <summary>The "createchangeid" key</summary>
        </member>
        <member name="F:NGit.ConfigConstants.CONFIG_KEY_DEFBRANCHSTARTPOINT">
            <summary>The "defaultsourceref" key</summary>
        </member>
        <member name="F:NGit.ConfigConstants.CONFIG_KEY_PATH">
            <summary>The "path" key</summary>
        </member>
        <member name="F:NGit.ConfigConstants.CONFIG_KEY_UPDATE">
            <summary>The "update" key</summary>
        </member>
        <member name="F:NGit.ConfigConstants.CONFIG_KEY_COMPRESSION">
            <summary>The "compression" key</summary>
        </member>
        <member name="F:NGit.ConfigConstants.CONFIG_KEY_INDEXVERSION">
            <summary>The "indexversion" key</summary>
        </member>
        <member name="T:NGit.Storage.File.ReflogWriter">
            <summary>Utility for writing reflog entries</summary>
            <since>2.0</since>
        </member>
        <member name="M:NGit.Storage.File.ReflogWriter.RefLockFor(System.String)">
            <summary>Get the ref name to be used for when locking a ref's log for rewriting</summary>
            <param name="name">
            name of the ref, relative to the Git repository top level
            directory (so typically starts with refs/).
            </param>
            <returns>the name of the ref's lock ref</returns>
        </member>
        <member name="M:NGit.Storage.File.ReflogWriter.#ctor(NGit.Repository)">
            <summary>Create write for repository</summary>
            <param name="repository"></param>
        </member>
        <member name="M:NGit.Storage.File.ReflogWriter.#ctor(NGit.Repository,System.Boolean)">
            <summary>Create write for repository</summary>
            <param name="repository"></param>
            <param name="forceWrite">
            true to write to disk all entries logged, false to respect the
            repository's config and current log file status
            </param>
        </member>
        <member name="M:NGit.Storage.File.ReflogWriter.GetRepository">
            <summary>Get repository that reflog is being written for</summary>
            <returns>file repository</returns>
        </member>
        <member name="M:NGit.Storage.File.ReflogWriter.Create">
            <summary>Create the log directories</summary>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
            <returns>this writer</returns>
        </member>
        <member name="M:NGit.Storage.File.ReflogWriter.LogFor(System.String)">
            <summary>Locate the log file on disk for a single reference name.</summary>
            <remarks>Locate the log file on disk for a single reference name.</remarks>
            <param name="name">
            name of the ref, relative to the Git repository top level
            directory (so typically starts with refs/).
            </param>
            <returns>the log file location.</returns>
        </member>
        <member name="M:NGit.Storage.File.ReflogWriter.Log(System.String,NGit.Storage.File.ReflogEntry)">
            <summary>
            Write the given
            <see cref="T:NGit.Storage.File.ReflogEntry">ReflogEntry</see>
            entry to the ref's log
            </summary>
            <param name="refName"></param>
            <param name="entry"></param>
            <returns>this writer</returns>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:NGit.Storage.File.ReflogWriter.Log(System.String,NGit.ObjectId,NGit.ObjectId,NGit.PersonIdent,System.String)">
            <summary>Write the given entry information to the ref's log</summary>
            <param name="refName"></param>
            <param name="oldId"></param>
            <param name="newId"></param>
            <param name="ident"></param>
            <param name="message"></param>
            <returns>this writer</returns>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:NGit.Storage.File.ReflogWriter.Log(NGit.RefUpdate,System.String,System.Boolean)">
            <summary>Write the given ref update to the ref's log</summary>
            <param name="update"></param>
            <param name="msg"></param>
            <param name="deref"></param>
            <returns>this writer</returns>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:NGit.Storage.File.ReflogWriter.Log(System.String,System.Byte[])">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Api.StashCreateCommand" -->
        <member name="M:NGit.Api.StashCreateCommand.#ctor(NGit.Repository)">
            <summary>Create a command to stash changes in the working directory and index</summary>
            <param name="repo"></param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Api.StashCreateCommand.SetIndexMessage(System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Api.StashCreateCommand.SetWorkingDirectoryMessage(System.String)" -->
        <member name="M:NGit.Api.StashCreateCommand.SetPerson(NGit.PersonIdent)">
            <summary>Set the person to use as the author and committer in the commits made</summary>
            <param name="person"></param>
            <returns>
            
            <code>this</code>
            </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Api.StashCreateCommand.SetRef(System.String)" -->
        <member name="M:NGit.Api.StashCreateCommand.ParseCommit(NGit.ObjectReader,NGit.ObjectId)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Api.StashCreateCommand.UpdateStashRef(NGit.ObjectId,NGit.PersonIdent,System.String)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Api.StashCreateCommand.GetHead">
            <exception cref="T:NGit.Api.Errors.GitAPIException"></exception>
        </member>
        <member name="M:NGit.Api.StashCreateCommand.Call">
            <summary>
            Stash the contents on the working directory and index in separate commits
            and reset to the current HEAD commit.
            </summary>
            <remarks>
            Stash the contents on the working directory and index in separate commits
            and reset to the current HEAD commit.
            </remarks>
            <returns>stashed commit or null if no changes to stash</returns>
            <exception cref="T:NGit.Api.Errors.GitAPIException">NGit.Api.Errors.GitAPIException
            	</exception>
        </member>
        <member name="T:NGit.Transport.AbstractAdvertiseRefsHook">
            <summary>
            Implementation of
            <see cref="T:NGit.Transport.AdvertiseRefsHook">AdvertiseRefsHook</see>
            that advertises the same refs for
            upload-pack and receive-pack.
            </summary>
            <since>2.0</since>
        </member>
        <member name="M:NGit.Transport.AbstractAdvertiseRefsHook.AdvertiseRefs(NGit.Transport.UploadPack)">
            <exception cref="T:NGit.Transport.ServiceMayNotContinueException"></exception>
        </member>
        <member name="M:NGit.Transport.AbstractAdvertiseRefsHook.AdvertiseRefs(NGit.Transport.BaseReceivePack)">
            <exception cref="T:NGit.Transport.ServiceMayNotContinueException"></exception>
        </member>
        <member name="M:NGit.Transport.AbstractAdvertiseRefsHook.GetAdvertisedRefs(NGit.Repository,NGit.Revwalk.RevWalk)">
            <summary>Get the refs to advertise.</summary>
            <remarks>Get the refs to advertise.</remarks>
            <param name="repository">repository instance.</param>
            <param name="revWalk">open rev walk on the repository.</param>
            <returns>set of refs to advertise.</returns>
            <exception cref="T:NGit.Transport.ServiceMayNotContinueException">abort; the message will be sent to the user.
            	</exception>
            <exception cref="T:NGit.Transport.ServiceMayNotContinueException"></exception>
        </member>
        <member name="M:NGit.Transport.AbstractAdvertiseRefsHook.GetAdvertisedHaves(NGit.Repository,NGit.Revwalk.RevWalk)">
            <summary>Get the additional haves to advertise.</summary>
            <remarks>Get the additional haves to advertise.</remarks>
            <param name="repository">repository instance.</param>
            <param name="revWalk">open rev walk on the repository.</param>
            <returns>
            set of additional haves; see
            <see cref="M:NGit.Transport.BaseReceivePack.GetAdvertisedObjects">BaseReceivePack.GetAdvertisedObjects()
            	</see>
            .
            </returns>
            <exception cref="T:NGit.Transport.ServiceMayNotContinueException">abort; the message will be sent to the user.
            	</exception>
            <exception cref="T:NGit.Transport.ServiceMayNotContinueException"></exception>
        </member>
        <member name="T:NGit.Transport.UploadPackInternalServerErrorException">
            <summary>UploadPack has already reported an error to the client.</summary>
            <remarks>UploadPack has already reported an error to the client.</remarks>
        </member>
        <member name="M:NGit.Transport.UploadPackInternalServerErrorException.#ctor(System.Exception)">
            <summary>Initialize a new exception.</summary>
            <remarks>Initialize a new exception.</remarks>
            <param name="why">root cause.</param>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Api.LsRemoteCommand" -->
        <member name="M:NGit.Api.LsRemoteCommand.#ctor(NGit.Repository)">
            <param name="repo"></param>
        </member>
        <member name="M:NGit.Api.LsRemoteCommand.SetRemote(System.String)">
            <summary>The remote (uri or name) used for the fetch operation.</summary>
            <remarks>
            The remote (uri or name) used for the fetch operation. If no remote is
            set, the default value of <code>Constants.DEFAULT_REMOTE_NAME</code> will
            be used.
            </remarks>
            <seealso cref="F:NGit.Constants.DEFAULT_REMOTE_NAME">NGit.Constants.DEFAULT_REMOTE_NAME
            	</seealso>
            <param name="remote"></param>
            <returns>
            
            <code>this</code>
            </returns>
        </member>
        <member name="M:NGit.Api.LsRemoteCommand.SetHeads(System.Boolean)">
            <summary>Include refs/heads in references results</summary>
            <param name="heads"></param>
            <returns>
            
            <code>this</code>
            </returns>
        </member>
        <member name="M:NGit.Api.LsRemoteCommand.SetTags(System.Boolean)">
            <summary>Include refs/tags in references results</summary>
            <param name="tags"></param>
            <returns>
            
            <code>this</code>
            </returns>
        </member>
        <member name="M:NGit.Api.LsRemoteCommand.SetUploadPack(System.String)">
            <summary>The full path of git-upload-pack on the remote host</summary>
            <param name="uploadPack"></param>
            <returns>
            
            <code>this</code>
            </returns>
        </member>
        <member name="M:NGit.Api.LsRemoteCommand.Call">
            <summary>
            Executes the
            <code>LsRemote</code>
            command with all the options and parameters
            collected by the setter methods (e.g.
            <see cref="M:NGit.Api.LsRemoteCommand.SetHeads(System.Boolean)">SetHeads(bool)</see>
            ) of this
            class. Each instance of this class should only be used for one invocation
            of the command. Don't call this method twice on an instance.
            </summary>
            <returns>a collection of references in the remote repository</returns>
            <exception cref="T:NGit.Api.Errors.InvalidRemoteException">when called with an invalid remote uri
            	</exception>
            <exception cref="T:NGit.Api.Errors.TransportException">for errors that occurs during transport
            	</exception>
            <exception cref="T:NGit.Api.Errors.GitAPIException"></exception>
        </member>
        <member name="T:NGit.Transport.Resolver.ServiceNotAuthorizedException">
            <summary>Indicates the request service is not authorized for current user.</summary>
            <remarks>Indicates the request service is not authorized for current user.</remarks>
        </member>
        <member name="M:NGit.Transport.Resolver.ServiceNotAuthorizedException.#ctor">
            <summary>Indicates the request service is not available.</summary>
            <remarks>Indicates the request service is not available.</remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Transport.HttpAuthMethod" -->
        <member name="F:NGit.Transport.HttpAuthMethod.NONE">
            <summary>No authentication is configured.</summary>
            <remarks>No authentication is configured.</remarks>
        </member>
        <member name="M:NGit.Transport.HttpAuthMethod.ScanResponse(Sharpen.HttpURLConnection)">
            <summary>Handle an authentication failure and possibly return a new response.</summary>
            <remarks>Handle an authentication failure and possibly return a new response.</remarks>
            <param name="conn">the connection that failed.</param>
            <returns>new authentication method to try.</returns>
        </member>
        <member name="M:NGit.Transport.HttpAuthMethod.Authorize(NGit.Transport.URIish,NGit.Transport.CredentialsProvider)">
            <summary>Update this method with the credentials from the URIish.</summary>
            <remarks>Update this method with the credentials from the URIish.</remarks>
            <param name="uri">the URI used to create the connection.</param>
            <param name="credentialsProvider">
            the credentials provider, or null. If provided,
            <see cref="M:NGit.Transport.URIish.GetPass">credentials in the URI</see>
            are ignored.
            </param>
            <returns>
            true if the authentication method is able to provide
            authorization for the given URI
            </returns>
        </member>
        <member name="M:NGit.Transport.HttpAuthMethod.Authorize(System.String,System.String)">
            <summary>Update this method with the given username and password pair.</summary>
            <remarks>Update this method with the given username and password pair.</remarks>
            <param name="user"></param>
            <param name="pass"></param>
        </member>
        <member name="M:NGit.Transport.HttpAuthMethod.ConfigureRequest(Sharpen.HttpURLConnection)">
            <summary>Update connection properties based on this authentication method.</summary>
            <remarks>Update connection properties based on this authentication method.</remarks>
            <param name="conn"></param>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="T:NGit.Transport.HttpAuthMethod.None">
            <summary>Performs no user authentication.</summary>
            <remarks>Performs no user authentication.</remarks>
        </member>
        <member name="M:NGit.Transport.HttpAuthMethod.None.ConfigureRequest(Sharpen.HttpURLConnection)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="T:NGit.Transport.HttpAuthMethod.Basic">
            <summary>Performs HTTP basic authentication (plaintext username/password).</summary>
            <remarks>Performs HTTP basic authentication (plaintext username/password).</remarks>
        </member>
        <member name="M:NGit.Transport.HttpAuthMethod.Basic.ConfigureRequest(Sharpen.HttpURLConnection)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="T:NGit.Transport.HttpAuthMethod.Digest">
            <summary>Performs HTTP digest authentication.</summary>
            <remarks>Performs HTTP digest authentication.</remarks>
        </member>
        <member name="M:NGit.Transport.HttpAuthMethod.Digest.ConfigureRequest(Sharpen.HttpURLConnection)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Transport.DefaultSshSessionFactory" -->
        <!-- Badly formed XML comment ignored for member "T:NGit.Transport.OpenSshConfig" -->
        <member name="F:NGit.Transport.OpenSshConfig.SSH_PORT">
            <summary>IANA assigned port number for SSH.</summary>
            <remarks>IANA assigned port number for SSH.</remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Transport.OpenSshConfig.Get(NGit.Util.FS)" -->
        <member name="F:NGit.Transport.OpenSshConfig.home">
            <summary>The user's home directory, as key files may be relative to here.</summary>
            <remarks>The user's home directory, as key files may be relative to here.</remarks>
        </member>
        <member name="F:NGit.Transport.OpenSshConfig.configFile">
            <summary>The .ssh/config file we read and monitor for updates.</summary>
            <remarks>The .ssh/config file we read and monitor for updates.</remarks>
        </member>
        <member name="F:NGit.Transport.OpenSshConfig.lastModified">
            <summary>
            Modification time of
            <see cref="F:NGit.Transport.OpenSshConfig.configFile">configFile</see>
            when
            <see cref="F:NGit.Transport.OpenSshConfig.hosts">hosts</see>
            loaded.
            </summary>
        </member>
        <member name="F:NGit.Transport.OpenSshConfig.hosts">
            <summary>Cached entries read out of the configuration file.</summary>
            <remarks>Cached entries read out of the configuration file.</remarks>
        </member>
        <member name="M:NGit.Transport.OpenSshConfig.Lookup(System.String)">
            <summary>Locate the configuration for a specific host request.</summary>
            <remarks>Locate the configuration for a specific host request.</remarks>
            <param name="hostName">
            the name the user has supplied to the SSH tool. This may be a
            real host name, or it may just be a "Host" block in the
            configuration file.
            </param>
            <returns>r configuration for the requested name. Never null.</returns>
        </member>
        <member name="M:NGit.Transport.OpenSshConfig.Parse(Sharpen.InputStream)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Transport.OpenSshConfig.Host" -->
        <member name="M:NGit.Transport.OpenSshConfig.Host.GetStrictHostKeyChecking">
            <returns>
            the value StrictHostKeyChecking property, the valid values
            are "yes" (unknown hosts are not accepted), "no" (unknown
            hosts are always accepted), and "ask" (user should be asked
            before accepting the host)
            </returns>
        </member>
        <member name="M:NGit.Transport.OpenSshConfig.Host.GetHostName">
            <returns>the real IP address or host name to connect to; never null.</returns>
        </member>
        <member name="M:NGit.Transport.OpenSshConfig.Host.GetPort">
            <returns>the real port number to connect to; never 0.</returns>
        </member>
        <member name="M:NGit.Transport.OpenSshConfig.Host.GetIdentityFile">
            <returns>
            path of the private key file to use for authentication; null
            if the caller should use default authentication strategies.
            </returns>
        </member>
        <member name="M:NGit.Transport.OpenSshConfig.Host.GetUser">
            <returns>the real user name to connect as; never null.</returns>
        </member>
        <member name="M:NGit.Transport.OpenSshConfig.Host.GetPreferredAuthentications">
            <returns>
            the preferred authentication methods, separated by commas if
            more than one authentication method is preferred.
            </returns>
        </member>
        <member name="M:NGit.Transport.OpenSshConfig.Host.IsBatchMode">
            <returns>
            true if batch (non-interactive) mode is preferred for this
            host connection.
            </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Transport.BundleWriter" -->
        <member name="M:NGit.Transport.BundleWriter.#ctor(NGit.Repository)">
            <summary>Create a writer for a bundle.</summary>
            <remarks>Create a writer for a bundle.</remarks>
            <param name="repo">repository where objects are stored.</param>
        </member>
        <member name="M:NGit.Transport.BundleWriter.SetPackConfig(NGit.Storage.Pack.PackConfig)">
            <summary>Set the configuration used by the pack generator.</summary>
            <remarks>Set the configuration used by the pack generator.</remarks>
            <param name="pc">
            configuration controlling packing parameters. If null the
            source repository's settings will be used.
            </param>
        </member>
        <member name="M:NGit.Transport.BundleWriter.Include(System.String,NGit.AnyObjectId)">
            <summary>Include an object (and everything reachable from it) in the bundle.</summary>
            <remarks>Include an object (and everything reachable from it) in the bundle.</remarks>
            <param name="name">
            name the recipient can discover this object as from the
            bundle's list of advertised refs . The name must be a valid
            ref format and must not have already been included in this
            bundle writer.
            </param>
            <param name="id">object to pack. Multiple refs may point to the same object.</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Transport.BundleWriter.Include(NGit.Ref)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Transport.BundleWriter.Assume(NGit.Revwalk.RevCommit)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Transport.BundleWriter.WriteBundle(NGit.ProgressMonitor,Sharpen.OutputStream)" -->
        <!-- Badly formed XML comment ignored for member "T:NGit.Transport.URIish" -->
        <member name="F:NGit.Transport.URIish.SCHEME_P">
            <summary>
            Part of a pattern which matches the scheme part (git, http, ...) of an
            URI.
            </summary>
            <remarks>
            Part of a pattern which matches the scheme part (git, http, ...) of an
            URI. Defines one capturing group containing the scheme without the
            trailing colon and slashes
            </remarks>
        </member>
        <member name="F:NGit.Transport.URIish.OPT_USER_PWD_P">
            <summary>Part of a pattern which matches the optional user/password part (e.g.</summary>
            <remarks>
            Part of a pattern which matches the optional user/password part (e.g.
            root:pwd@ in git://root:pwd@host.xyz/a.git) of URIs. Defines two
            capturing groups: the first containing the user and the second containing
            the password
            </remarks>
        </member>
        <member name="F:NGit.Transport.URIish.HOST_P">
            <summary>Part of a pattern which matches the host part of URIs.</summary>
            <remarks>
            Part of a pattern which matches the host part of URIs. Defines one
            capturing group containing the host name.
            </remarks>
        </member>
        <member name="F:NGit.Transport.URIish.OPT_PORT_P">
            <summary>Part of a pattern which matches the optional port part of URIs.</summary>
            <remarks>
            Part of a pattern which matches the optional port part of URIs. Defines
            one capturing group containing the port without the preceding colon.
            </remarks>
        </member>
        <member name="F:NGit.Transport.URIish.USER_HOME_P">
            <summary>Part of a pattern which matches the ~username part (e.g.</summary>
            <remarks>
            Part of a pattern which matches the ~username part (e.g. /~root in
            git://host.xyz/~root/a.git) of URIs. Defines no capturing group.
            </remarks>
        </member>
        <member name="F:NGit.Transport.URIish.OPT_DRIVE_LETTER_P">
            <summary>Part of a pattern which matches the optional drive letter in paths (e.g.
            	</summary>
            <remarks>
            Part of a pattern which matches the optional drive letter in paths (e.g.
            D: in file:///D:/a.txt). Defines no capturing group.
            </remarks>
        </member>
        <member name="F:NGit.Transport.URIish.RELATIVE_PATH_P">
            <summary>Part of a pattern which matches a relative path.</summary>
            <remarks>
            Part of a pattern which matches a relative path. Relative paths don't
            start with slash or drive letters. Defines no capturing group.
            </remarks>
        </member>
        <member name="F:NGit.Transport.URIish.PATH_P">
            <summary>Part of a pattern which matches a relative or absolute path.</summary>
            <remarks>
            Part of a pattern which matches a relative or absolute path. Defines no
            capturing group.
            </remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "F:NGit.Transport.URIish.FULL_URI" -->
        <member name="F:NGit.Transport.URIish.LOCAL_FILE">
            <summary>A pattern matching the reference to a local file.</summary>
            <remarks>
            A pattern matching the reference to a local file. This may be an absolute
            path (maybe even containing windows drive-letters) or a relative path.
            </remarks>
        </member>
        <member name="F:NGit.Transport.URIish.SINGLE_SLASH_FILE_URI">
            <summary>
            A pattern matching a URI for the scheme 'file' which has only ':/' as
            separator between scheme and path.
            </summary>
            <remarks>
            A pattern matching a URI for the scheme 'file' which has only ':/' as
            separator between scheme and path. Standard file URIs have '://' as
            separator, but java.io.File.toURI() constructs those URIs.
            </remarks>
        </member>
        <member name="F:NGit.Transport.URIish.RELATIVE_SCP_URI">
            <summary>A pattern matching a SCP URI's of the form user@host:path/to/repo.git</summary>
        </member>
        <member name="F:NGit.Transport.URIish.ABSOLUTE_SCP_URI">
            <summary>A pattern matching a SCP URI's of the form user@host:/path/to/repo.git</summary>
        </member>
        <member name="M:NGit.Transport.URIish.#ctor(System.String)">
            <summary>
            Parse and construct an
            <see cref="T:NGit.Transport.URIish">URIish</see>
            from a string
            </summary>
            <param name="s"></param>
            <exception cref="T:Sharpen.URISyntaxException">Sharpen.URISyntaxException</exception>
        </member>
        <member name="M:NGit.Transport.URIish.Unescape(System.String)">
            <exception cref="T:Sharpen.URISyntaxException"></exception>
        </member>
        <member name="M:NGit.Transport.URIish.Escape(System.String,System.Boolean,System.Boolean)">
            <summary>Escape unprintable characters optionally URI-reserved characters</summary>
            <param name="s">The Java String to encode (may contain any character)</param>
            <param name="escapeReservedChars">true to escape URI reserved characters</param>
            <param name="encodeNonAscii">encode any non-ASCII characters</param>
            <returns>a URI-encoded string</returns>
        </member>
        <member name="M:NGit.Transport.URIish.#ctor(System.Uri)">
            <summary>Construct a URIish from a standard URL.</summary>
            <remarks>Construct a URIish from a standard URL.</remarks>
            <param name="u">the source URL to convert from.</param>
        </member>
        <member name="M:NGit.Transport.URIish.#ctor">
            <summary>Create an empty, non-configured URI.</summary>
            <remarks>Create an empty, non-configured URI.</remarks>
        </member>
        <member name="M:NGit.Transport.URIish.IsRemote">
            <returns>true if this URI references a repository on another system.</returns>
        </member>
        <member name="M:NGit.Transport.URIish.GetHost">
            <returns>host name part or null</returns>
        </member>
        <member name="M:NGit.Transport.URIish.SetHost(System.String)">
            <summary>Return a new URI matching this one, but with a different host.</summary>
            <remarks>Return a new URI matching this one, but with a different host.</remarks>
            <param name="n">the new value for host.</param>
            <returns>a new URI with the updated value.</returns>
        </member>
        <member name="M:NGit.Transport.URIish.GetScheme">
            <returns>protocol name or null for local references</returns>
        </member>
        <member name="M:NGit.Transport.URIish.SetScheme(System.String)">
            <summary>Return a new URI matching this one, but with a different scheme.</summary>
            <remarks>Return a new URI matching this one, but with a different scheme.</remarks>
            <param name="n">the new value for scheme.</param>
            <returns>a new URI with the updated value.</returns>
        </member>
        <member name="M:NGit.Transport.URIish.GetPath">
            <returns>path name component</returns>
        </member>
        <member name="M:NGit.Transport.URIish.GetRawPath">
            <returns>path name component</returns>
        </member>
        <member name="M:NGit.Transport.URIish.SetPath(System.String)">
            <summary>Return a new URI matching this one, but with a different path.</summary>
            <remarks>Return a new URI matching this one, but with a different path.</remarks>
            <param name="n">the new value for path.</param>
            <returns>a new URI with the updated value.</returns>
        </member>
        <member name="M:NGit.Transport.URIish.SetRawPath(System.String)">
            <summary>Return a new URI matching this one, but with a different (raw) path.</summary>
            <remarks>Return a new URI matching this one, but with a different (raw) path.</remarks>
            <param name="n">the new value for path.</param>
            <returns>a new URI with the updated value.</returns>
            <exception cref="T:Sharpen.URISyntaxException">Sharpen.URISyntaxException</exception>
        </member>
        <member name="M:NGit.Transport.URIish.GetUser">
            <returns>user name requested for transfer or null</returns>
        </member>
        <member name="M:NGit.Transport.URIish.SetUser(System.String)">
            <summary>Return a new URI matching this one, but with a different user.</summary>
            <remarks>Return a new URI matching this one, but with a different user.</remarks>
            <param name="n">the new value for user.</param>
            <returns>a new URI with the updated value.</returns>
        </member>
        <member name="M:NGit.Transport.URIish.GetPass">
            <returns>password requested for transfer or null</returns>
        </member>
        <member name="M:NGit.Transport.URIish.SetPass(System.String)">
            <summary>Return a new URI matching this one, but with a different password.</summary>
            <remarks>Return a new URI matching this one, but with a different password.</remarks>
            <param name="n">the new value for password.</param>
            <returns>a new URI with the updated value.</returns>
        </member>
        <member name="M:NGit.Transport.URIish.GetPort">
            <returns>port number requested for transfer or -1 if not explicit</returns>
        </member>
        <member name="M:NGit.Transport.URIish.SetPort(System.Int32)">
            <summary>Return a new URI matching this one, but with a different port.</summary>
            <remarks>Return a new URI matching this one, but with a different port.</remarks>
            <param name="n">the new value for port.</param>
            <returns>a new URI with the updated value.</returns>
        </member>
        <member name="M:NGit.Transport.URIish.ToPrivateString">
            <summary>Obtain the string form of the URI, with the password included.</summary>
            <remarks>Obtain the string form of the URI, with the password included.</remarks>
            <returns>the URI, including its password field, if any.</returns>
        </member>
        <member name="M:NGit.Transport.URIish.ToASCIIString">
            <returns>the URI as an ASCII string. Password is not included.</returns>
        </member>
        <member name="M:NGit.Transport.URIish.ToPrivateASCIIString">
            <returns>
            the URI including password, formatted with only ASCII characters
            such that it will be valid for use over the network.
            </returns>
        </member>
        <member name="M:NGit.Transport.URIish.GetHumanishName">
            <summary>Get the "humanish" part of the path.</summary>
            <remarks>
            Get the "humanish" part of the path. Some examples of a 'humanish' part
            for a full path:
            <table>
            <tr>
            <th>Path</th>
            <th>Humanish part</th>
            </tr>
            <tr>
            <td><code>/path/to/repo.git</code></td>
            <td rowspan="4"><code>repo</code></td>
            </tr>
            <tr>
            <td><code>/path/to/repo.git/</code></td>
            </tr>
            <tr>
            <td><code>/path/to/repo/.git</code></td>
            </tr>
            <tr>
            <td><code>/path/to/repo/</code></td>
            </tr>
            <tr>
            <td><code>/path//to</code></td>
            <td>an empty string</td>
            </tr>
            </table>
            </remarks>
            <returns>
            the "humanish" part of the path. May be an empty string. Never
            <code>null</code>
            .
            </returns>
            <exception cref="T:System.ArgumentException">
            if it's impossible to determine a humanish part, or path is
            <code>null</code>
            or empty
            </exception>
            <seealso cref="M:NGit.Transport.URIish.GetPath">GetPath()</seealso>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Util.IO.MessageWriter" -->
        <member name="M:NGit.Util.IO.MessageWriter.#ctor">
            <summary>Create an empty writer.</summary>
            <remarks>Create an empty writer.</remarks>
        </member>
        <member name="M:NGit.Util.IO.MessageWriter.Write(System.Char[],System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Util.IO.MessageWriter.GetRawStream">
            <returns>
            the underlying byte stream that character writes to this writer
            drop into. Writes to this stream should should be in UTF-8.
            </returns>
        </member>
        <member name="M:NGit.Util.IO.MessageWriter.Close">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Util.IO.MessageWriter.Flush">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Util.IO.MessageWriter.ToString">
            <returns>string version of all buffered data.</returns>
        </member>
        <member name="T:NGit.Util.RawParseUtils">
            <summary>Handy utility functions to parse raw object contents.</summary>
            <remarks>Handy utility functions to parse raw object contents.</remarks>
        </member>
        <member name="M:NGit.Util.RawParseUtils.Match(System.Byte[],System.Int32,System.Byte[])">
            <summary>Determine if b[ptr] matches src.</summary>
            <remarks>Determine if b[ptr] matches src.</remarks>
            <param name="b">the buffer to scan.</param>
            <param name="ptr">first position within b, this should match src[0].</param>
            <param name="src">the buffer to test for equality with b.</param>
            <returns>ptr + src.length if b[ptr..src.length] == src; else -1.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Util.RawParseUtils.FormatBase10(System.Byte[],System.Int32,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Util.RawParseUtils.ParseBase10(System.Byte[],System.Int32,NGit.Util.MutableInteger)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Util.RawParseUtils.ParseLongBase10(System.Byte[],System.Int32,NGit.Util.MutableInteger)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Util.RawParseUtils.ParseHexInt16(System.Byte[],System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Util.RawParseUtils.ParseHexInt32(System.Byte[],System.Int32)" -->
        <member name="M:NGit.Util.RawParseUtils.ParseHexInt4(System.Byte)">
            <summary>Parse a single hex digit to its numeric value (0-15).</summary>
            <remarks>Parse a single hex digit to its numeric value (0-15).</remarks>
            <param name="digit">hex character to parse.</param>
            <returns>numeric value, in the range 0-15.</returns>
            <exception cref="T:System.IndexOutOfRangeException">if the input digit is not a valid hex digit.
            	</exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Util.RawParseUtils.ParseTimeZoneOffset(System.Byte[],System.Int32)" -->
        <member name="M:NGit.Util.RawParseUtils.Next(System.Byte[],System.Int32,System.Char)">
            <summary>Locate the first position after a given character.</summary>
            <remarks>Locate the first position after a given character.</remarks>
            <param name="b">buffer to scan.</param>
            <param name="ptr">position within buffer to start looking for chrA at.</param>
            <param name="chrA">character to find.</param>
            <returns>new position just after chrA.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Util.RawParseUtils.NextLF(System.Byte[],System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Util.RawParseUtils.NextLF(System.Byte[],System.Int32,System.Char)" -->
        <member name="M:NGit.Util.RawParseUtils.Prev(System.Byte[],System.Int32,System.Char)">
            <summary>Locate the first position before a given character.</summary>
            <remarks>Locate the first position before a given character.</remarks>
            <param name="b">buffer to scan.</param>
            <param name="ptr">position within buffer to start looking for chrA at.</param>
            <param name="chrA">character to find.</param>
            <returns>new position just before chrA, -1 for not found</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Util.RawParseUtils.PrevLF(System.Byte[],System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Util.RawParseUtils.PrevLF(System.Byte[],System.Int32,System.Char)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Util.RawParseUtils.LineMap(System.Byte[],System.Int32,System.Int32)" -->
        <member name="M:NGit.Util.RawParseUtils.Author(System.Byte[],System.Int32)">
            <summary>Locate the "author " header line data.</summary>
            <remarks>Locate the "author " header line data.</remarks>
            <param name="b">buffer to scan.</param>
            <param name="ptr">
            position in buffer to start the scan at. Most callers should
            pass 0 to ensure the scan starts from the beginning of the
            commit buffer and does not accidentally look at message body.
            </param>
            <returns>
            position just after the space in "author ", so the first
            character of the author's name. If no author header can be
            located -1 is returned.
            </returns>
        </member>
        <member name="M:NGit.Util.RawParseUtils.Committer(System.Byte[],System.Int32)">
            <summary>Locate the "committer " header line data.</summary>
            <remarks>Locate the "committer " header line data.</remarks>
            <param name="b">buffer to scan.</param>
            <param name="ptr">
            position in buffer to start the scan at. Most callers should
            pass 0 to ensure the scan starts from the beginning of the
            commit buffer and does not accidentally look at message body.
            </param>
            <returns>
            position just after the space in "committer ", so the first
            character of the committer's name. If no committer header can be
            located -1 is returned.
            </returns>
        </member>
        <member name="M:NGit.Util.RawParseUtils.Tagger(System.Byte[],System.Int32)">
            <summary>Locate the "tagger " header line data.</summary>
            <remarks>Locate the "tagger " header line data.</remarks>
            <param name="b">buffer to scan.</param>
            <param name="ptr">
            position in buffer to start the scan at. Most callers should
            pass 0 to ensure the scan starts from the beginning of the tag
            buffer and does not accidentally look at message body.
            </param>
            <returns>
            position just after the space in "tagger ", so the first
            character of the tagger's name. If no tagger header can be
            located -1 is returned.
            </returns>
        </member>
        <member name="M:NGit.Util.RawParseUtils.Encoding(System.Byte[],System.Int32)">
            <summary>Locate the "encoding " header line.</summary>
            <remarks>Locate the "encoding " header line.</remarks>
            <param name="b">buffer to scan.</param>
            <param name="ptr">
            position in buffer to start the scan at. Most callers should
            pass 0 to ensure the scan starts from the beginning of the
            buffer and does not accidentally look at the message body.
            </param>
            <returns>
            position just after the space in "encoding ", so the first
            character of the encoding's name. If no encoding header can be
            located -1 is returned (and UTF-8 should be assumed).
            </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Util.RawParseUtils.ParseEncoding(System.Byte[])" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Util.RawParseUtils.ParsePersonIdent(System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Util.RawParseUtils.ParsePersonIdent(System.Byte[],System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Util.RawParseUtils.ParsePersonIdentOnly(System.Byte[],System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:NGit.Util.RawParseUtils.EndOfFooterLineKey(System.Byte[],System.Int32)" -->
        <member name="M:NGit.Util.RawParseUtils.Decode(System.Byte[])">
            <summary>Decode a buffer under UTF-8, if possible.</summary>
            <remarks>
            Decode a buffer under UTF-8, if possible.
            If the byte stream cannot be decoded that way, the platform default is tried
            and if that too fails, the fail-safe ISO-8859-1 encoding is tried.
            </remarks>
            <param name="buffer">buffer to pull raw bytes from.</param>
            <returns>
            a string representation of the range <code>[start,end)</code>,
            after decoding the region through the specified character set.
            </returns>
        </member>
        <member name="M:NGit.Util.RawParseUtils.Decode(System.Byte[],System.Int32,System.Int32)">
            <summary>Decode a buffer under UTF-8, if possible.</summary>
            <remarks>
            Decode a buffer under UTF-8, if possible.
            If the byte stream cannot be decoded that way, the platform default is
            tried and if that too fails, the fail-safe ISO-8859-1 encoding is tried.
            </remarks>
            <param name="buffer">buffer to pull raw bytes from.</param>
            <param name="start">start position in buffer</param>
            <param name="end">
            one position past the last location within the buffer to take
            data from.
            </param>
            <returns>
            a string representation of the range <code>[start,end)</code>,
            after decoding the region through the specified character set.
            </returns>
        </member>
        <member name="M:NGit.Util.RawParseUtils.Decode(System.Text.Encoding,System.Byte[])">
            <summary>Decode a buffer under the specified character set if possible.</summary>
            <remarks>
            Decode a buffer under the specified character set if possible.
            If the byte stream cannot be decoded that way, the platform default is tried
            and if that too fails, the fail-safe ISO-8859-1 encoding is tried.
            </remarks>
            <param name="cs">character set to use when decoding the buffer.</param>
            <param name="buffer">buffer to pull raw bytes from.</param>
            <returns>
            a string representation of the range <code>[start,end)</code>,
            after decoding the region through the specified character set.
            </returns>
        </member>
        <member name="M:NGit.Util.RawParseUtils.Decode(System.Text.Encoding,System.Byte[],System.Int32,System.Int32)">
            <summary>Decode a region of the buffer under the specified character set if possible.
            	</summary>
            <remarks>
            Decode a region of the buffer under the specified character set if possible.
            If the byte stream cannot be decoded that way, the platform default is tried
            and if that too fails, the fail-safe ISO-8859-1 encoding is tried.
            </remarks>
            <param name="cs">character set to use when decoding the buffer.</param>
            <param name="buffer">buffer to pull raw bytes from.</param>
            <param name="start">first position within the buffer to take data from.</param>
            <param name="end">
            one position past the last location within the buffer to take
            data from.
            </param>
            <returns>
            a string representation of the range <code>[start,end)</code>,
            after decoding the region through the specified character set.
            </returns>
        </member>
        <member name="M:NGit.Util.RawParseUtils.DecodeNoFallback(System.Text.Encoding,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Decode a region of the buffer under the specified character set if
            possible.
            </summary>
            <remarks>
            Decode a region of the buffer under the specified character set if
            possible.
            If the byte stream cannot be decoded that way, the platform default is
            tried and if that too fails, an exception is thrown.
            </remarks>
            <param name="cs">character set to use when decoding the buffer.</param>
            <param name="buffer">buffer to pull raw bytes from.</param>
            <param name="start">first position within the buffer to take data from.</param>
            <param name="end">
            one position past the last location within the buffer to take
            data from.
            </param>
            <returns>
            a string representation of the range <code>[start,end)</code>,
            after decoding the region through the specified character set.
            </returns>
            <exception cref="T:Sharpen.CharacterCodingException">the input is not in any of the tested character sets.
            	</exception>
        </member>
        <member name="M:NGit.Util.RawParseUtils.ExtractBinaryString(System.Byte[],System.Int32,System.Int32)">
            <summary>Decode a region of the buffer under the ISO-8859-1 encoding.</summary>
            <remarks>
            Decode a region of the buffer under the ISO-8859-1 encoding.
            Each byte is treated as a single character in the 8859-1 character
            encoding, performing a raw binary-&gt;char conversion.
            </remarks>
            <param name="buffer">buffer to pull raw bytes from.</param>
            <param name="start">first position within the buffer to take data from.</param>
            <param name="end">
            one position past the last location within the buffer to take
            data from.
            </param>
            <returns>a string representation of the range <code>[start,end)</code>.</returns>
        </member>
        <member name="M:NGit.Util.RawParseUtils.Decode(Sharpen.ByteBuffer,System.Text.Encoding)">
            <exception cref="T:Sharpen.CharacterCodingException"></exception>
        </member>
        <member name="M:NGit.Util.RawParseUtils.CommitMessage(System.Byte[],System.Int32)">
            <summary>Locate the position of the commit message body.</summary>
            <remarks>Locate the position of the commit message body.</remarks>
            <param name="b">buffer to scan.</param>
            <param name="ptr">
            position in buffer to start the scan at. Most callers should
            pass 0 to ensure the scan starts from the beginning of the
            commit buffer.
            </param>
            <returns>position of the user's message buffer.</returns>
        </member>
        <member name="M:NGit.Util.RawParseUtils.TagMessage(System.Byte[],System.Int32)">
            <summary>Locate the position of the tag message body.</summary>
            <remarks>Locate the position of the tag message body.</remarks>
            <param name="b">buffer to scan.</param>
            <param name="ptr">
            position in buffer to start the scan at. Most callers should
            pass 0 to ensure the scan starts from the beginning of the tag
            buffer.
            </param>
            <returns>position of the user's message buffer.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Util.RawParseUtils.EndOfParagraph(System.Byte[],System.Int32)" -->
        <member name="T:NGit.Treewalk.Filter.NotTreeFilter">
            <summary>Includes an entry only if the subfilter does not include the entry.</summary>
            <remarks>Includes an entry only if the subfilter does not include the entry.</remarks>
        </member>
        <member name="M:NGit.Treewalk.Filter.NotTreeFilter.Create(NGit.Treewalk.Filter.TreeFilter)">
            <summary>Create a filter that negates the result of another filter.</summary>
            <remarks>Create a filter that negates the result of another filter.</remarks>
            <param name="a">filter to negate.</param>
            <returns>a filter that does the reverse of <code>a</code>.</returns>
        </member>
        <member name="M:NGit.Treewalk.Filter.NotTreeFilter.Include(NGit.Treewalk.TreeWalk)">
            <exception cref="T:NGit.Errors.MissingObjectException"></exception>
            <exception cref="T:NGit.Errors.IncorrectObjectTypeException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="T:NGit.Treewalk.WorkingTreeOptions">
            <summary>
            Options used by the
            <see cref="T:NGit.Treewalk.WorkingTreeIterator">WorkingTreeIterator</see>
            .
            </summary>
        </member>
        <member name="F:NGit.Treewalk.WorkingTreeOptions.KEY">
            <summary>
            Key for
            <see cref="M:NGit.Config.Get``1(NGit.Config.SectionParser{``0})">NGit.Config.Get&lt;T&gt;(NGit.Config.SectionParser&lt;T&gt;)
            	</see>
            .
            </summary>
        </member>
        <member name="M:NGit.Treewalk.WorkingTreeOptions.IsFileMode">
            <returns>true if the execute bit on working files should be trusted.</returns>
        </member>
        <member name="M:NGit.Treewalk.WorkingTreeOptions.GetAutoCRLF">
            <returns>how automatic CRLF conversion has been configured.</returns>
        </member>
        <member name="T:NGit.Storage.File.ReflogReader">
            <summary>Utility for reading reflog entries</summary>
        </member>
        <member name="M:NGit.Storage.File.ReflogReader.#ctor(NGit.Repository,System.String)">
            <param name="db"></param>
            <param name="refname"></param>
        </member>
        <member name="M:NGit.Storage.File.ReflogReader.GetLastEntry">
            <summary>Get the last entry in the reflog</summary>
            <returns>the latest reflog entry, or null if no log</returns>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:NGit.Storage.File.ReflogReader.GetReverseEntries">
            <returns>all reflog entries in reverse order</returns>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:NGit.Storage.File.ReflogReader.GetReverseEntry(System.Int32)">
            <summary>
            Get specific entry in the reflog relative to the last entry which is
            considered entry zero.
            </summary>
            <remarks>
            Get specific entry in the reflog relative to the last entry which is
            considered entry zero.
            </remarks>
            <param name="number"></param>
            <returns>reflog entry or null if not found</returns>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="M:NGit.Storage.File.ReflogReader.GetReverseEntries(System.Int32)">
            <param name="max">max number of entries to read</param>
            <returns>all reflog entries in reverse order</returns>
            <exception cref="T:System.IO.IOException">System.IO.IOException</exception>
        </member>
        <member name="T:NGit.Storage.File.PackIndexV2">
            <summary>Support for the pack index v2 format.</summary>
            <remarks>Support for the pack index v2 format.</remarks>
        </member>
        <member name="F:NGit.Storage.File.PackIndexV2.names">
            <summary>256 arrays of contiguous object names.</summary>
            <remarks>256 arrays of contiguous object names.</remarks>
        </member>
        <member name="F:NGit.Storage.File.PackIndexV2.offset32">
            <summary>
            256 arrays of the 32 bit offset data, matching
            <see cref="F:NGit.Storage.File.PackIndexV2.names">names</see>
            .
            </summary>
        </member>
        <member name="F:NGit.Storage.File.PackIndexV2.crc32">
            <summary>
            256 arrays of the CRC-32 of objects, matching
            <see cref="F:NGit.Storage.File.PackIndexV2.names">names</see>
            .
            </summary>
        </member>
        <member name="F:NGit.Storage.File.PackIndexV2.offset64">
            <summary>64 bit offset table.</summary>
            <remarks>64 bit offset table.</remarks>
        </member>
        <member name="M:NGit.Storage.File.PackIndexV2.#ctor(Sharpen.InputStream)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Storage.File.PackIndexV2.FindCRC32(NGit.AnyObjectId)">
            <exception cref="T:NGit.Errors.MissingObjectException"></exception>
        </member>
        <member name="M:NGit.Storage.File.PackIndexV2.Resolve(System.Collections.Generic.ICollection{NGit.ObjectId},NGit.AbbreviatedObjectId,System.Int32)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="T:NGit.Revwalk.TopoSortGenerator">
            <summary>Sorts commits in topological order.</summary>
            <remarks>Sorts commits in topological order.</remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NGit.Revwalk.TopoSortGenerator.#ctor(NGit.Revwalk.Generator)" -->
        <member name="M:NGit.Revwalk.TopoSortGenerator.Next">
            <exception cref="T:NGit.Errors.MissingObjectException"></exception>
            <exception cref="T:NGit.Errors.IncorrectObjectTypeException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="T:NGit.Revwalk.RevTree">
            <summary>A reference to a tree of subtrees/files.</summary>
            <remarks>A reference to a tree of subtrees/files.</remarks>
        </member>
        <member name="M:NGit.Revwalk.RevTree.#ctor(NGit.AnyObjectId)">
            <summary>Create a new tree reference.</summary>
            <remarks>Create a new tree reference.</remarks>
            <param name="id">object name for the tree.</param>
        </member>
        <member name="M:NGit.Revwalk.RevTree.ParseHeaders(NGit.Revwalk.RevWalk)">
            <exception cref="T:NGit.Errors.MissingObjectException"></exception>
            <exception cref="T:NGit.Errors.IncorrectObjectTypeException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Revwalk.RevTree.ParseBody(NGit.Revwalk.RevWalk)">
            <exception cref="T:NGit.Errors.MissingObjectException"></exception>
            <exception cref="T:NGit.Errors.IncorrectObjectTypeException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Revwalk.BlockObjQueue.#ctor">
            <summary>Create an empty queue.</summary>
            <remarks>Create an empty queue.</remarks>
        </member>
        <member name="F:NGit.Revwalk.BlockObjQueue.Block.next">
            <summary>Next block in our chain of blocks; null if we are the last.</summary>
            <remarks>Next block in our chain of blocks; null if we are the last.</remarks>
        </member>
        <member name="F:NGit.Revwalk.BlockObjQueue.Block.objects">
            <summary>Our table of queued objects.</summary>
            <remarks>Our table of queued objects.</remarks>
        </member>
        <member name="F:NGit.Revwalk.BlockObjQueue.Block.headIndex">
            <summary>
            Next valid entry in
            <see cref="F:NGit.Revwalk.BlockObjQueue.Block.objects">objects</see>
            .
            </summary>
        </member>
        <member name="F:NGit.Revwalk.BlockObjQueue.Block.tailIndex">
            <summary>
            Next free entry in
            <see cref="F:NGit.Revwalk.BlockObjQueue.Block.objects">objects</see>
            for addition at.
            </summary>
        </member>
        <member name="T:NGit.Errors.StopWalkException">
            <summary>Stops the driver loop of walker and finish with current results.</summary>
            <remarks>Stops the driver loop of walker and finish with current results.</remarks>
            <seealso cref="T:NGit.Revwalk.Filter.RevFilter">NGit.Revwalk.Filter.RevFilter</seealso>
        </member>
        <member name="F:NGit.Errors.StopWalkException.INSTANCE">
            <summary>Singleton instance for throwing within a filter.</summary>
            <remarks>Singleton instance for throwing within a filter.</remarks>
        </member>
        <member name="T:NGit.Errors.CompoundException">
            <summary>An exception detailing multiple reasons for failure.</summary>
            <remarks>An exception detailing multiple reasons for failure.</remarks>
        </member>
        <member name="M:NGit.Errors.CompoundException.#ctor(System.Collections.Generic.ICollection{System.Exception})">
            <summary>Constructs an exception detailing many potential reasons for failure.</summary>
            <remarks>Constructs an exception detailing many potential reasons for failure.</remarks>
            <param name="why">Two or more exceptions that may have been the problem.</param>
        </member>
        <member name="M:NGit.Errors.CompoundException.GetAllCauses">
            <summary>Get the complete list of reasons why this failure happened.</summary>
            <remarks>Get the complete list of reasons why this failure happened.</remarks>
            <returns>unmodifiable collection of all possible reasons.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Diff.MyersDiff`1" -->
        <member name="F:NGit.Diff.MyersDiff`1.INSTANCE">
            <summary>Singleton instance of MyersDiff.</summary>
            <remarks>Singleton instance of MyersDiff.</remarks>
        </member>
        <member name="F:NGit.Diff.MyersDiff`1.edits">
            <summary>
            The list of edits found during the last call to
            <see cref="M:NGit.Diff.MyersDiff`1.CalculateEdits(NGit.Diff.Edit)">MyersDiff&lt;S&gt;.CalculateEdits(Edit)
            	</see>
            </summary>
        </member>
        <member name="F:NGit.Diff.MyersDiff`1.cmp">
            <summary>Comparison function for sequences.</summary>
            <remarks>Comparison function for sequences.</remarks>
        </member>
        <member name="F:NGit.Diff.MyersDiff`1.a">
            <summary>The first text to be compared.</summary>
            <remarks>The first text to be compared. Referred to as "Text A" in the comments</remarks>
        </member>
        <member name="F:NGit.Diff.MyersDiff`1.b">
            <summary>The second text to be compared.</summary>
            <remarks>The second text to be compared. Referred to as "Text B" in the comments</remarks>
        </member>
        <member name="M:NGit.Diff.MyersDiff`1.CalculateEdits(NGit.Diff.Edit)">
            <summary>Entrypoint into the algorithm this class is all about.</summary>
            <remarks>
            Entrypoint into the algorithm this class is all about. This method triggers that the
            differences between A and B are calculated in form of a list of edits.
            </remarks>
            <param name="r">portion of the sequences to examine.</param>
        </member>
        <member name="M:NGit.Diff.MyersDiff`1.CalculateEdits(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>Calculates the differences between a given part of A against another given part of B
            	</summary>
            <param name="beginA">start of the part of A which should be compared (0&lt;=beginA&lt;sizeof(A))
            	</param>
            <param name="endA">end of the part of A which should be compared (beginA&lt;=endA&lt;sizeof(A))
            	</param>
            <param name="beginB">start of the part of B which should be compared (0&lt;=beginB&lt;sizeof(B))
            	</param>
            <param name="endB">end of the part of B which should be compared (beginB&lt;=endB&lt;sizeof(B))
            	</param>
        </member>
        <member name="M:NGit.Diff.MyersDiff`1.Main(System.String[])">
            <param name="args">two filenames specifying the contents to be diffed</param>
        </member>
        <member name="T:NGit.Diff.MyersDiff`1.MiddleEdit">
            <summary>
            A class to help bisecting the sequences a and b to find minimal
            edit paths.
            </summary>
            <remarks>
            A class to help bisecting the sequences a and b to find minimal
            edit paths.
            As the arrays are reused for space efficiency, you will need one
            instance per thread.
            The entry function is the calculate() method.
            </remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NGit.Api.CommitCommand" -->
        <member name="F:NGit.Api.CommitCommand.parents">
            <summary>parents this commit should have.</summary>
            <remarks>
            parents this commit should have. The current HEAD will be in this list
            and also all commits mentioned in .git/MERGE_HEAD
            </remarks>
        </member>
        <member name="M:NGit.Api.CommitCommand.#ctor(NGit.Repository)">
            <param name="repo"></param>
        </member>
        <member name="M:NGit.Api.CommitCommand.Call">
            <summary>
            Executes the
            <code>commit</code>
            command with all the options and parameters
            collected by the setter methods of this class. Each instance of this
            class should only be used for one invocation of the command (means: one
            call to
            <see cref="M:NGit.Api.CommitCommand.Call">Call()</see>
            )
            </summary>
            <returns>
            a
            <see cref="T:NGit.Revwalk.RevCommit">NGit.Revwalk.RevCommit</see>
            object representing the successful commit.
            </returns>
            <exception cref="T:NGit.Api.Errors.NoHeadException">when called on a git repo without a HEAD reference
            	</exception>
            <exception cref="T:NGit.Api.Errors.NoMessageException">when called without specifying a commit message
            	</exception>
            <exception cref="T:NGit.Api.Errors.UnmergedPathsException">when the current index contained unmerged paths (conflicts)
            	</exception>
            <exception cref="T:NGit.Api.Errors.ConcurrentRefUpdateException">
            when HEAD or branch ref is updated concurrently by someone
            else
            </exception>
            <exception cref="T:NGit.Api.Errors.WrongRepositoryStateException">when repository is not in the right state for committing
            	</exception>
            <exception cref="T:NGit.Api.Errors.GitAPIException"></exception>
        </member>
        <member name="M:NGit.Api.CommitCommand.InsertChangeId(NGit.ObjectId)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Api.CommitCommand.CreateTemporaryIndex(NGit.ObjectId,NGit.Dircache.DirCache)">
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NGit.Api.CommitCommand.LookupOnly(System.String)">
            <summary>
            Look an entry's path up in the list of paths specified by the --only/ -o
            option
            In case the complete (file) path (e.g.
            </summary>
            <remarks>
            Look an entry's path up in the list of paths specified by the --only/ -o
            option
            In case the complete (file) path (e.g. "d1/d2/f1") cannot be found in
            <code>only</code>, lookup is also tried with (parent) directory paths
            (e.g. "d1/d2" and "d1").
            </remarks>
            <param name="pathString">entry's path</param>
            <returns>the item's index in <code>only</code>; -1 if no item matches</returns>
        </member>
        <member name="M:NGit.Api.CommitCommand.ProcessOptions(NGit.RepositoryState)">
            <summary>Sets default values for not explicitly specified options.</summary>
            <remarks>
            Sets default values for not explicitly specified options. Then validates
            that all required data has been provided.
            </remarks>
            <param name="state">the state of the repository we are working on</param>
            <exception cref="T:NGit.Api.Errors.NoMessageException">if the commit message has not been specified
            	</exception>
        </member>
        <member name="M:NGit.Api.CommitCommand.SetMessage(System.String)">
            <param name="message">
            the commit message used for the
            <code>commit</code>
            </param>
            <returns>
            
            <code>this</code>
            </returns>
        </member>
        <member name="M:NGit.Api.CommitCommand.GetMessage">
            <returns>the commit message used for the <code>commit</code></returns>
        </member>
        <member name="M:NGit.Api.CommitCommand.SetCommitter(NGit.PersonIdent)">
            <summary>
            Sets the committer for this
            <code>commit</code>
            . If no committer is explicitly
            specified because this method is never called or called with
            <code>null</code>
            value then the committer will be deduced from config info in repository,
            with current time.
            </summary>
            <param name="committer">
            the committer used for the
            <code>commit</code>
            </param>
            <returns>
            
            <code>this</code>
            </returns>
        </member>
        <member name="M:NGit.Api.CommitCommand.SetCommitter(System.String,System.String)">
            <summary>
            Sets the committer for this
            <code>commit</code>
            . If no committer is explicitly
            specified because this method is never called or called with
            <code>null</code>
            value then the committer will be deduced from config info in repository,
            with current time.
            </summary>
            <param name="name">
            the name of the committer used for the
            <code>commit</code>
            </param>
            <param name="email">
            the email of the committer used for the
            <code>commit</code>
            </param>
            <returns>
            
            <code>this</code>
            </returns>
        </member>
        <member name="M:NGit.Api.CommitCommand.GetCommitter">
            <returns>
            the committer used for the
            <code>commit</code>
            . If no committer was
            specified
            <code>null</code>
            is returned and the default
            <see cref="T:NGit.PersonIdent">NGit.PersonIdent</see>
            of this repo is used during execution of the
            command
            </returns>
        </member>
        <member name="M:NGit.Api.CommitCommand.SetAuthor(NGit.PersonIdent)">
            <summary>
            Sets the author for this
            <code>commit</code>
            . If no author is explicitly
            specified because this method is never called or called with
            <code>null</code>
            value then the author will be set to the committer.
            </summary>
            <param name="author">
            the author used for the
            <code>commit</code>
            </param>
            <returns>
            
            <code>this</code>
            </returns>
        </member>
        <member name="M:NGit.Api.CommitCommand.SetAuthor(System.String,System.String)">
            <summary>
            Sets the author for this
            <code>commit</code>
            . If no author is explicitly
            specified because this method is never called or called with
            <code>null</code>
            value then the author will be set to the committer.
            </summary>
            <param name="name">
            the name of the author used for the
            <code>commit</code>
            </param>
            <param name="email">
            the email of the author used for the
            <code>commit</code>
            </param>
            <returns>
            
            <code>this</code>
            </returns>
        </member>
        <member name="M:NGit.Api.CommitCommand.GetAuthor">
            <returns>
            the author used for the
            <code>commit</code>
            . If no author was
            specified
            <code>null</code>
            is returned and the default
            <see cref="T:NGit.PersonIdent">NGit.PersonIdent</see>
            of this repo is used during execution of the
            command
            </returns>
        </member>
        <member name="M:NGit.Api.CommitCommand.SetAll(System.Boolean)">
            <summary>
            If set to true the Commit command automatically stages files that have
            been modified and deleted, but new files not known by the repository are
            not affected.
            </summary>
            <remarks>
            If set to true the Commit command automatically stages files that have
            been modified and deleted, but new files not known by the repository are
            not affected. This corresponds to the parameter -a on the command line.
            </remarks>
            <param name="all"></param>
            <returns>
            
            <code>this</code>
            </returns>
            <exception cref="T:NGit.Api.Errors.JGitInternalException">in case of an illegal combination of arguments/ options
            	</exception>
        </member>
        <member name="M:NGit.Api.CommitCommand.SetAmend(System.Boolean)">
            <summary>Used to amend the tip of the current branch.</summary>
            <remarks>
            Used to amend the tip of the current branch. If set to true, the previous
            commit will be amended. This is equivalent to --amend on the command
            line.
            </remarks>
            <param name="amend"></param>
            <returns>
            
            <code>this</code>
            </returns>
        </member>
        <member name="M:NGit.Api.CommitCommand.SetOnly(System.String)">
            <summary>
            Commit dedicated path only
            This method can be called several times to add multiple paths.
            </summary>
            <remarks>
            Commit dedicated path only
            This method can be called several times to add multiple paths. Full file
            paths are supported as well as directory paths; in the latter case this
            commits all files/ directories below the specified path.
            </remarks>
            <param name="only">path to commit</param>
            <returns>
            
            <code>this</code>
            </returns>
        </member>
        <member name="M:NGit.Api.CommitCommand.SetInsertChangeId(System.Boolean)">
            <summary>
            If set to true a change id will be inserted into the commit message
            An existing change id is not replaced.
            </summary>
            <remarks>
            If set to true a change id will be inserted into the commit message
            An existing change id is not replaced. An initial change id (I000...)
            will be replaced by the change id.
            </remarks>
            <param name="insertChangeId"></param>
            <returns>
            
            <code>this</code>
            </returns>
        </member>
        <member name="M:NGit.Api.CommitCommand.SetReflogComment(System.String)">
            <summary>Override the message written to the reflog</summary>
            <param name="reflogComment"></param>
            <returns>
            
            <code>this</code>
            </returns>
        </member>
        <member name="T:NGit.NullProgressMonitor">
            <summary>A NullProgressMonitor does not report progress anywhere.</summary>
            <remarks>A NullProgressMonitor does not report progress anywhere.</remarks>
        </member>
        <member name="F:NGit.NullProgressMonitor.INSTANCE">
            <summary>Immutable instance of a null progress monitor.</summary>
            <remarks>Immutable instance of a null progress monitor.</remarks>
        </member>
    </members>
</doc>
